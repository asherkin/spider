// vim: set ts=4 sw=4 tw=99 noet:
//
// AMX Mod X, based on AMX Mod by Aleksander Naszko ("OLO").
// Copyright (C) The AMX Mod X Development Team.
//
// This software is licensed under the GNU General Public License, version 3 or higher.
// Additional exceptions apply. For full license details, see LICENSE.txt or visit:
//     https://alliedmods.net/amxmodx-license

#if defined _amxconst_included
  #endinput
#endif
#define _amxconst_included

#include <amxmodx_version>

/**
 * Internal AMXX buffer size for string retrieval.
 *
 * @note This is the buffer size AMX Mod X uses internally to retrieve strings
 *       from plugins. Most natives that take strings as arguments will
 *       implicitly truncate them to this maximum length. This has been raised
 *       to the current value with AMXX 1.8.3. Previously the limit was 3072.
 * @note This is here mainly for documentation purposes. By default plugins
 *       don't have enough memory available to allocate an array of this size.
 *       You probably should not use this to actually declare a buffer unless
 *       you *absolutely* have to. Look at #pragma dynamic to increase a plugins
 *       available memory.
 */
#define MAX_STRING_LENGTH 16384

/**
 * Defines and constants related to the maximum number of clients.
 *
 * @note  MAX_PLAYERS is not the same as MaxClients. MAX_PLAYERS is a hardcoded
 *        value as an upper limit, used mainly to declare arrays big enough for
 *        all possible server situations. MaxClients changes based on the
 *        server the plugin is deployed on..
 */
#define MAX_PLAYERS 33 /* Maximum number of players AMX Mod X supports */

public stock const MaxClients; /* Maximum number of players the server supports */

/**
 * The maximum buffer size required to store a clients name.
 */
#define MAX_NAME_LENGTH 32

/**
 * Ï€
 */
#define M_PI 3.1415926535

/**
 * @section Admin privilege and authentication constants
 */

/**
 * Admin level constants
 */
#define ADMIN_ALL           0       /* everyone */
#define ADMIN_IMMUNITY      (1<<0)  /* flag "a" */
#define ADMIN_RESERVATION   (1<<1)  /* flag "b" */
#define ADMIN_KICK          (1<<2)  /* flag "c" */
#define ADMIN_BAN           (1<<3)  /* flag "d" */
#define ADMIN_SLAY          (1<<4)  /* flag "e" */
#define ADMIN_MAP           (1<<5)  /* flag "f" */
#define ADMIN_CVAR          (1<<6)  /* flag "g" */
#define ADMIN_CFG           (1<<7)  /* flag "h" */
#define ADMIN_CHAT          (1<<8)  /* flag "i" */
#define ADMIN_VOTE          (1<<9)  /* flag "j" */
#define ADMIN_PASSWORD      (1<<10) /* flag "k" */
#define ADMIN_RCON          (1<<11) /* flag "l" */
#define ADMIN_LEVEL_A       (1<<12) /* flag "m" */
#define ADMIN_LEVEL_B       (1<<13) /* flag "n" */
#define ADMIN_LEVEL_C       (1<<14) /* flag "o" */
#define ADMIN_LEVEL_D       (1<<15) /* flag "p" */
#define ADMIN_LEVEL_E       (1<<16) /* flag "q" */
#define ADMIN_LEVEL_F       (1<<17) /* flag "r" */
#define ADMIN_LEVEL_G       (1<<18) /* flag "s" */
#define ADMIN_LEVEL_H       (1<<19) /* flag "t" */
#define ADMIN_MENU          (1<<20) /* flag "u" */
#define ADMIN_BAN_TEMP      (1<<21) /* flag "v" */
#define ADMIN_ADMIN         (1<<24) /* flag "y" */
#define ADMIN_USER          (1<<25) /* flag "z" */

/**
 * Admin authentication behavior flags
 */
#define FLAG_KICK           (1<<0)  /* flag "a" */
#define FLAG_TAG            (1<<1)  /* flag "b" */
#define FLAG_AUTHID         (1<<2)  /* flag "c" */
#define FLAG_IP             (1<<3)  /* flag "d" */
#define FLAG_NOPASS         (1<<4)  /* flag "e" */
#define FLAG_CASE_SENSITIVE (1<<10) /* flag "k" */

/**
 * @endsection
 */

/**
 * Return codes
 */
#define PLUGIN_CONTINUE     0   /* Results returned by public functions */
#define PLUGIN_HANDLED      1   /* stop other plugins */
#define PLUGIN_HANDLED_MAIN 2   /* to use in client_command(), continue all plugins but stop the command */

/**
 * CVAR flags for register_cvar()
 */
#define FCVAR_ARCHIVE       1   /* set to cause it to be saved to vars.rc */
#define FCVAR_USERINFO      2   /* changes the client's info string */
#define FCVAR_SERVER        4   /* notifies players when changed */
#define FCVAR_EXTDLL        8   /* defined by external DLL */
#define FCVAR_CLIENTDLL     16  /* defined by the client dll */
#define FCVAR_PROTECTED     32  /* It's a server cvar, but we don't send the data since it's a password, etc.  Sends 1 if it's not bland/zero, 0 otherwise as value */
#define FCVAR_SPONLY        64  /* This cvar cannot be changed by clients connected to a multiplayer server. */
#define FCVAR_PRINTABLEONLY 128 /* This cvar's string cannot contain unprintable characters ( e.g., used for player name etc ). */
#define FCVAR_UNLOGGED      256 /* If this is a FCVAR_SERVER, don't log changes to the log file / console if we are creating a log */

/**
 * IDs of weapons in CS
 */
#define CSW_P228            1
#define CSW_SCOUT           3
#define CSW_HEGRENADE       4
#define CSW_XM1014          5
#define CSW_C4              6
#define CSW_MAC10           7
#define CSW_AUG             8
#define CSW_SMOKEGRENADE    9
#define CSW_ELITE           10
#define CSW_FIVESEVEN       11
#define CSW_UMP45           12
#define CSW_SG550           13
#define CSW_GALI            14
#define CSW_GALIL           14
#define CSW_FAMAS           15
#define CSW_USP             16
#define CSW_GLOCK18         17
#define CSW_AWP             18
#define CSW_MP5NAVY         19
#define CSW_M249            20
#define CSW_M3              21
#define CSW_M4A1            22
#define CSW_TMP             23
#define CSW_G3SG1           24
#define CSW_FLASHBANG       25
#define CSW_DEAGLE          26
#define CSW_SG552           27
#define CSW_AK47            28
#define CSW_KNIFE           29
#define CSW_P90             30
#define CSW_VEST            31  // Custom
#define CSW_VESTHELM        32  // Custom
#define CSW_SHIELDGUN       99

/**
 * HI weapon constants
 */
#define HIW_BERETTA     1
#define HIW_SPAS12      2
#define HIW_M4A1        3
#define HIW_MP5A4       4
#define HIW_MP5SD5      5
#define HIW_AK47        6
#define HIW_AKS74U      7
#define HIW_GLOCK       8
#define HIW_M11         9
#define HIW_M11SD       10
#define HIW_PSG1        11
#define HIW_ZASTAVA     12
#define HIW_M16A2       13
#define HIW_REMINGTON   14
#define HIW_NATOGREN    15
#define HIW_TANGOGREN   16
#define HIW_FLASHBANG   17

/**
 * Parts of body for hits
 */
#define HIT_GENERIC     0   /* none */
#define HIT_HEAD        1
#define HIT_CHEST       2
#define HIT_STOMACH     3
#define HIT_LEFTARM     4
#define HIT_RIGHTARM    5
#define HIT_LEFTLEG     6
#define HIT_RIGHTLEG    7

/**
 * @section emit_sound() constants
 */

/**
 * Channels
 */
#define CHAN_AUTO       0
#define CHAN_WEAPON     1
#define CHAN_VOICE      2
#define CHAN_ITEM       3
#define CHAN_BODY       4
#define CHAN_STREAM     5   /* allocate stream channel from the static or dynamic area */
#define CHAN_STATIC     6   /* allocate channel from the static area  */
#define CHAN_NETWORKVOICE_BASE  7   /* voice data coming across the network */
#define CHAN_NETWORKVOICE_END   500 /* network voice data reserves slots (CHAN_NETWORKVOICE_BASE through CHAN_NETWORKVOICE_END). */

/**
 *Attenuation values
 */
#define ATTN_NONE       0.00
#define ATTN_NORM       0.80
#define ATTN_IDLE       2.00
#define ATTN_STATIC     1.25

/**
 * Pitch values
 */
#define PITCH_NORM      100 /* non-pitch shifted */
#define PITCH_LOW       95  /* other values are possible - 0-255, where 255 is very high */
#define PITCH_HIGH      120

/**
 * Volume values
 */
#define VOL_NORM        1.0

/**
 * Sound behavior constants
 */
#define SND_SPAWNING        (1<<8)      // we're spawing, used in some cases for ambients
#define SND_STOP            (1<<5)      // stop sound
#define SND_CHANGE_VOL      (1<<6)      // change sound vol
#define SND_CHANGE_PITCH    (1<<7)      // change sound pitch

/**
 * @endsection
 */

/**
 * Menu keys
 */
#define MENU_KEY_1      (1<<0)
#define MENU_KEY_2      (1<<1)
#define MENU_KEY_3      (1<<2)
#define MENU_KEY_4      (1<<3)
#define MENU_KEY_5      (1<<4)
#define MENU_KEY_6      (1<<5)
#define MENU_KEY_7      (1<<6)
#define MENU_KEY_8      (1<<7)
#define MENU_KEY_9      (1<<8)
#define MENU_KEY_0      (1<<9)

/**
 * Language constants
 */
#define LANG_SERVER     0
#define LANG_PLAYER     -1

/**
 * @section Client print native constants
 */

/**
 * Destination types for client_print()
 */
enum
{
	print_notify = 1,
	print_console,
	print_chat,
	print_center,
	print_radio     /* Counter-Strike only */
};

/**
 * Color types for client_print_color()
 */
enum
{
	print_team_default = 0,
	print_team_grey = -1,
	print_team_red = -2,
	print_team_blue = -3,
};

/**
 * Destination types for engclient_print()
 */
enum
{
	engprint_console = 0,
	engprint_center,
	engprint_chat,
};

/**
 * @endsection
 */

/**
 * @section Entity rendering constants
 */

/**
 * Rendering modes (i.e. for set_user_rendering())
 */
enum
{
	kRenderNormal = 0,      /* src */
	kRenderTransColor,      /* c*a+dest*(1-a) */
	kRenderTransTexture,    /* src*a+dest*(1-a) */
	kRenderGlow,            /* src*a+dest -- No Z buffer checks */
	kRenderTransAlpha,      /* src*srca+dest*(1-srca) */
	kRenderTransAdd,        /* src*a+dest */
};

/**
 * Rendering fx (i.e. for set_user_rendering())
 */
enum
{
	kRenderFxNone = 0,
	kRenderFxPulseSlow,
	kRenderFxPulseFast,
	kRenderFxPulseSlowWide,
	kRenderFxPulseFastWide,
	kRenderFxFadeSlow,
	kRenderFxFadeFast,
	kRenderFxSolidSlow,
	kRenderFxSolidFast,
	kRenderFxStrobeSlow,
	kRenderFxStrobeFast,
	kRenderFxStrobeFaster,
	kRenderFxFlickerSlow,
	kRenderFxFlickerFast,
	kRenderFxNoDissipation,
	kRenderFxDistort,           /* Distort/scale/translate flicker */
	kRenderFxHologram,          /* kRenderFxDistort + distance fade */
	kRenderFxDeadPlayer,        /* kRenderAmt is the player index */
	kRenderFxExplode,           /* Scale up really big! */
	kRenderFxGlowShell,         /* Glowing Shell */
	kRenderFxClampMinScale,     /* Keep this sprite from getting very small (SPRITES only!) */
};

/**
 * @endsection
 */

/**
 * Type for force_unmodified()
 */
enum
{
	force_exactfile = 0,        /* File on client must exactly match server's file */
	force_model_samebounds,     /* For model files only, the geometry must fit in the same bbox */
	force_model_specifybounds,  /* For model files only, the geometry must fit in the specified bbox */
};

/**
 * Status for get_module()
 */
enum
{
	module_none = 0,
	module_query,
	module_badload,
	module_loaded,
	module_noinfo,
	module_noquery,
	module_noattach,
	module_old,
};

/**
 * AMX flag constants
 */
#define AMX_FLAG_DEBUG      0x02    /* symbolic info. available */
#define AMX_FLAG_COMPACT    0x04    /* compact encoding */
#define AMX_FLAG_BYTEOPC    0x08    /* opcode is a byte (not a cell) */
#define AMX_FLAG_NOCHECKS   0x10    /* no array bounds checking; no STMT opcode */
#define AMX_FLAG_NTVREG     0x1000  /* all native functions are registered */
#define AMX_FLAG_JITC       0x2000  /* abstract machine is JIT compiled */
#define AMX_FLAG_BROWSE     0x4000  /* busy browsing */
#define AMX_FLAG_RELOC      0x8000  /* jump/call addresses relocated */

/**
 * Invalid plugin id
 */
#define INVALID_PLUGIN_ID   -1

/**
 * Menu and menu item status codes
 */
#define MENU_TIMEOUT    -4
#define MENU_EXIT       -3
#define MENU_BACK       -2
#define MENU_MORE       -1
#define ITEM_IGNORE     0
#define ITEM_ENABLED    1
#define ITEM_DISABLED   2

/**
 * AMX error codes
 */
#define AMX_ERR_NATIVE      10
#define AMX_ERR_MEMACCESS   5
#define AMX_ERR_NONE        0
#define AMX_ERR_BOUNDS      4
#define AMX_ERR_STACKERR    3
#define AMX_ERR_STACKLOW    7
#define AMX_ERR_HEAPLOW     8
#define AMX_ERR_DIVIDE      11
#define AMX_ERR_NOTFOUND    19
#define AMX_ERR_PARAMS      25
#define AMX_ERR_GENERAL     27

/**
 * Generic invalid handle value
 */
#define INVALID_HANDLE      -1

/**
 * @section Plugin forward related constants
 */

/**
 * Stop types for plugin forwards
 */
#define ET_IGNORE       0   //ignore return val
#define ET_STOP         1   //stop on PLUGIN_HANDLED
#define ET_STOP2        2   //same, except return biggest
#define ET_CONTINUE     3   //no stop, return biggest

/**
 * Parameter types for plugin forwards
 */
#define FP_CELL         0
#define FP_FLOAT        1
#define FP_STRING       2
#define FP_ARRAY        4

/**
 * @endsection
 */

/**
 * LibType constants
 */
enum LibType
{
	LibType_Library,
	LibType_Class
};

/**
 * AdminProp constants
 */
enum AdminProp
{
	AdminProp_Auth = 0,
	AdminProp_Password,
	AdminProp_Access,
	AdminProp_Flags
};
// vim: set ts=4 sw=4 tw=99 noet:
//
// AMX Mod X, based on AMX Mod by Aleksander Naszko ("OLO").
// Copyright (C) The AMX Mod X Development Team.
//
// This software is licensed under the GNU General Public License, version 3 or higher.
// Additional exceptions apply. For full license details, see LICENSE.txt or visit:
//     https://alliedmods.net/amxmodx-license

#if defined _amxmisc_included
  #endinput
#endif
#define _amxmisc_included

#if !defined _amxmodx_included
	#include <amxmodx>
#endif

stock is_user_admin(id)
{
	new __flags=get_user_flags(id);
	return (__flags>0 && !(__flags&ADMIN_USER));
}

stock cmd_access(id, level, cid, num, bool:accesssilent = false) 
{
	new has_access = 0;
	if ( id==(is_dedicated_server()?0:1) ) 
	{
		has_access = 1;
	}
	else if ( level==ADMIN_ADMIN )
	{
		if ( is_user_admin(id) )
		{
			has_access = 1;
		}
	}
	else if ( get_user_flags(id) & level )
	{
		has_access = 1;
	}
	else if (level == ADMIN_ALL) 
	{
		has_access = 1;
	}

	if ( has_access==0 ) 
	{
		if (!accesssilent)
		{
			console_print(id,"%L",id,"NO_ACC_COM");
		}
		return 0;
	}
	if (read_argc() < num) 
	{
		new hcmd[32], hinfo[128], hflag;
		get_concmd(cid,hcmd,31,hflag,hinfo,127,level);
		console_print(id,"%L:  %s %s",id,"USAGE",hcmd,hinfo);
		return 0;
	}
	
	return 1;
}

stock access(id,level) 
{
	if (level==ADMIN_ADMIN)
	{
		return is_user_admin(id);
	}
	else if (level==ADMIN_ALL)
	{
		return 1;
	}

	return (get_user_flags(id) & level);
}

/* Flags:
*  1 - obey immunity
*  2 - allow yourself
*  4 - must be alive
*  8 - can't be bot */
#define CMDTARGET_OBEY_IMMUNITY (1<<0)
#define CMDTARGET_ALLOW_SELF	(1<<1)
#define CMDTARGET_ONLY_ALIVE	(1<<2)
#define CMDTARGET_NO_BOTS		(1<<3)
stock cmd_target(id,const arg[],flags = CMDTARGET_OBEY_IMMUNITY) 
{
	new player = find_player("bl",arg);
	if (player) 
	{
		if ( player != find_player("blj",arg) ) 
		{
			console_print(id,"%L",id,"MORE_CL_MATCHT");
			return 0;
		}
	}
	else if ( ( player = find_player("c",arg) )==0 && arg[0]=='#' && arg[1] )
	{
		player = find_player("k",str_to_num(arg[1]));
	}
	if (!player) 
	{
		console_print(id,"%L",id,"CL_NOT_FOUND");
		return 0;
	}
	if (flags & CMDTARGET_OBEY_IMMUNITY) 
	{
		if ((get_user_flags(player) & ADMIN_IMMUNITY) && 
			((flags & CMDTARGET_ALLOW_SELF) ? (id != player) : true) ) 
		{
			new imname[MAX_NAME_LENGTH];
			get_user_name(player,imname,31);
			console_print(id,"%L",id,"CLIENT_IMM",imname);
			return 0;
		}
	}
	if (flags & CMDTARGET_ONLY_ALIVE) 
	{
		if (!is_user_alive(player)) 
		{
			new imname[MAX_NAME_LENGTH];
			get_user_name(player,imname,31);
			console_print(id,"%L",id,"CANT_PERF_DEAD",imname);
			return 0;
		}
	}
	if (flags & CMDTARGET_NO_BOTS) 
	{
		if (is_user_bot(player)) 
		{
			new imname[MAX_NAME_LENGTH];
			get_user_name(player,imname,31);
			console_print(id,"%L",id,"CANT_PERF_BOT",imname);
			return 0;
		}
	}
	return player;
}

/**
 * Standard method to show activity to clients connected to the server.
 * This depends on the amx_show_activity cvar.  See documentation for more details.
 *
 * @param id		The user id of the person doing the action.
 * @param name		The name of the person doing the action.
 * @param fmt		The format string to display.  Do not put the "ADMIN:" prefix in this.
 */
stock show_activity( id, const name[], const fmt[], any:... ) 
{
	static __amx_show_activity;
	if (__amx_show_activity == 0)
	{
		__amx_show_activity = get_cvar_pointer("amx_show_activity");
	
		// if still not found, then register the cvar as a dummy
		if (__amx_show_activity == 0)
		{
			__amx_show_activity = register_cvar("amx_show_activity", "2", FCVAR_PROTECTED);
		}
	}
	
	new prefix[10];
	if (is_user_admin(id))
	{
		copy(prefix, charsmax(prefix), "ADMIN");
	}
	else
	{
		copy(prefix, charsmax(prefix), "PLAYER");
	}
	new buffer[512];
	vformat(buffer, charsmax(buffer), fmt, 4);
	
	switch(get_pcvar_num(__amx_show_activity))
	{
		case 5: // hide name only to admins, show nothing to normal users
		{
			for (new i=1; i<=MaxClients; i++)
			{
				if (is_user_connected(i))
				{
					if (is_user_admin(i))
					{
						client_print(i, print_chat, "%L: %s", i, prefix, buffer);
					}
				}
			}
		}
		case 4: // show name only to admins, show nothing to normal users
		{
			for (new i=1; i<=MaxClients; i++)
			{
				if (is_user_connected(i))
				{
					if (is_user_admin(i))
					{
						client_print(i, print_chat, "%L %s: %s", i, prefix, name, buffer);
					}
				}
			}
		}
		case 3: // show name only to admins, hide name from normal users
		{
			for (new i=1; i<=MaxClients; i++)
			{
				if (is_user_connected(i))
				{
					if (is_user_admin(i))
					{
						client_print(i, print_chat, "%L %s: %s", i, prefix, name, buffer);
					}
					else
					{
						client_print(i, print_chat, "%L: %s", i, prefix, buffer);
					}
				}
			}
		}
		case 2: // show name to all
		{
			client_print(0, print_chat, "%L %s: %s", LANG_PLAYER, prefix , name , buffer );
		}
		case 1: // hide name to all
		{
			client_print(0, print_chat, "%L: %s", LANG_PLAYER, prefix, buffer );
		}
	}
}

/**
 * Standard method to show activity to one single client. 
 * This is useful for messages that get pieced together by many language keys.
 * This depends on the amx_show_activity cvar.  See documentation for more details.
 *
 * @param idtarget	The user id of the person to display to.  0 is invalid.
 * @param idadmin	The user id of the person doing the action.
 * @param name		The name of the person doing the action.
 * @param fmt		The format string to display.  Do not put the "ADMIN:" prefix in this.
 */
stock show_activity_id(idtarget, idadmin, const name[], const fmt[], any:...)
{
	if (idtarget == 0 ||
		!is_user_connected(idtarget) )
	{
		return;
	}
	
	static __amx_show_activity;
	if (__amx_show_activity == 0)
	{
		__amx_show_activity = get_cvar_pointer("amx_show_activity");
	
		// if still not found, then register the cvar as a dummy
		if (__amx_show_activity == 0)
		{
			__amx_show_activity = register_cvar("amx_show_activity", "2", FCVAR_PROTECTED);
		}
	}

	static prefix[10];
	if (is_user_admin(idadmin))
	{
		copy(prefix, charsmax(prefix), "ADMIN");
	}
	else
	{
		copy(prefix, charsmax(prefix), "PLAYER");
	}
	
	static buffer[512];
	vformat(buffer, charsmax(buffer), fmt, 5);
	
	
	switch(get_pcvar_num(__amx_show_activity))
	{
		case 5: // hide name only to admins, show nothing to normal users
		{
			if ( is_user_admin(idtarget) )
			{
				client_print(idtarget, print_chat, "%L: %s", idtarget, prefix, buffer);
			}
		}
		case 4: // show name only to admins, show nothing to normal users
		{
			if ( is_user_admin(idtarget) )
			{
				client_print(idtarget, print_chat, "%L %s: %s", idtarget, prefix, name, buffer);
			}
		}
		case 3: // show name only to admins, hide name from normal users
		{
			if ( is_user_admin(idtarget) )
			{
				client_print(idtarget, print_chat, "%L %s: %s", idtarget, prefix, name, buffer);
			}
			else
			{
				client_print(idtarget, print_chat, "%L: %s", idtarget, prefix, buffer);
			}
		}
		case 2: // show name to all
		{
			client_print(idtarget, print_chat, "%L %s: %s", idtarget, prefix, name, buffer);
		}
		case 1: // hide name to all
		{
			client_print(idtarget, print_chat, "%L: %s", idtarget, prefix, buffer);
		}
	}
}
/**
 * Standard method to show activity to one single client with normal language keys.
 * These keys need to be in the format of standard AMXX keys:
 *   eg: ADMIN_KICK_1 = ADMIN: kick %s
 *       ADMIN_KICK_2 = ADMIN %s: kick %s
 * This depends on the amx_show_activity cvar.  See documentation for more details.
 *
 * @param KeyWithoutName	The language key that does not have the name field.
 * @param KeyWithName		The language key that does have the name field.
 * @param __AdminName		The name of the person doing the action.
 * @extra					Pass any extra format arguments for the language key in the variable arguments list. 
 */
stock show_activity_key(const KeyWithoutName[], const KeyWithName[], const ___AdminName[], any:...)
{
// The variable gets used via vformat, but the compiler doesn't know that, so it still cries.
#pragma unused ___AdminName
	static __amx_show_activity;
	if (__amx_show_activity == 0)
	{
		__amx_show_activity = get_cvar_pointer("amx_show_activity");
	
		// if still not found, then register the cvar as a dummy
		if (__amx_show_activity == 0)
		{
			__amx_show_activity = register_cvar("amx_show_activity", "2", FCVAR_PROTECTED);
		}
	}
	
	new buffer[512];
	new keyfmt[256];
	new i;
	
	switch( get_pcvar_num(__amx_show_activity) )
	{
	case 5: // hide name to admins, display nothing to normal players
		while (i++ < MaxClients)
		{
			if ( is_user_connected(i) )
			{
				if ( is_user_admin(i) )
				{
					LookupLangKey(keyfmt, charsmax(keyfmt), KeyWithoutName, i);

					// skip the "adminname" argument if not showing name
					vformat(buffer, charsmax(buffer), keyfmt, 4);
					client_print(i, print_chat, "%s", buffer);
				}
			}
		}
	case 4: // show name only to admins, display nothing to normal players
		while (i++ < MaxClients)
		{
			if ( is_user_connected(i) )
			{
				if ( is_user_admin(i) )
				{
					LookupLangKey(keyfmt, charsmax(keyfmt), KeyWithName, i);
					vformat(buffer, charsmax(buffer), keyfmt, 3);
					client_print(i, print_chat, "%s", buffer);
				}
			}
		}
	case 3: // show name only to admins, hide name from normal users
		while (i++ < MaxClients)
		{
			if ( is_user_connected(i) )
			{
				if ( is_user_admin(i) )
				{
					LookupLangKey(keyfmt, charsmax(keyfmt), KeyWithName, i);
					vformat(buffer, charsmax(buffer), keyfmt, 3);
				}
				else
				{
					LookupLangKey(keyfmt, charsmax(keyfmt), KeyWithoutName, i);
					
					// skip the "adminname" argument if not showing name
					vformat(buffer, charsmax(buffer), keyfmt, 4);
				}
				client_print(i, print_chat, "%s", buffer);
			}
		}
	case 2: // show name to all users
		while (i++ < MaxClients)
		{
			if ( is_user_connected(i) )
			{
				LookupLangKey(keyfmt, charsmax(keyfmt), KeyWithName, i);
				vformat(buffer, charsmax(buffer), keyfmt, 3);
				client_print(i, print_chat, "%s", buffer);
			}
		}
	case 1: // hide name from all users
		while (i++ < MaxClients)
		{
			if ( is_user_connected(i) )
			{
				LookupLangKey(keyfmt, charsmax(keyfmt), KeyWithoutName, i);

				// skip the "adminname" argument if not showing name
				vformat(buffer, charsmax(buffer), keyfmt, 4);
				client_print(i, print_chat, "%s", buffer);
			}
		}
		
	}
}

stock colored_menus() 
{
	new mod_name[32];
	get_modname(mod_name,31);

	return ( equal(mod_name,"cstrike") || equal(mod_name,"czero") || equal(mod_name,"dod") );
}

stock cstrike_running() 
{
	new mod_name[32];
	get_modname(mod_name,31);

	return ( equal(mod_name,"cstrike") || equal(mod_name,"czero") || equal(mod_name,"csv15") || equal(mod_name,"cs13") );
}

stock is_running(const mod[]) 
{
	new mod_name[32];
	get_modname(mod_name,31);

	return equal(mod_name,mod);
}

stock get_basedir(name[],len)
{
	return get_localinfo("amxx_basedir",name,len);
}

stock get_configsdir(name[],len)
{
	return get_localinfo("amxx_configsdir",name,len);
}

stock get_datadir(name[],len)
{
	return get_localinfo("amxx_datadir",name,len);
}

stock register_menu(const title[],keys,const function[],outside=0)
{
	register_menucmd(register_menuid(title,outside),keys,function);
}

/* Backwards Compatibility
* don't use it! */
stock get_customdir(name[],len)
{
	return get_localinfo("amxx_configsdir",name,len);
}

/* Add a menu item to Menus Front-End plugin ("amxmodmenu"):
* MENU_TEXT: Text that will be shown for this item in menu
* MENU_CMD: Command that should be executed to start menu
* MENU_ACCESS: Access required for menu
* MENU_PLUGIN: The exact case-insensitive name of plugin holding the menu command
*/
stock AddMenuItem(const MENU_TEXT[], const MENU_CMD[], const MENU_ACCESS, const MENU_PLUGIN[]) 
{
	AddMenuItem_call(MENU_TEXT, MENU_CMD, MENU_ACCESS, MENU_PLUGIN, false);
}
/* Just like above, but add menu item to "amx_menu", that should also be accessible by non-admins.
*/
stock AddClientMenuItem(const MENU_TEXT[], const MENU_CMD[], const MENU_ACCESS, const MENU_PLUGIN[]) 
{
	AddMenuItem_call(MENU_TEXT, MENU_CMD, MENU_ACCESS, MENU_PLUGIN, true);
}

// Internal function used by above stocks.
stock AddMenuItem_call(const MENU_TEXT[], const MENU_CMD[], const MENU_ACCESS, const MENU_PLUGIN[], const bool:ADD_TO_CLIENT_MENU) 
{
	new pluginid = is_plugin_loaded("Menus Front-End");
	if (pluginid == -1) {
		log_amx("Can't add menu item ^"%s^" from plugin ^"%s^" to menu set because the Menus Front-End plugin itself is not loaded!", MENU_TEXT, MENU_PLUGIN);
		return; // Menus Front-End doesn't exist, return.
	}

	new filename[64], b[1];
	get_plugin(pluginid, filename, 63, b, 0, b, 0, b, 0, b, 0);

	new status = callfunc_begin(ADD_TO_CLIENT_MENU ? "AddClientMenu" : "AddMenu", filename);
	new bool:failed = true;
	switch (status) 
	{
		case 1: failed = false;
		case 0: log_amx("Run time error! (AddMenuItem_call failed)");
		case -2: log_amx("Function not found! (AddMenuItem_call failed)");
		case -1: log_amx("Plugin not found! (AddMenuItem_call failed)");
	}
	if (failed)
	{
		return;
	}
	// Item text
	callfunc_push_str(MENU_TEXT);
	// Cmd
	callfunc_push_str(MENU_CMD);
	// Access
	callfunc_push_int(MENU_ACCESS);
	// Menu exists in this plugin
	callfunc_push_str(MENU_PLUGIN);

	callfunc_end();
}


stock constraint_offset(low, high, seed, offset)
{
	new numElements = high - low + 1;
	offset += seed - low;
   
	if (offset >= 0)
	{
		return low + (offset % numElements);
	}
	else
	{
		return high - (abs(offset) % numElements) + 1;
	}
	
	return 0;	// Makes the compiler happy -_-
}

/* Returns true if the user has ANY of the provided flags
 * false if they have none 
 */
stock has_flag(id, const flags[]) 
{
	return (get_user_flags(id) & read_flags(flags));
}
/* Returns true if the user has ALL of the provided flags
 * false otherwise
 */
stock has_all_flags(id, const flags[]) 
{
	new FlagsNumber=read_flags(flags);
	return ((get_user_flags(id) & FlagsNumber)==FlagsNumber);
}
// vim: set ts=4 sw=4 tw=99 noet:
//
// AMX Mod X, based on AMX Mod by Aleksander Naszko ("OLO").
// Copyright (C) The AMX Mod X Development Team.
//
// This software is licensed under the GNU General Public License, version 3 or higher.
// Additional exceptions apply. For full license details, see LICENSE.txt or visit:
//     https://alliedmods.net/amxmodx-license

#if defined _amxmodx_included
  #endinput
#endif
#define _amxmodx_included

#include <core>
#include <float>
#include <amxconst>
#include <string>
#include <file>
#include <vault>
#include <lang>
#include <messages>
#include <vector>
#include <sorting>
#include <cellarray>
#include <cellstack>
#include <celltrie>
#include <datapack>
#include <newmenus>
#include <textparse_smc>
#include <textparse_ini>

/**
 * Called just after server activation.
 *
 * @note Good place to initialize most of the plugin, such as registering
 *       cvars, commands or forwards, creating data structures for later use or
 *       generating and loading other required configuration.
 *
 * @noreturn
 */
forward plugin_init();

/**
 * Called just before the plugin is paused from execution.
 *
 * @noreturn
 */
forward plugin_pause();


/**
 * Called just after the plugin is unpaused.
 *
 * @noreturn
 */
forward plugin_unpause();

/**
 * Called when the mod tries to change the map.
 *
 * @note This is *only* called if the mod itself handles the map change. The
 *       server command "changelevel" which is used by many plugins will not
 *       trigger this forward. Unfortunately this means that in practice this
 *       forward is very unreliable, and will not be called in many situations.
 * @note AMXX 1.8.3 has added the change_level() function which will utilize
 *       the correct engine function to change the map and therefore trigger
 *       this forward.
 *
 * @param map   Map that the mod tries to change to
 *
 * @return      PLUGIN_CONTINUE to let the mod change the map
 *              PLUGIN_HANDLED or higher to prevent the map change
 */
forward server_changelevel(map[]);

/**
 * Called when all plugins went through plugin_init
 *
 * @note When this forward is called most plugins should have registered their
 *       cvars and commands already.
 *
 * @noreturn
 */
forward plugin_cfg();

/**
 * Called just before server deactivation and subsequent
 * unloading of the plugin.
 *
 * @note The plugin is required to manually free Handles it has acquired, such
 *       as those from dynamic data structures. Failing to do that will result
 *       in the plugin and AMXX leaking memory.
 *
 * @noreturn
 */
forward plugin_end();

/**
 * Called when a message is about to be logged.
 *
 * @note Message data and information can be retrieved using the read_log* set
 *       of functions.
 *
 * @return      PLUGIN_CONTINUE to let the log message through
 *              PLUGIN_HANDLED or higher to stop the log message
 */
forward plugin_log();

/**
 * This forward allows plugins to add models, sounds and generic files to the
 * precache tables using the precache_* set of functions.
 *
 * @note Adding files to the precaching tables will trigger the client to
 *       download them to its local filesystem.
 * @note There is a hard upper limit of entries in the precaching tables for
 *       every game, this limit is 512 in most cases. The entries will be filled
 *       and indexed incrementally. Going over this limit will crash the server.
 *
 * @noreturn
 */
forward plugin_precache();

/**
 * Called when a clients info has changed
 *
 * @param id    Client index
 *
 * @noreturn
 */
forward client_infochanged(id);

/**
 * Called when a client is connecting.
 *
 * @note This forward is called too early to do anything that directly affects
 *       the client.
 *
 * @param id    Client index
 *
 * @noreturn
 */
forward client_connect(id);

/**
 * Called when the client gets a valid SteamID.
 *
 * @note This may occur before or after client_putinserver has been called.
 * @note This is called for bots, and the SteamID will be "BOT"
 *
 * @param id    Client index
 *
 * @noreturn
 */
forward client_authorized(id);

/**
 * Called when a client is disconnecting from the server.
 *
 * @note By this point it is already too late to do anything that directly
 *       affects the client.
 *
 * @param id    Client index
 *
 * @noreturn
 */
forward client_disconnect(id);

/**
 * Called when a client attempts to execute a command.
 *
 * @note The command and its arguments can be read using the read_arg* set of
 *       functions.
 *
 * @param id    Client index
 *
 * @return      PLUGIN_CONTINUE to let the client execute the command
 *              PLUGIN_HANDLED or higher to stop the command
 */
forward client_command(id);

/**
 * Called when a client is entering the game.
 *
 * @note It is not defined whether the client already has a SteamID when this
 *       forward is called. client_authorized may occur either before or after
 *       this.
 *
 * @param id    Client index
 *
 * @noreturn
 */
forward client_putinserver(id);

/**
 * Sets informations about the calling plugin.
 *
 * @param plugin_name   Name of the plugin
 * @param version       Version of the plugin
 * @param author        Author of the plugin
 *
 * @return              Plugin id of the calling plugin
 */
native register_plugin(const plugin_name[], const version[], const author[]);

/**
 * Precaches a model file.
 *
 * @note Can only be used inside of the plugin_precache() forward.
 *
 * @param name  Path to the model file
 *
 * @return      Unique cache id of the model
 * @error       If called outside of the plugin_precache() forward, an error is
 *              thrown.
 */
native precache_model(const name[]);

/**
 * Precaches a sound file.
 *
 * @note Can only be used inside of the plugin_precache() forward.
 * @note The filepath is always relative to the "sound" folder, and the file has
 *       to be a wav file. Precaching a file with this will add it to the engine
 *       sound table, making it available for usage in emit_sound for example.
 * @note Precaching other filetypes (such as mp3 music), optionally in different
 *       locations, has to be done with precache_generic.
 *
 *
 * @param name  Path to the sound file
 *
 * @return      Unique cache id of the sound
 * @error       If called outside of the plugin_precache() forward, an error is
 *              thrown.
 */
native precache_sound(const name[]);

/**
 * Precaches a generic file.
 *
 * @note Can only be used inside of the plugin_precache() forward.
 * @note Precaching sounds with this will not add them to the engine sound table
 *
 * @param szFile    Path to the file
 *
 * @return          Unique cache id of the file
 * @error           If called outside of the plugin_precache() forward, an error
 *                  is thrown.
 */
native precache_generic(const szFile[]);

/**
 * Changes the map.
 *
 * @note  This calls the pfnChangelLevel engine function.
 * @note  This has the same behavior as using the "changelevel" server command,
 *        but will also trigger the server_changelevel() forward in AMXX
 *        plugins. It will also notify any Metamod plugins that are hooking
 *        the pfnChangeLevel function.
 *
 * @param map   Map name to change to
 *
 * @noreturn
 */
native change_level(const map[]);

/**
 * Sets info on the client.
 *
 * @param index     Client index
 * @param info      Info key
 * @param value     New value
 *
 * @noreturn
 * @error           If the index is not within the range of 1 to MaxClients or
 *                  the client is not connected an error will be thrown.
 * @error           If called outside of the plugin_precache() forward, an error
 *                  is thrown.
 */
native set_user_info(index, const info[], const value[]);

/**
 * Gets info from the client.
 *
 * @param index     Client index
 * @param info      Info key
 * @param output    Buffer to copy value to
 * @param len       Maximum size of the buffer
 *
 * @return          Number of cells written to buffer
 * @error           If the index is not within the range of 1 to MaxClients or
 *                  the client is not connected an error will be thrown.
 */
native get_user_info(index, const info[], output[], len);

/**
 * Sets info on the server.
 *
 * @param info      Info key
 * @param value     New value
 *
 * @noreturn
 */
native set_localinfo(const info[], const value[]);

/**
 * Gets info from the server.
 *
 * @param info      Info key
 * @param output    Buffer to copy value to
 * @param len       Maximum size of the buffer
 *
 * @return          Number of cells written to buffer
 */
native get_localinfo(const info[], output[], len);

/**
 * Shows text or a file in MOTD window.
 *
 * @param player    Client index, use 0 to display to all clients
 * @param message   Message to display inside the MOTD window. If this is a
 *                  filename the contents of this file will be displayed.
 * @param header    Text for the MOTD header. If this is empty the servers
 *                  hostname will be displayed instead.
 *
 * @noreturn
 */
native show_motd(player, const message[], const header[]="");

/**
 * Sends a message to the client.
 *
 * @param index     Client index, use 0 to display to all clients
 * @param type      Message type, see print_* destination constants in amxconst
 * @param message   Formatting rules
 * @param ...       Variable number of formatting parameters
 *
 * @return          Number of printed characters
 *                  If 0 is specified as the index then 0 will be returned if
 *                  nothing has been sent. The number of printed characters will
 *                  otherwise refer to the message that is sent last, to the
 *                  client with the highest index.
 * @error           If a single client is specified and the index is not
 *                  within the range of 1 to MaxClients an error will be thrown
 */
native client_print(index, type, const message[], any:...);

/**
 * Sends colored chat messages to clients.
 *
 * @note This only works in Counter-Strike 1.6 and Condition Zero.
 * @note The colors can be modified inside of the format string using special
 *       characters. These characters can be included using the escape character
 *          green           x04   ; use location color from this point forward
 *          red/blue/grey   x03   ; use team color from this point forward
 *          red/blue/grey   x02   ; use team color to the end of the client name
 *                                ; This only works at the start of the string,
 *                                ; and precludes using other control characters
 *          default         x01   ; use default color from this point forward
 * @note The team color is defined by the sender's index or a specific team
 *       color using the print_team_* constants in amxconst
 * @note Usage examples:
 *       client_print_color(id, print_team_red, "^4Green ^3Red ^1Default")
 *       client_print_color(id, id2, "^4Green ^3id2's team color, ^1Default")
 * @note Including colors in ML can be done using the same escaping method:
 *       EXAMPLE_ML_KEY = ^4Green ^3Team color ^1Default.
 *
 * @param index     Client index, use 0 to display to all clients
 * @param sender    Client index used as the sender, defining the team color
 *                  used in the message. Use print_team_* constants to force
 *                  a specific color.
 * @param fmt       Formatting rules
 * @param ...       Variable number of formatting parameters
 *
 * @return          Number of printed characters
 *                  If 0 is specified as the index then 0 will be returned if
 *                  nothing has been sent. The number of printed characters will
 *                  otherwise refer to the message that is sent last, to the
 *                  client with the highest index.
 * @error           If a single client is specified and the index is not
 *                  within the range of 1 to MaxClients an error will be thrown
 */
native client_print_color(index, sender, const message[], any:...);

/**
 * Sends a message to the client via the engine.
 *
 * @param player    Client index, use 0 to display to all clients
 * @param type      Message type, see print_* destination constants in amxconst
 * @param message   Formatting rules
 * @param ...       Variable number of formatting parameters
 *
 * @return          Number of printed characters
 *                  If 0 is specified as the index then 0 will be returned if
 *                  nothing has been sent. The number of printed characters will
 *                  otherwise refer to the message that is sent last, to the
 *                  client with the highest index.
 * @error           If a single client is specified and the index is not
 *                  within the range of 1 to MaxClients an error will be thrown
 */
native engclient_print(player, type, const message[], any:...);

/**
 * Sends a message to the console of a client or the server.
 *
 * @param index     Client index, or 0 to print to the server console
 * @param message   Formatting rules
 * @param ...       Variable number of formatting parameters
 *
 * @return          Number of printed characters
 * @error           If a single client is specified and the index is not
 *                  within the range of 1 to MaxClients an error will be thrown
 */
native console_print(id, const message[], any:...);

/**
 * Executes a command from the specified client or the server console.
 *
 * @param id    Client index, or 0 to print to the server console
 * @param cmd   Formatting rules
 * @param ...   Variable number of formatting parameters
 *
 * @return      Length of the formatted command
 */
native console_cmd(id, const cmd[], any:...);

/**
 * Registers a function to be called on a given game event.
 *
 * @note Examples for event conditions:
 *       "2=c4" - Second parameter of message must be the string "c4"
 *       "3>10" - Third parameter of message must be greater than 10
 *       "3!4" - Third parameter of message must not be equal to 4
 *       "2&Buy" - Second parameter of message must contain "Buy" substring
 *       "2!Buy" - Second parameter of message must not equal "Buy"
 * @note Due to a long-standing bug that would break compatibility with older
 *       plugins, the client id should be checked for alive/dead state if using
 *       flags "d" or "e".
 *
 * @param event     Name of event that should be hooked
 * @param function  Name of callback function
 * @param flags     Flags used for filtering events, the valid flags are:
 *                  "a" - Global event (sent to every client)
 *                  "b" - Event sent to single client
 *                  "c" - Call only once when repeated to multiple clients
 *                  "d" - Call only if sent to dead client
 *                  "e" - Call only if sent to alive client
 *                  "f" - Call only if sent to human client ("b" flag required)
 *                  "g" - Call only if sent to bot ("b" flag required)
 * @param cond      Condition string used for filtering events, built as:
 *                  "<argument number><comparison operator><value>"
 *                  Argument number is the argument position to be filtered
 *                  The comparison operator may be:
 *                    - "=" for equality comparison (all argument types)
 *                    - "!" for inequality comparison (all argument types)
 *                    - "&" for bitwise and (int argument) or substring
 *                      comparison (string argument)
 *                    - "<" for less than comparison (int/float arguments)
 *                    - ">" for greater than comparison (int/float arguments)
 *                  The argument is compared to the specified value accordingly
 * @param ...       Any number of additional conditions
 *
 * @return          1 on successfully registering event
 *                  0 on failure
 * @error           Invalid event name or invalid callback function
 */
native register_event(const event[], const function[], const flags[], const cond[]="", ...);

/**
 * Registers a function to be called on a given log event.
 *
 * @note Examples for log conditions:
 *       "0=World triggered" "1=Game_Commencing"
 *       "1=say"
 *       "3=Terrorists_Win"
 *       "1=entered the game"
 *       "0=Server cvar"
 *
 * @param function  Name of callback function
 * @param argsnum   Number of arguments of the log event
 * @param ...       Any number of conditions used for filtering events
 *                  A condition string is built as:
 *                  "<argument number><comparison operator><string>"
 *                  Argument number is the argument position to be filtered
 *                  The comparison operator may be:
 *                    - "=" for equality comparison
 *                    - "&" for substring comparison
 *                  The argument is compared to the specified string accordingly
 *
 * @return          1 on successfully registering event, 0 on failure
 * @error           Invalid callback function
 */
native register_logevent(const function[], argsnum,  ...);

/**
 * Sets display parameters for hudmessages.
 *
 * @note As of AMXX 1.61, setting the channel to -1 will automatically choose
 *       the next available HUD channel for the client.
 * @note There are four different HUD channels available on the client (1-4).
 *       Sending a hudmessage to a channel will overwrite any existing messages
 *       already displaying on that channel.
 * @note If you plan to create a permanent message don't forget to specify a
 *       specific channel to avoid possible flickering due to auto-channeling
 * @note For the hudmessage coordinates x and y, -1.0 will center the message
 *       on the respective axis.
 * @note These parameters stay until the next call to set_hudmessage overwrites
 *       them. Multiple calls to show_hudmessage will therefore re-use the same
 *       parameters. The parameters are not stored per-plugin, so other plugins
 *       can overwrite them.
 *
 * @param red           Red component of hudmessage color
 * @param green         Green component of hudmessage color
 * @param blue          Blue component of hudmessage color
 * @param x             Location of the message on the x axis in percent
 * @param y             Location of the message on the y axis in percent
 * @param effects       Display effect
 * @param fxtime        Duration of the effect
 * @param holdtime      Time the message stays on screen
 * @param fadeintime    Time it takes the message to fully appear (fade-in)
 * @param fadeouttime   Time it takes the message to fully disappear (fade-out)
 * @param channel       Channel to use on the client
 *
 * @noreturn
 */
native set_hudmessage(red=200, green=100, blue=0, Float:x=-1.0, Float:y=0.35, effects=0, Float:fxtime=6.0, Float:holdtime=12.0, Float:fadeintime=0.1, Float:fadeouttime=0.2, channel=-1);

/**
 * Displays a message on the client HUD.
 *
 * @note Use set_hudmessage to define how the message should look on screen.
 *
 * @param index     Client index, use 0 to display to all clients
 * @param message   Formatting rules
 * @param ...       Variable number of formatting parameters
 *
 * @return          Number of printed characters
 *                  If 0 is specified as the index then 0 will be returned if
 *                  nothing has been sent. The number of printed characters will
 *                  otherwise refer to the message that is sent last, to the
 *                  client with the highest index.
 * @error           If a single client is specified and the index is not
 *                  within the range of 1 to MaxClients an error will be thrown
 */
native show_hudmessage(index, const message[], any:...);

/**
 * Sets display parameters for director hudmessages.
 *
 * @note For the hudmessage coordinates x and y, -1.0 will center the message
 *       on the respective axis.
 * @note These parameters stay until the next call to set_dhudmessage overwrites
 *       them. Multiple calls to show_dhudmessage will therefore re-use the same
 *       parameters. The parameters are not stored per-plugin, so other plugins
 *       can overwrite them.
 *
 * @param red           Red component of hudmessage color
 * @param green         Green component of hudmessage color
 * @param blue          Blue component of hudmessage color
 * @param x             Location of the message on the x axis in percent
 * @param y             Location of the message on the y axis in percent
 * @param effects       Display effect
 * @param fxtime        Duration of the effect
 * @param holdtime      Time the message stays on screen
 * @param fadeintime    Time it takes the message to fully appear (fade-in)
 * @param fadeouttime   Time it takes the message to fully disappear (fade-out)
 *
 * @noreturn
 */
native set_dhudmessage(red=200, green=100, blue=0, Float:x=-1.0, Float:y=0.35, effects=0, Float:fxtime=6.0, Float:holdtime=12.0, Float:fadeintime=0.1, Float:fadeouttime=0.2);

/**
 * Displays a director message on the client HUD.
 *
 * @note Use set_dhudmessage to define how the message should look on screen.
 * @note Unlike the classic HUD message which is channel-based, director
 *       messages are stack-based. You can have up to 8 messages displaying at
 *       once, if more are added they will be overwritten in the order they were
 *       sent. There is no way to clear a specific message.
 * @note The message has a maximum length of 128 characters which this function
 *       will automatically enforce.
 *
 * @param index     Client index, use 0 to display to all clients
 * @param message   Formatting rules
 * @param ...       Variable number of formatting parameters
 *
 * @return          Number of printed characters
 *                  If 0 is specified as the index then 0 will be returned if
 *                  nothing has been sent. The number of printed characters will
 *                  otherwise refer to the message that is sent last, to the
 *                  client with the highest index.
 * @error           If a single client is specified and the index is not
 *                  within the range of 1 to MaxClients an error will be thrown
 */
native show_dhudmessage(index, const message[], any:...);

/**
 * Displays a menu to the client.
 *
 * @note Keys is a bitflag value that represents which keys the user can press
 *       on the menu. If you want to display disabled menu options or skip
 *       certain number slots you should exclude that key from the bitflag.
 *       amxconst.inc provides MENU_KEY_* constants for convenience.
 * @note If a menu timeout is specified it does not automatically overwrite
 *       the menu on the client's screen. But if a client acts upon a timeouted
 *       displayed menu that action will not be sent to the plugin.
 * @note The title parameter is not displayed to the client and is only used for
 *       identifying menus internally and assigning them to their callbacks.
 *       The title corresponds to the menu name that you register with
 *       register_menuid().
 *
 * @param index     Client to display menu to, use 0 to display to all clients
 * @param keys      Enabled keys
 * @param menu      Menu body
 * @param time      Menu timeout in seconds, -1 to disable
 * @param title     Name of the menu for internal tracking purposes
 */
native show_menu(index, keys, const menu[], time=-1, const title[]="");

/**
 * Retrieves values from a client message.
 *
 * @note For use within callbacks registered with register_event().
 * @note Usage examples:
 *       value = read_data(1);
 *       read_data(2, floatvalue);
 *       written = read_data(3, buffer, buffersize);
 *
 *
 * @param value     Argument number to retrieve value from
 * @param ...       If 0 additional parameters are provided, the function
 *                  will return the argument value directly.
 *                  If 1 additional parameter is provided, the function will
 *                  store a float value in that second parameter.
 *                  If two additional parameters are provided, the function
 *                  will copy a string to the buffer provided in the second
 *                  parameter, using the third as the maximum buffer size.
 *
 * @return          If zero additional parameters are provided, the function
 *                  will return an integer value.
 *                  If one additional parameter is provided, the function will
 *                  return the float value, converted (truncated) to an integer.
 *                  If two additional parameters are provided, the function
 *                  will return the number of cells written to the buffer.
 */
native read_data(value, any:...);

/**
 * Returns the number of values in the client message.
 *
 * @note For use within callbacks registered with register_event().
 *
 * @return      Number of values in client message
 */
native read_datanum();

/**
 * Returns the message id of the client message.
 *
 * @note For use within callbacks registered with register_event().
 *
 * @return      Message id of the client message
 */
native read_datatype();

/**
 * Retrieves current log message.
 *
 * @note Can only be used inside of the plugin_log() forward.
 *
 * @param output    Buffer to copy log message to
 * @param len       Maximum buffer size
 *
 * @return          Number of cells written to buffer
 * @error           If called outside of the plugin_log() forward, an error is
 *                  thrown.
 */
native read_logdata(output[], len);

/**
 * Returns number of log message arguments.
 *
 * @note Can only be used inside of the plugin_log() forward.
 *
 * @return          Number of arguments in the log message
 * @error           If called outside of the plugin_log() forward, an error is
 *                  thrown.
 */
native read_logargc();

/**
 * Retrieves argument of log message.
 *
 * @note Can only be used inside of the plugin_log() forward.
 *
 * @param id        Argument index, starting from 0
 * @param output    Buffer to copy log argument to
 * @param len       Maximum buffer size
 *
 * @return          Number of cells written to buffer
 * @error           If called outside of the plugin_log() forward, an error is
 *                  thrown.
 */
native read_logargv(id, output[], len);

/**
 * Parse log data about client.
 *
 * @note When client actions are logged they appear in the the format
 *       "Name<#userid><SteamID><teamname>", this native extracts the individual
 *       pieces of information.
 *
 * @param text      String to process
 * @param name      Buffer to copy client name to
 * @param nlen      Maximum name buffer size
 * @param userid    Variable to store userid in
 * @param authid    Buffer to copy client authid to
 * @param alen      Maximum auth buffer size
 * @param team      Buffer to copy client team to
 * @param tlen      Maximum team buffer size
 *
 * @noreturn
 * @error           If the provided string is not valid client log data, an
 *                  error will be thrown.
 */
native parse_loguser(const text[], name[], nlen, &userid=-2, authid[]="", alen=0, team[]="", tlen=0);

/**
 * Sends a message to the console of the server.
 *
 * @param message   Formatting rules
 * @param ...       Variable number of formatting parameters
 *
 * @return          Number of printed characters
 */
native server_print(const message[], any:...);

/**
 * Returns if the given mapname is deemed valid by the engine.
 *
 * @param mapname   Name of the map
 *
 * @return          1 if the map name is valid, 0 otherwise
 */
native is_map_valid(const mapname[]);

/**
 * Returns if the client is a bot.
 *
 * @param index     Client index
 *
 * @return          1 if client is a bot, 0 otherwise
 */
native is_user_bot(index);

/**
 * Returns if the client is a HLTV proxy.
 *
 * @param index     Client index
 *
 * @return          1 if client is a HLTV proxy, 0 otherwise
 */
native is_user_hltv(index);

/**
 * Returns if the client is connected.
 *
 * @note This does not throw an error if the provided index is out of the
 *       1 to MaxClients range. That means you can safely use this native
 *       without manually verifying an index to be a valid client index.
 *
 * @param index     Client index
 *
 * @return          1 if client is connected, 0 otherwise
 */
native is_user_connected(index);

/**
 * Returns if the client is connecting.
 *
 * @param index     Client index
 *
 * @return          1 if client is connecting, 0 otherwise
 */
native is_user_connecting(index);

/**
 * Returns if the client is alive.
 *
 * @note This will never return true if a client is not connected. If you need
 *       to know whether a client is alive, an additional call to
 *       is_user_connected() is unnecessary.
 *
 * @param index     Client index
 *
 * @return          1 if client is alive, 0 otherwise
 */
native is_user_alive(index);

/**
 * Returns if the server is a dedicated server.
 *
 * @param index     Client index
 *
 * @return          1 if server is a dedicated server, 0 otherwise
 */
native is_dedicated_server();

/**
 * Returns if the server is running on Linux.
 *
 * @param index     Client index
 *
 * @return          1 if server is running on Linux, 0 otherwise
 */
native is_linux_server();

/**
 * Returns if the AMXX installation has the JIT enabled.
 *
 * @param index     Client index
 *
 * @return          1 if JIT is enabled, 0 otherwise
 */
native is_jit_enabled();

/**
 * Retrieves the version string of the AMXX installation.
 *
 * @param buffer    Buffer to copy version to
 * @param length    Maximum buffer size
 *
 * @return          Number of cells written to the buffer
 */
native get_amxx_verstring(buffer[], length);

/**
 * Returns the last known attacker of a client.
 *
 * @note As of AMXX 1.75 this can return a non-client entity index if the client
 *       was attacked by a non-client entity.
 *
 * @param index     Client index
 * @param ...       Optionally a second byref parameter will be filled with the
 *                  attacker weapon, and a third byref parameter will be filled
 *                  with the hit place on the body.
 *
 * @return          Attacker client index, a non-client entity or 0 if no
 *                  attacker was found
 * @error           If the client index is not within the range of 1 to
 *                  MaxClients an error will be thrown.
 */

native get_user_attacker(index, ...);

/**
 * Traces the client's current aim vector to see if it hits something.
 *
 * @note If the trace does not hit a client, id and body will be set to 0.
 * @note If the trace hits nothing within the specified distance 0.0 is returned
 *
 * @param index     Client index to trace aim from
 * @param id        Variable to store hit client index (if applicable)
 * @param body      Variable to store hit client body part (if applicable)
 * @param dist      Maximum distance of the trace
 *
 * @return          Distance between the trace start and end point
 * @error           If the client index is not within the range of 1 to
 *                  MaxClients an error will be thrown.
 */
native Float:get_user_aiming(index, &id, &body, dist=9999);

/**
 * Returns the client's frags.
 *
 * @note While this is mod-independent the mod may track frag count differently
 *       so it can only be retrieved using another native or other methods.
 * @note This will actually return the client's overall score, which may or may
 *       not be equal to their scored frags depending on the mod.
 *
 * @param index     Client index
 *
 * @return          Frags/Score of the client. Also returns 0 if the client is
 *                  not connected or the index is not within the range of
 *                  1 to MaxClients
 */
native get_user_frags(index);

/**
 * Returns the client's armor value.
 *
 * @note While this is mod-independent the mod may track armor data differently
 *       so it can only be retrieved using another native or other methods.
 *
 * @param index     Client index
 *
 * @return          Amount of armor the client has. Also returns 0 if the client
 *                  is not connected or the index is not within the range of
 *                  1 to MaxClients
 */
native get_user_armor(index);

/**
 * Returns the client's death count.
 *
 * @note While this is mod-independent the mod may track death count differently
 *       so it can only be retrieved using another native or other methods.
 *
 * @param index     Client index
 *
 * @return          Amount of deaths the client has. Also returns 0 if the
 *                  client is not connected or the index is not within the range
 *                  of 1 to MaxClients
 */
native get_user_deaths(index);

/**
 * Returns the client's health points.
 *
 * @note While this is mod-independent the mod may track health points
 *       differently so it can only be retrieved using another native or other
 *       methods.
 *
 * @param index     Client index
 *
 * @return          Amount of health points the client has. Also returns 0 if
 *                  the client is not connected or the index is not within the
 *                  range of 1 to MaxClients
 */
native get_user_health(index);

/**
 * Retrieves a client's index by name.
 *
 * @param name  Name to search for
 *
 * @return      Client index on success, 0 otherwise
 */
native get_user_index(const name[]);

/**
 * Retrieves the IP of a client or the server.
 *
 * @param index             Client index, use 0 to retrieve the server IP
 * @param ip                Buffer to copy IP to
 * @param len               Maximum buffer size
 * @param without_port      Remove the port from the IP if nonzero
 *
 * @return                  Number of cells written to the buffer
 */
native get_user_ip(index, ip[], len, without_port=0);

/**
 * Returns if the client has the specified weapon in their inventory.
 *
 * @param index         Client index
 * @param weapon        Weapon index
 * @param setweapon     If zero the weapon bit will be removed from the client's
 *                      inventory, if 1 it will be set
 *
 * @return              1 if the weapon is present, 0 if it is not
 * @error               If the client index is not within the range of 1 to
 *                      MaxClients an error will be thrown.
 */
native user_has_weapon(index, weapon, setweapon=-1);

/**
 * Returns weapon index of the currently carried weapon. Also allows retrieval
 * of ammo in the clip and backpack.
 *
 * @param index     Client index
 * @param clip      Optional variable to store clip ammo to
 * @param ammo      Optional variable to store backpack ammo to
 *
 * @return          Weapon index on success, or 0 if the client is not connected
 * @error           If the client index is not within the range of 1 to
 *                  MaxClients an error will be thrown.
 */
native get_user_weapon(index, &clip=0, &ammo=0);

/**
 * Retrieves ammo in the clip and backpack of the specified weapon.
 *
 * @param index     Client index
 * @param weapon    Weapon index
 * @param clip      Variable to store clip ammo to
 * @param ammo      Variable to store backpack ammo to
 *
 * @return          1 on success, or 0 if the client is not connected
 * @error           If the client index is not within the range of 1 to
 *                  MaxClients, or the weapon index is invalid, an error will
 *                  be thrown.
 */
native get_user_ammo(index, weapon, &clip, &ammo);

/**
 * Converts an integer to a text string.
 *
 * @note The conversion algorithm is limited to a certain range of numbers, but
 *       is guaranteed to work correctly for all numbers from 0 to 999. Outside
 *       of that range the conversion will result in an incorrect string, but
 *       not fail.
 * @note The conversion is to english text, there is no way to change this.
 *
 * @param num       Integer to convert
 * @param output    Buffer to copy string to
 * @param len       Maximum buffer size
 *
 * @return          Number of cells written to buffer
 */
native num_to_word(num, output[], len);

/**
 * Returns the team id of the client, and optionally retrieves the name of
 * the team.
 *
 * @param index     Client index
 * @param team      Buffer to copy team name to
 * @param len       Maximum size of buffer
 *
 * @return          Team index on success, -1 if client index is invalid or
 *                  the client is not connected.
 */
native get_user_team(index, team[]="", len=0);

/**
 * Returns client's playing time in seconds.
 *
 * @param index     Client index
 * @param flag      If nonzero the result will not include the time it took
 *                  the client to connect.
 *
 * @return          Connection time in seconds, 0 if client index is invalid or
 *                  client is not connected
 */
native get_user_time(index, flag=0);

/**
 * Retrieves the ping and loss of a client.
 *
 * @param index     Client index
 * @param ping      Variable to store ping in
 * @param loss      Variable to sote loss in
 *
 * @return          1 on success, 0 if client index is invalid or the client
 *                  is not connected.
 */
native get_user_ping(index, &ping, &loss);

/**
 * Retrieves an origin related to the client.
 *
 * @param index     Client index
 * @param origin    Array to store origin in
 * @param mode      What type of origin to retrieve:
 *                    0 - current position
 *                    1 - position of eyes (and weapon)
 *                    2 - aim end position from client position
 *                    3 - aim end position from eyes (hit point for weapon)
 *                    4 - position of last bullet hit (only for Counter-Strike)
 *
 * @return          1 on succes, 0 if client is not connected
 * @error           If the client index is not within the range of 1 to
 *                  MaxClients an error will be thrown.
 */
native get_user_origin(index, origin[3], mode=0);

/**
 * Retrieves all weapons in the client inventory, stores them in an array and
 * returns the inventory as a bitflag sum.
 *
 * @note Make sure that num has an initial value of 0, or the native will not
 *       work correctly.
 *
 * @param index     Client index
 * @param weapons   Array to store weapon indexes in
 * @param num       Variable to store number of weapons in the inventory to
 *
 * @return          Bitflag sum of weapon indexes, 0 if client is not connected
 * @error           If the client index is not within the range of 1 to
 *                  MaxClients an error will be thrown.
 */
native get_user_weapons(index, weapons[32], &num);

/**
 * Retrieves the full name of a weapon.
 *
 * @param id        Weapon index
 * @param weapon    Buffer to copy name to
 * @param len       Maximum buffer size
 */
native get_weaponname(id, weapon[], len);

/**
 * Retrieves the name of a client or the server.
 *
 * @param index     Client index, or 0 to retrieve the server hostname
 * @param name      Buffer to copy name to
 * @param len       Maximum buffer size
 *
 * @return          Number of cells written to buffer
 */
native get_user_name(index, name[], len);

/**
 * Retrieves the SteamID of a client.
 *
 * @note The SteamID is only available once the client_authorized() forward has
 *       been called for the client.
 *
 * @param index     Client index
 * @param authid    Buffer to copy auth to
 * @param len       Maximum buffer size
 *
 * @return          Number of cells written to buffer
 */
native get_user_authid(index, authid[], len);

/**
 * Returns the userid of a client.
 *
 * @param index     Client index
 *
 * @return          Client userid, 0 if the userid is not available or the
 *                  client index is invalid.
 */
native get_user_userid(index);

/**
 * Slaps the client with specified power. Killing the client if applicable.
 *
 * @note This removes "power" amount of health from the client, performing
 *       a kill if they have no health left after the slap.
 * @note The function will apply a velocity to the client that is independent
 *       of the slap power. The slap direction can be influenced by the third
 *       parameter.
 *
 * @param index     Client idex
 * @param power     Power of the slap
 * @param rnddir    If set to zero the player will be slapped along it's aim
 *                  vector. If nonzero the direction will be randomized.
 */
native user_slap(index, power, rnddir=1);

/**
 * Kills a client.
 *
 * @param index     Client index
 * @param flag      If nonzero the death will not affect the client's score
 *
 * @return          1 on success, 0 if client index is invalid or the client
 *                  is not connected.
 */
native user_kill(index, flag=0);

/**
 * Logs a message to the current AMXX log file.
 *
 * @note The message will automatically be tagged with the plugin's name and the
 *       log will include a timestamp with the message.
 *
 * @param string    Formatting rules
 * @param ...       Variable number of formatting parameters
 *
 * @noreturn
 */
native log_amx(const string[], any:...);

/**
 * Logs a message to the current server log file.
 *
 * @note The log will include a timestamp with the message.
 *
 * @param string    Formatting rules
 * @param ...       Variable number of formatting parameters
 *
 * @return          Number of printed characters
 */
native log_message(const message[], any:...);

/**
 * Logs a message to the specified file
 *
 * @note The log will include a timestamp with the message.
 *
 * @param string    Formatting rules
 * @param ...       Variable number of formatting parameters
 *
 * @noreturn
 */
native log_to_file(const file[], const message[], any:...);

/**
 * Returns the number of clients on the server.
 *
 * @param flag      Count clients still in the connecting process if nonzero
 *
 * @return          Number of clients on the server
 */
native get_playersnum(flag=0);

/**
 * Stores a filtered list of client indexes to an array.
 *
 * @note Example retrieving all alive CTs: get_players(players, num "ae", "CT")
 *
 * @param players   Array to store indexes to
 * @param num       Variable to store number of indexes to
 * @param flags     Optional list of filtering flags:
 *                    "a" - do not include dead clients
 *                    "b" - do not include alive clients
 *                    "c" - do not include bots
 *                    "d" - do not include human clients
 *                    "e" - match with team
 *                    "f" - match with part of name
 *                    "g" - match case insensitive
 *                    "h" - do not include HLTV proxies
 * @param team      String to match against if the "e" or "f" flag is specified
 *
 * @noreturn
 */
native get_players(players[32], &num, const flags[]="", const team[]="");

/**
 * Retrieves argument of client command.
 *
 * @note Should only be used inside of the client_command() forward.
 *
 * @param id        Argument index starting from 1, 0 returns the command itself
 * @param output    Buffer to copy command argument to
 * @param len       Maximum buffer size
 *
 * @return          Number of cells written to buffer
 */
native read_argv(id, output[], len);

/**
 * Retrieves full client command string.
 *
 * @note Should only be used inside of the client_command() forward.
 *
 * @param output    Buffer to copy command line to
 * @param len       Maximum buffer size
 *
 * @return          Number of cells written to buffer
 */
native read_args(output[], len);

/**
 * Returns number of client command arguments.
 *
 * @note Should only be used inside of the client_command() forward.
 * @note This count includes the command itself. I.e. in a command with 4
 *       arguments this will return 5.
 *
 * @return          Number of arguments in the command
 */
native read_argc();

/**
 * Converts a flag string to a bitflag value.
 *
 * @note Example: The string "abcd" represents the sum of 1, 2, 4 and 8 - or
 *       (1<<0)|(1<<1)|(1<<2)|(1<<3). The function will return 15.
 *
 * @param flags     Flag string to convert
 *
 * @return          Bitflag value
 */
native read_flags(const flags[]);

/**
 * Converts a bitflag value to a flag string.
 *
 * @note Example: The value 3 will yield the string "ab"
 *
 * @param flags     Bitflag value to convert
 * @param output    Buffer to copy flag string to
 * @param len       Maximum buffer size
 *
 * @return          Number of cells written to buffer
 */
native get_flags(flags, output[], len);

/**
 * Find a player given a filter.
 *
 * @note If matching by userid, do not also specify the "a", "b" or "c" flags,
 *       or the function may not return a correct result.
 *
 * @param flags     List of filtering flags:
 *                    "a" - match with name
 *                    "b" - match with name substring
 *                    "c" - match with authid
 *                    "d" - match with ip
 *                    "e" - match with team name
 *                    "f" - do not include dead clients
 *                    "g" - do not include alive clients
 *                    "h" - do not include bots
 *                    "i" - do not include human clients
 *                    "j" - return last matched client instead of the first
 *                    "k" - match with userid
 *                    "l" - match case insensitively
 * @param ...       String to match against (integer if "k" flag is specified)
 *
 */
native find_player(const flags[], ...);

/**
 * Removes double-quotes from the beginning and end of a string.
 *
 * @note If the string only has a double-quote at either the start *or* the end
 *       and not both the function will do nothing.
 * @note The function does not perform any trimming per-se. But if a
 *       double-quote is found at the beginning of the string, it will remove
 *       one ^r (carriage return) character at the end of the string if present,
 *       even if no matching double-quote is found. This is for convenience.
 *
 * @param text      String to remove double-quotes from
 *
 * @return          1 if matching double-quotes have been removed, 0 otherwise
 */
native remove_quotes(text[]);

/**
 * Executes a command on the client.
 *
 * @note Executing malicious commands on the client ("slowhacking") is frowned
 *       upon.
 * @note Valve has introduced a command filter to Counter-Strike 1.6. It is not
 *       possible to execute many commands if the client has opted in to this.
 *
 * @param index     Client index, use 0 to execute on all clients
 * @param command   Formatting rules
 * @param ...       Variable number of formatting parameters
 *
 * @return          Lenght of formatted command string
 * @error           If a single client is specified and the index is not
 *                  within the range of 1 to MaxClients an error will be thrown
 */
native client_cmd(index, const command[], any:...);

/**
 * Execute a command from the client without actually sending it to the client's
 * DLL.
 *
 * @note This emulates a client command on the server side, and is an excellent
 *       tool to force a client to do certain actions related to the game.
 * @note The command has to stand alone in the command parameter, only add
 *       arguments using the designated paramters.
 * @note Commands emulated using this function will not trigger plugin command
 *       hooks. For an alternative that does, see amxclient_cmd().
 *
 * @param index         Client index, use 0 to execute from all clients.
 * @param command       Client command to execute on
 * @param arg1          Optional command arguments
 * @param arg2          Optional command arguments
 *
 * @noreturn
 * @error           If a single client is specified and the index is not
 *                  within the range of 1 to MaxClients an error will be thrown
 */
native engclient_cmd(index, const command[], const arg1[]="", const arg2[]="");

/**
 * Execute a command from the client without actually sending it to the client's
 * DLL. This triggers plugin command hooks.
 *
 * @note This emulates a client command on the server side, and is an excellent
 *       tool to force a client to do certain actions related to the game.
 * @note The command has to stand alone in the command parameter, only add
 *       arguments using the designated paramters.
 * @note Commands emulated using this function will trigger other plugin's
 *       command hooks. For an alternative that doesn't, see engclient_cmd().
 *
 * @param index         Client index, use 0 to execute from all clients.
 * @param command       Client command to execute on
 * @param arg1          Optional command arguments
 * @param arg2          Optional command arguments
 *
 * @noreturn
 * @error           If a single client is specified and the index is not
 *                  within the range of 1 to MaxClients an error will be thrown
 */
native amxclient_cmd(index, const command[], const arg1[]="", const arg2[]="");

/**
 * Queues a command to be executed from the server console.
 *
 * @note Warning: This is a potential source of command injection. Do not feed
 *       client-controlled input (including client names) to this function
 *       without sanitizing it first.
 * @note The queued commands will be executed by the engine on the next frame.
 *       If you require them to be executed immediately, see server_exec().
 *
 * @param command   Formatting rules
 * @param ...       Variable number of formatting parameters
 *
 * @noreturn
 */
native server_cmd(const command[], any:...);

/**
 * Sets a cvar to a given string value. The cvar is accessed by name.
 *
 * @note Accessing a cvar by name requires this function to walk through the
 *       engine's cvar list every time, which can result in a considerable waste
 *       of processing time, especially if many cvars have been registered. For
 *       a vastly superior alternative look at the set_pcvar_string function.
 *
 * @param cvar      Cvar name to set value of
 * @param value     Value to set cvar to
 *
 * @noreturn
 */
native set_cvar_string(const cvar[], const value[]);

/**
 * Returns if a cvar is registered on the server.
 *
 * @param cvar      Cvar name to check
 *
 * @return          1 if the cvar exists, 0 otherwise
 */
native cvar_exists(const cvar[]);

/**
 * Removes specified flags from a cvar. The cvar is accessed by name.
 *
 * @note Not permitted for the "amx_version", "amxmodx_version", "fun_version"
 *       and "sv_cheats" cvars.
 * @note For a list of possible flags see the FCVAR_* constants in amxconst.inc
 * @note This function removes the flags using a bitwise-and operation.
 * @note Accessing a Cvar by name requires this function to walk through the
 *       engine's cvar list every time, which can result in a considerable waste
 *       of processing time, especially if many cvars have been registered. For
 *       a vastly superior alternative look at the set_pcvar_flags function.
 *
 *
 * @param cvar      Cvar name to remove flags from
 * @param flags     Bitflag sum of flags to remove
 *
 * @return          1 on success, 0 if cvar does not exist or is not permitted
 */
native remove_cvar_flags(const cvar[], flags=-1);

/**
 * Sets specified flags to a cvar. The cvar is accessed by name.
 *
 * @note Not permitted for the "amx_version", "amxmodx_version", "fun_version"
 *       and "sv_cheats" cvars.
 * @note For a list of possible flags see the FCVAR_* constants in amxconst.inc
 * @note This function just adds the flags using a bitwise-or operation. After
 *       it has run the flags may not exactly equal the specified bitflag sum.
 * @note Accessing a Cvar by name requires this function to walk through the
 *       engine's cvar list every time, which can result in a considerable waste
 *       of processing time, especially if many cvars have been registered. For
 *       a vastly superior alternative look at the set_pcvar_flags function.
 *
 * @param cvar      Cvar name to remove flags from
 * @param flags     Bitflag sum of flags to set
 *
 * @return          1 on success, 0 if cvar does not exist or is not permitted
 */
native set_cvar_flags(const cvar[], flags);

/**
 * Returns flags of a cvar. The cvar is accessed by name.
 *
 * @note For a list of possible flags see the FCVAR_* constants in amxconst.inc
 * @note Accessing a Cvar by name requires this function to walk through the
 *       engine's cvar list every time, which can result in a considerable waste
 *       of processing time, especially if many cvars have been registered. For
 *       a vastly superior alternative look at the get_pcvar_flags function.
 *
 * @param cvar      Cvar name to retrieve flags from
 *
 * @return          1 on success, 0 if cvar does not exist or is not permitted
 */
native get_cvar_flags(const cvar[]);

/**
 * Sets a cvar to a given float value. The cvar is accessed by name.
 *
 * @note Accessing a Cvar by name requires this function to walk through the
 *       engine's cvar list every time, which can result in a considerable waste
 *       of processing time, especially if many cvars have been registered. For
 *       a vastly superior alternative look at the set_pcvar_float function.
 *
 * @param cvar      Cvar name to set value of
 * @param value     Value to set cvar to
 *
 * @noreturn
 */
native set_cvar_float(const cvar[], Float:value);

/**
 * Returns a floating value from a cvar. The cvar is accessed by name.
 *
 * @note Accessing a Cvar by name requires this function to walk through the
 *       engine's cvar list every time, which can result in a considerable waste
 *       of processing time, especially if many cvars have been registered. For
 *       a vastly superior alternative look at the get_pcvar_float function.
 *
 * @param cvarname  Cvar name to retrieve value from
 *
 * @return          Cvar value, converted to float
 */
native Float:get_cvar_float(const cvarname[]);

/**
 * Returns an integer value from a cvar. The cvar is accessed by name.
 *
 * @note Accessing a Cvar by name requires this function to walk through the
 *       engine's cvar list every time, which can result in a considerable waste
 *       of processing time, especially if many cvars have been registered. For
 *       a vastly superior alternative look at the get_pcvar_num function.
 *
 * @param cvarname  Cvar name to retrieve value from
 *
 * @return          Cvar value, converted to int
 */
native get_cvar_num(const cvarname[]);

/**
 * Sets a cvar to a given integer value. The cvar is accessed by name.
 *
 * @note Accessing a Cvar by name requires this function to walk through the
 *       engine's cvar list every time, which can result in a considerable waste
 *       of processing time, especially if many cvars have been registered. For
 *       a vastly superior alternative look at the set_pcvar_num function.
 *
 * @param cvar      Cvar name to set value of
 * @param value     Value to set cvar to
 *
 * @noreturn
 */
native set_cvar_num(const cvarname[], value);

/**
 * Gets a string value from a cvar. The cvar is accessed by name.
 *
 * @note Accessing a Cvar by name requires this function to walk through the
 *       engine's cvar list every time, which can result in a considerable waste
 *       of processing time, especially if many cvars have been registered. For
 *       a vastly superior alternative look at the get_pcvar_string function.
 *
 * @param cvar      Cvar name to retrieve value from
 * @param output    Buffer to copy cvar value to
 * @param iLen      Maximum size of the buffer
 *
 * @return          Number of cells written to buffer.
 */
native get_cvar_string(const cvarname[], output[], iLen);

/**
 * Retrieves the name of the currently played map.
 *
 * @param name      Buffer to copy map name to
 * @param len       Maximum buffer size
 *
 * @return          Number of cells written to buffer
 */
native get_mapname(name[], len);

/**
 * Returns time remaining on map.
 *
 * @return  Time left on map, in seconds
 */
native get_timeleft();

/**
 * Returns the game time based on the game tick.
 *
 * @note This time is counted up from map start. If the engine is not processing
 *       this function will return the same value between calls, which makes it
 *       unusable for profiling purposes.
 *
 * @return      Game time, in seconds
 */
native Float:get_gametime();

/**
 * Returns the maxplayers setting of the current server, that is how many
 * clients it supports.
 *
 * @note As of AMXX 1.8.3 this value is also exposed through a dynamic constant
 *       via the MaxClients variable, declared in amxconst.inc
 *
 * @return      Maxplayers setting
 */
native get_maxplayers();

/**
 * Retrieves the name of the currently played mod.
 *
 * @note This retrieves the short name of the mod. Example: for Counter-Strike
 *       it will copy "cstrike" to the buffer.
 *
 * @param name      Buffer to copy mod name to
 * @param len       Maximum size of the buffer
 *
 * @return          Number of cells written to buffer
 */
native get_modname(name[], len);

/**
 * Retrieves the current time using the specified format string.
 *
 * @note Uses the strftime C function. For a list of valid format parameters,
 *       see: http://cplusplus.com/reference/clibrary/ctime/strftime.html
 *       A common example for a format string would be: "%m/%d/%Y - %H:%M:%S"
 *
 * @param format    Format string
 * @param output    Buffer to copy formatted time string to
 * @param len       Maximum size of buffer
 *
 * @return          Number of cells written to buffer
 */
native get_time(const format[], output[], len);

/**
 * Retrieves the provided time using using the specified format string.
 *
 * @note Uses the strftime C function. For a list of valid format parameters,
 *       see: http://cplusplus.com/reference/clibrary/ctime/strftime.html
 *       A common example for a format string would be: "%m/%d/%Y - %H:%M:%S"
 *
 * @param output    Buffer to copy formatted time string to
 * @param len       Maximum size of buffer
 * @param format    Format string
 * @param time      Unix timestamp, use -1 to use the current time
 *
 * @return          Number of cells written to buffer
 * @error           If the conversion process fails, an error will be thrown
 */
native format_time(output[], len, const format[], time=-1);

/**
 * Returns the system time as a unix timestamp (number of seconds since unix
 * epoch)
 *
 * @param offset    Optional offset value in seconds
 *
 * @return          Unix time stamp
 * @error
 */
native get_systime(offset=0);

/**
 * Converts time string to unix time stamp.
 *
 * @note Uses the strptime C function. For a list of valid format parameters,
 *       see: http://www.cplusplus.com/reference/ctime/strftime/
 *       An example for a input/format combination would be:
 *       Input: "10:32:54 04/02/2013"  Format: "%H:%M:%S %m:%d:%Y"
 * @note Information missing from the input will be filled with the current
 *       time and date.
 *
 * @param input     Time string to convert
 * @param format    Formatting information for conversion
 * @param time      If different from -1 the converted time will be added to
 *                  this time stamp.
 *
 * @return          Unix time stamp
 * @error           If the conversion process fails, an error will be thrown
 */
native parse_time(const input[], const format[], time=-1);

/**
 * Calls a function after a specified time has elapsed.
 *
 * @param time          Time interval to assign
 * @param function      Function to execute
 * @param id            Task id to assign
 * @param parameter     Data to pass through to callback
 * @param len           Size of data
 * @param flags         Optional set of flags:
 *                        "a" - repeat timer a set amount of times
 *                        "b" - loop indefinitely until timer is stopped
 *                        "c" - time interval is treated as absolute time after
 *                              map start
 *                        "d" - time interval is treated as absolute time before
 *                              map change
 * @param repeat        If the "a" flag is set the task will be repeated this
 *                      many times
 */
native set_task(Float:time, const function[], id=0, const parameter[]="", len=0, const flags[]="", repeat=0);

/**
 * Removes all tasks with the specified id.
 *
 * @param id        Task id to search for
 * @param outside   Will remove tasks set by other plugins if nonzero
 *
 * @return          Number of removed tasks
 */
native remove_task(id=0, outside=0);

/**
 * Modifies the time interval of all tasks with the specified id.
 *
 * @param id        Task id to search for
 * @param newTime   New time interval to set
 * @param outside   Will affect tasks set by other plugins if nonzero
 *
 * @return          Number of affected tasks
 */
native change_task(id=0, Float:newTime=1.0, outside=0);

/**
 * Returns if a task with the specified id exists.
 *
 * @param id        Task id to search for
 * @param outside   Search for tasks set by other plugins if nonzero
 *
 * @return          1 if a task was found, 0 otherwise
 */
native task_exists(id=0, outside=0);

/**
 * Sets the specified admin flags to a client.
 *
 * @note For a list of possible flags see the ADMIN_* constants in amxconst.inc
 * @note This function just adds the flags using a bitwise-or operation. After it
 *       has run the flags may not exactly equal the specified bitflag sum.
 * @note AMXX stores multiple sets of flags internally, but only flag set
 *       0 is actively used. You should not change the value of the third
 *       parameter from the default.
 *
 * @param index     Client index, 0 to set flags of server
 * @param flags     Admin flags
 * @param id        Flag set id, ranging from 0 to 31
 *
 * @noreturn
 * @error           If the index is not within the range of 0 to MaxClients, an
 *                  error will be thrown.
 */
native set_user_flags(index, flags=-1, id=0);

/**
 * Returns the client's admin flags as a bitflag sum.
 *
 * @note For a list of possible flags see the ADMIN_* constants in amxconst.inc
 * @note AMXX stores multiple sets of flags internally, but only flag set
 *       0 is actively used. You should not change the value of the second
 *       parameter from the default.
 *
 * @param index     Client index, 0 to set flags of server
 * @param id        Flag set id, ranging from 0 to 31
 *
 * @noreturn
 * @error           If the index is not within the range of 0 to MaxClients, an
 *                  error will be thrown.
 */
native get_user_flags(index, id=0);

/**
 * Removes the specified admin flags from a client.
 *
 * @note For a list of possible flags see the ADMIN_* constants in amxconst.inc
 * @note This function just removes the flags using a bitwise-and operation.
 * @note AMXX stores multiple sets of flags internally, but only flag set
 *       0 is actively used. You should not change the value of the third
 *       parameter from the default.
 *
 * @param index     Client index, 0 to set flags of server
 * @param flags     Admin flags
 * @param id        Flag set id, ranging from 0 to 31
 *
 * @noreturn
 * @error           If the index is not within the range of 0 to MaxClients, an
 *                  error will be thrown.
 */
native remove_user_flags(index, flags=-1, id=0);

/**
 * Registers a callback to be called when the client executes a command from the
 * console.
 *
 * @note For a list of possible access flags see the ADMIN_* constans in
 *       amxconst.inc
 * @note Opting in to FlagManager enables the admin privileges to be overwritten
 *       by the end user via the cmdaccess.ini config file.
 * @note Automatic detection for FlagManager will only include a command if it
 *       has required privileges (flags is not -1) and it is not a command
 *       starting with "say".
 *
 * @param client_cmd    Command to register
 * @param function      Callback function
 * @param flags         Admin privilege flags required
 * @param info          Command description
 * @param FlagManager   0 opts out of flag manager, 1 opts in, -1 selects
 *                      automatically
 *
 * @return              Command id, 0 on failure
 * @error               If an invalid callback function is specified, an error
 *                      will be thrown.
 */
native register_clcmd(const client_cmd[], const function[], flags=-1, const info[]="", FlagManager=-1);

/**
 * Registers a callback to be called when the client or server executes a
 * command from the console.
 *
 * @note For a list of possible access flags see the ADMIN_* constans in
 *       amxconst.inc
 * @note Opting in to FlagManager enables the admin privileges to be overwritten
 *       by the end user via the cmdaccess.ini config file.
 * @note Automatic detection for FlagManager will only include a command if it
 *       has required privileges (flags is not -1) and it is not a command
 *       starting with "say".
 *
 * @param client_cmd    Command to register
 * @param function      Callback function
 * @param flags         Admin privilege flags required
 * @param info          Command description
 * @param FlagManager   0 opts out of flag manager, 1 opts in, -1 selects
 *                      automatically
 *
 * @return              Command id, 0 on failure
 * @error               If an invalid callback function is specified, an error
 *                      will be thrown.
 */
native register_concmd(const cmd[], const function[], flags=-1, const info[]="", FlagManager=-1);

/**
 * Registers a callback to be called when the server executes a command from the
 * console.
 *
 * @note For a list of possible access flags see the ADMIN_* constans in
 *       amxconst.inc
 *
 * @param client_cmd    Command to register
 * @param function      Callback function
 * @param flags         Admin privilege flags required
 * @param info          Command description
 *
 * @return              Command id, 0 on failure
 * @error               If an invalid callback function is specified, an error
 *                      will be thrown.
 */
native register_srvcmd(const server_cmd[], const function[], flags=-1, const info[]="");

/**
 * Retrieves information about a client command.
 *
 * @note For a list of possible access flags see the ADMIN_* constans in
 *       amxconst.inc
 *
 * @param index     Command index
 * @param command   Buffer to copy command name to
 * @param len1      Maximum name buffer size
 * @param flags     Variable to store privilege flags to
 * @param info      Buffer to copy command description to
 * @param len2      Maximum description buffer size
 * @param flag      Only considers commands that can be accessed with
 *                  the specified privilege flags.
 *
 * @return          1 on succes, 0 if command was not found
 */
native get_clcmd(index, command[], len1, &flags, info[], len2, flag);

/**
 * Returns number of registered client commands.
 *
 * @note For a list of possible access flags see the ADMIN_* constans in
 *       amxconst.inc
 *
 * @param flag      Only considers commands that can be accessed with
 *                  the specified privilege flags.
 *
 * @return          Number of registered client commants
 */
native get_clcmdsnum(flag);

/**
 * Retrieves information about a server command.
 *
 * @note For a list of possible access flags see the ADMIN_* constans in
 *       amxconst.inc
 *
 * @param index     Command index
 * @param command   Buffer to copy command name to
 * @param len1      Maximum name buffer size
 * @param flags     Variable to store privilege flags to
 * @param info      Buffer to copy command description to
 * @param len2      Maximum description buffer size
 * @param flag      Only considers commands that can be accessed with
 *                  the specified privilege flags.
 *
 * @return          1 on succes, 0 if command was not found
 */
native get_srvcmd(index, server_cmd[], len1, &flags, info[], len2, flag);

/**
 * Returns number of registered server commands.
 *
 * @note For a list of possible access flags see the ADMIN_* constans in
 *       amxconst.inc
 *
 * @param flag      Only considers commands that can be accessed with
 *                  the specified privilege flags.
 *
 * @return          Number of registered server commants
 */
native get_srvcmdsnum(flag);

/**
 * Retrieves information about a console command.
 *
 * @note For a list of possible access flags see the ADMIN_* constans in
 *       amxconst.inc
 *
 * @param index     Command index
 * @param command   Buffer to copy command name to
 * @param len1      Maximum name buffer size
 * @param flags     Variable to store privilege flags to
 * @param info      Buffer to copy command description to
 * @param len2      Maximum description buffer size
 * @param flag      Only considers commands that can be accessed with
 *                  the specified privilege flags.
 * @param id        If set to 0 only server commands will be considered,
 *                  positive will only consider client commands, otherwise
 *                  all console commands will be considered.
 *
 * @return          1 on succes, 0 if command was not found
 */
native get_concmd(index, cmd[], len1, &flags, info[], len2, flag, id=-1);

/**
 * Returns the parent plugin id of a console command
 *
 * @note For a list of possible access flags see the ADMIN_* constans in
 *       amxconst.inc
 *
 * @param cid           Command index
 * @param flag_mask     Only considers commands that can be accessed with
 *                      the specified privilege flags.
 * @param id_type       If set to 0 only server commands will be considered,
 *                      positive will only consider client commands, otherwise
 *                      all console commands will be considered.
 */
native get_concmd_plid(cid, flag_mask, id_type);

/**
 * Returns number of registered console commands.
 *
 * @note For a list of possible access flags see the ADMIN_* constans in
 *       amxconst.inc
 *
 * @param flag      Only considers commands that can be accessed with
 *                  the specified privilege flags.
 * @param id        If set to 0 only server commands will be considered,
 *                  positive will only consider client commands, otherwise
 *                  all console commands will be considered.
 *
 * @return          Number of registered console commants
 */
native get_concmdsnum(flag, id=-1);

/**
 * Returns the number of plugin-registered cvars.
 *
 * @return  Number of registered cvars
 */
native get_plugins_cvarsnum();

/**
 * Retrieves information about a plugin-registered cvar.
 *
 * @note The returned cvar pointer should be used with the get_pcvar_* and
 *       set_pcvar_* set of functions.
 *
 * @param num           Cvar index, this does not equal the cvar pointer, it is
 *                      the internal index, incremented for each registered cvar
 * @param name          Buffer to copy cvar name to
 * @param namelen       Maximum buffer size
 * @param flags         Variable to store cvar flags to
 * @param plugin_id     Variable to store id of the registering plugin to
 * @param pcvar_handle  Variable to store cvar pointer to
 *
 * @return              1 on success, 0 if index is invalid
 */
native get_plugins_cvar(num, name[], namelen, &flags=0, &plugin_id=0, &pcvar_handle=0);

/**
 * Returns unique menu id of a menu.
 *
 * @param menu      Menu name
 * @param outside   Catch menus outside the calling plugin
 *
 * @return          Menu id
 */
native register_menuid(const menu[], outside=0);

/**
 * Registers a callback function to a menu id and keys.
 *
 * @param menuid        Menu id
 * @param keys          Key flags
 * @param function      Callback function
 *
 * @noreturn
 * @error               If an invalid callback function is specified, an error
 *                      will be thrown.
 */
native register_menucmd(menuid, keys, const function[]);

/**
 * Returns if the client is watching a menu.
 *
 * @note If there is no menu the id is 0. If the id is negative then the client
 *       views a VGUI menu. Otherwise the id is an id acquired from the
 *       register_menuid() function.
 *
 * @param index     Client index
 * @param id        Variable to store menu id to
 * @param keys      Variable to store menu keys to
 *
 * @return          1 if client views a menu, 0 otherwise
 * @error           If the client index is not within the range of 1 to
 *                  MaxClients, an error will be thrown.
 */
native get_user_menu(index, &id, &keys);

/**
 * Forces the server to execute the command queue immediately.
 *
 * @note Commands can be added to the queue using server_cmd().
 *
 * @noreturn
 */
native server_exec();

/**
 * Emits a sound from an entity from the engine.
 *
 * @note The sample must be precached using precache_sound() so it is available
 *       in the engine's sound table.
 * @note For a list of available channels see CHAN_* constants in amxconst.inc,
 *       sounds emitted from the same channel will override each other.
 * @note There are helpful reference constants in amxconst.inc for sound volume
 *       (VOL_*), attenuation (ATTN_*), flags (SND_*), and pitch (PITCH_*).
 *
 * @param index     Entity index, use 0 to emit from all clients
 * @param channel   Channel to emit from
 * @param sample    Sound file to emit
 * @param vol       Volume in percent
 * @param att       Sound attenuation
 * @param flags     Emit flags
 * @param pitch     Sound pitch
 */
native emit_sound(index, channel, const sample[], Float:vol, Float:att, flags, pitch);

/**
 * Registers a new cvar for the engine.
 *
 * @note For a list of possible cvar flags see FCVAR_* constants in amxconst.inc
 * @note If an already existing cvar is registered it will not be duplicated.
 * @note The returned cvar pointer should be used with the get_pcvar_* and
 *       set_pcvar_* set of functions.
 *
 * @param name      Cvar name
 * @param string    Default cvar value
 * @param flags     Cvar flags
 * @param fvalue    Unused
 *
 * @return          Unique cvar pointer
 */
native register_cvar(const name[], const string[], flags=0, Float:fvalue=0.0);

/**
 * Returns a random floating point value generated by the engine.
 *
 * @param a     Minimum value (inclusive)
 * @param b     Maximum value (inclusive)
 *
 * @return      Generated random value
 */
native Float:random_float(Float:a, Float:b);

/**
 * Returns a random integer value generated by the engine.
 *
 * @param a     Minimum value (inclusive)
 * @param b     Maximum value (inclusive)
 *
 * @return      Generated random value
 */
native random_num(a, b);

/**
 * Returns unique id of a client message
 *
 * @note Example usage: get_user_msgid("TextMsg")
 * @note The message id is unique as long as the server is running, but might
 *       change between updates. They should not be hardcoded into plugins.
 *
 * @param name      Client message name
 *
 * @return          Message id, 0 if message was not found
 */
native get_user_msgid(const name[]);

/**
 * Retrieves the client message name from a message id.
 *
 * @param msgid     Client message id
 * @param name      Buffer to copy message name to
 * @param len       Maximum buffer size
 *
 * @return          Number of cells written to buffer, 0 on invalid message id
 */
native get_user_msgname(msgid, name[], len);

/**
 * Returns a unique id for a public variable.
 *
 * @note Variables declared with the "public" specifier are accessible by-name
 *       from outside of the declaring plugin.
 * @note If multiple plugins declare the same public variable this native will
 *       still return a unique id.
 *
 * @param name      Variable name
 *
 * @return          Xvar id on success, -1 on failure
 */
native get_xvar_id(const name[]);

/**
 * Returns if a public variable exists in any loaded plugin.
 *
 * @param name      Variable name
 *
 * @return          1 if public cvar exists, 0 otherwise
 */
native xvar_exists(const name[]);

/**
 * Returns the integer value of a public variable.
 *
 * @note If multiple plugins declare the same public variable they are not
 *       automatically synchronized. The xvar system accesses only one of all
 *       public variables directly. Xvars have to be read through the natives or
 *       the value will be incorrect.
 *
 * @param id    Xvar id, an xvar id can be retrieved using get_xvar_id()
 *
 * @return      Xvar integer value
 */
native get_xvar_num(id);

/**
 * Returns the float value of a public variable.
 *
 * @note If multiple plugins declare the same public variable they are not
 *       automatically synchronized. The xvar system accesses only one of all
 *       public variables directly. Xvars have to be read through the natives or
 *       the value will be incorrect.
 *
 * @param id    Xvar id, an xvar id can be retrieved using get_xvar_id()
 *
 * @return      Xvar float value
 */
native Float:get_xvar_float(id);

/**
 * Sets the integer value of a public variable.
 *
 * @note If multiple plugins declare the same public variable they are not
 *       automatically synchronized. The xvar system accesses only one of all
 *       public variables directly. Xvars have to be set through the natives or
 *       the xvar will not be updated.
 *
 * @param id        Xvar id, an xvar id can be retrieved using get_xvar_id()
 * @param value     Value to set
 *
 * @noreturn
 * @error           If an invalid xvar id is specified an error will be thrown.
 */
native set_xvar_num(id, value=0);

/**
 * Sets the float value of a public variable.
 *
 * @note If multiple plugins declare the same public variable they are not
 *       automatically synchronized. The xvar system accesses only one of all
 *       public variables directly. Xvars have to be set through the natives or
 *       the xvar will not be updated.
 *
 * @param id        Xvar id, an xvar id can be retrieved using get_xvar_id()
 * @param value     Value to set
 *
 * @noreturn
 * @error           If an invalid xvar id is specified an error will be thrown.
 */
native set_xvar_float(id, Float:value=0.0);

/**
 * Returns if a module is loaded.
 *
 * @param name      Module name
 *
 * @return          Module id of the matching module, -1 otherwise
 */
native is_module_loaded(const name[]);

/**
 * Retrieves info about a module by module index.
 *
 * @note For a list of possible status flags see module_* constants in
 *       amxconst.inc
 *
 * @param id            Module id
 * @param name          Buffer to copy module name to
 * @param nameLen       Maximum name buffer size
 * @param author        Buffer to copy module author to
 * @param authorLen     Maximum author buffer size
 * @param version       Buffer to copy module version to
 * @param versionLen    Maximum version buffer size
 * @param status        Variable to store module status to
 *
 * @return              Module id on succes, -1 on invalid module
 */
native get_module(id, name[], nameLen, author[], authorLen, version[], versionLen, &status);

/**
 * Returns the number of currently registered modules.
 *
 * @return  Number of modules
 */
native get_modulesnum();

/**
 * Returns if a plugin is loaded by registered name or filename.
 *
 * @note An example for a registered name would be "Admin Base" while a possible
 *       filename would be "admin.amxx"
 * @note Prior to AMXX 1.80 this function would only search for plugins
 *       registered names, not the filename.
 * @note The plugin name matching is case insensitive while the filename
 *       matching is case sensitive.
 *
 * @param name          Plugin name or filename
 * @param usefilename   If true searches for plugin filename, false searches for
 *                      plugin name
 *
 * @return              Plugin id of the matching plugin, -1 otherwise
 */
native is_plugin_loaded(const name[], bool:usefilename=false);

/**
 * Retrieves info about a plugin by plugin index.
 *
 * @param index     Plugin index, -1 to target calling plugin
 * @param filename  Buffer to copy plugin filename to
 * @param len1      Maximum filename buffer size
 * @param name      Buffer to copy plugin name to
 * @param len2      Maximum name buffer size
 * @param version   Buffer to copy plugin version to
 * @param len3      Maximum version buffer size
 * @param author    Buffer to copy plugin author to
 * @param len4      Maximum author buffer size
 * @param status    Buffer to copy plugin status flags to
 * @param len5      Maximum status buffer size
 * @param ...       Unused and ignored
 *
 * @return          Plugin index on success, -1 if there is no plugin with given
 *                  index
 */
native get_plugin(index, filename[]="", len1=0, name[]="", len2=0, version[]="", len3=0, author[]="", len4=0, status[]="", len5=0, ...);

/**
 * Returns the number of loaded AMXX plugins.
 *
 * @return  Number of loaded plugins
 */
native get_pluginsnum();

/**
 * Pauses a plugin so it will not be executed until it is unpaused.
 *
 * @note This used to be able to pause specific functions but this functionality
 *       (along with the flags "b" and "e") has been deprecated.
 * @note If used without flag "c" this will pause the calling plugin.
 *
 * @param flag      Pause flags
 *                    "a" - pause plugin
 *                    "c" - search for other plugins using param1
 *                    "d" - stop plugin, making it unavailable to unpause
 * @param param1    Plugin filename
 * @param param2    Unused and ignored
 *
 * @return          1 on success, 0 otherwise
 * @error           If it is attempted to use the deprecated functionality,
 *                  an error is thrown.
 */
native pause(const flag[], const param1[]="", const param2[]="");

/**
 * Unpauses a plugin so it will resume execution if it was previously paused.
 *
 * @note This used to be able to unpause specific functions but this
 *       functionality (along with the flags "b" and "e") has been deprecated.
 * @note Without specifying flag "c" this function will do nothing, as a plugin
 *       is incapable of unpausing itself. This is a relict of the deprecated
 *       functionality.
 *
 * @param flag      Pause flags
 *                    "a" - pause plugin
 *                    "c" - search for other plugins using param1
 * @param param1    Plugin filename
 * @param param2    Unused and ignored
 *
 * @return          1 on success, 0 otherwise
 * @error           If it is attempted to use the deprecated functionality,
 *                  an error is thrown.
 */
native unpause(const flag[], const param1[]="", const param2[]="");

/**
 * Initiates a function call to this or another plugin by function name.
 *
 * @note This only sets up the function call and covers the pre-requisites.
 *       Push parameters using the callfunc_push_* set of functions. The call
 *       will be executed only upon using callfunc_end()
 *
 * @param func      Function name
 * @param plugin    Plugin filename. If empty the calling plugin is targeted.
 *                  The filename has to be the full exact name (e.g. stats.amxx)
 *
 * @return           1 on success
 *                   0 on runtime error
 *                  -1 if plugin was not found
 *                  -2 if function was not found
 * @error           If called while another callfunc has not yet been finished,
 *                  an error is thrown.
 */
native callfunc_begin(const func[], const plugin[]="");

/**
 * Initiates a function call to this or another plugin by function id.
 *
 * @note This only sets up the function call and covers the pre-requisites.
 *       Push parameters using the callfunc_push_* set of functions. The call
 *       will be executed only upon using callfunc_end()
 * @note The function id can be retrieved by get_func_id()
 *
 * @param func      Function id
 * @param plugin    Plugin filename. If empty the calling plugin is targeted.
 *                  The filename has to be the full exact name (e.g. stats.amxx)
 *
 * @return           1 on success
 *                  -1 if plugin was not found
 *                  -2 if function is not executable
 * @error           If called while another callfunc has not yet been finished,
 *                  or the specified function is invalid, an error is thrown.
 */
native callfunc_begin_i(func, plugin=-1);

/**
 * Retrieves a functions id for use with callfunc_begin_i()
 *
 * @param funcName  Function name
 * @param pluginId  Plugin id. If -1 the calling plugin is targeted. The plugin
 *                  id can be retrieved using find_plugin_byfile()
 *
 * @return          >0 Function id on success
 *                  -1 if plugin or function was not found
 */
native get_func_id(const funcName[], pluginId=-1);

/**
 * Pushes an int value onto the current call.
 *
 * @param value     Int value to push
 *
 * @noreturn
 * @error           If called without initiating a callfunc, or the maximum
 *                  amount of parameters is reached, an error is thrown.
 */
native callfunc_push_int(value);

/**
 * Pushes a float value onto the current call.
 *
 * @param value     Float value to push
 *
 * @noreturn
 * @error           If called without initiating a callfunc, or the maximum
 *                  amount of parameters is reached, an error is thrown.
 */
native callfunc_push_float(Float: value);

/**
 * Pushes an int value reference onto the current call.
 *
 * @note Changes made to this value by the called function will be reflected
 *       in the calling plugin.
 *
 * @param value     Int value to push
 *
 * @noreturn
 * @error           If called without initiating a callfunc, or the maximum
 *                  amount of parameters is reached, an error is thrown.
 */
native callfunc_push_intrf(&value);

/**
 * Pushes a float value reference onto the current call.
 *
 * @note Changes made to this value by the called function will be reflected
 *       in the calling plugin.
 *
 * @param value     Float value to push
 *
 * @noreturn
 * @error           If called without initiating a callfunc, or the maximum
 *                  amount of parameters is reached, an error is thrown.
 */
native callfunc_push_floatrf(&Float:value);

/**
 * Pushes a string onto the current call.
 *
 * @note This will defy the "const" specifier if copyback is true, which is
 *       only kept for special backwards compatibility.
 *
 * @param VALUE     String to push
 * @param copyback  If true any changes made in the called function will be
 *                  copied back to the calling plugin.
 *
 * @noreturn
 * @error           If called without initiating a callfunc, or the maximum
 *                  amount of parameters is reached, an error is thrown.
 */
native callfunc_push_str(const VALUE[], bool:copyback=true);

/**
 * Pushes an array onto the current call.
 *
 * @note This will defy the "const" specifier if copyback is true, which is
 *       only kept for special backwards compatibility.
 *
 * @param VALUE         Array to push
 * @param array_size    Size of the array
 * @param copyback      If true any changes made in the called function will be
 *                      copied back to the calling plugin.
 *
 * @noreturn
 * @error           If called without initiating a callfunc, or the maximum
 *                  amount of parameters is reached, an error is thrown.
 */
native callfunc_push_array(const VALUE[], array_size, bool:copyback=true);

/**
 * Completes the call to a function.
 *
 * @return       1 on success
 *              -1 if the plugin was not found
 *              -2 if the function was not found
 * @error       If called without initiating a callfunc an error is thrown.
 */
native callfunc_end();

/**
 * Called when an inconsistent file is encountered by the engine.
 *
 * @param id        Client index
 * @param filename  Detected file
 * @param reason    Buffer storing the disconnect reason (can be overwritten)
 *
 * @return          PLUGIN_CONTINUE to let the engine kick the client
 *                  PLUGIN_HANDLED to block the inconsistency kick
 */
forward inconsistent_file(id, const filename[], reason[64]);

/**
 * Forces the clients and server to be running with the same version of a
 * specified file.
 *
 * @note For a list of possible enforcement types see the force_* constants
 *       in amxconst.inc
 *
 * @param force_type    Enforcement type
 * @param mins          Bounding box mins vector
 * @param maxs          Bounding box maxs vector
 * @param filename      Filename
 *
 * @return              1 on success, 0 otherwise
 */
native force_unmodified(force_type, const mins[3], const maxs[3], const filename[]);

/**
 * Calculates the MD5 keysum of a string.
 *
 * @param szString      String to calculate keysum of
 * @param md5buffer     Buffer to copy the MD5 hash to
 *
 * @return              Number of cells written to the buffer (always 32)
 */
native md5(const szString[], md5buffer[34]);

/**
 * Calculates the MD5 keysum of a file.
 *
 * @param file          Path to file to calculate keysum of
 * @param md5buffer     Buffer to copy the MD5 hash to
 *
 * @return              Number of cells written to the buffer (always 32)
 * @error               If the file can not be opened, and error is thrown.
 */
native md5_file(const file[], md5buffer[34]);

/**
 * Returns the internal flags set on the plugin's state.
 *
 * @param hdr       If nonzero the function will return the pcode rather than
 *                  state flags
 * @param plid      Plugin id, -1 to target calling plugin
 */
native plugin_flags(hdr=0, plid=-1);

/**
 * Allows plugins to declare module dependencies using require_module()
 *
 * @deprecated Module dependency has been automatically handled by the compiler
 *             since AMXX 1.50, released in 2005. This forward is no longer
 *             called.
 *
 * @noreturn
 */
forward plugin_modules();

/**
 * Adds a module dependency
 *
 * @deprecated Module dependency has been automatically handled by the compiler
 *             since AMXX 1.50, released in 2005. This native has no effect.
 *
 * @noreturn
 */
native require_module(const module[]);

/**
 * Returns if the server is 64 bit.
 *
 * @deprecated As a result of valve dropping support for 64bit binaries AMXX is
 *             also not shipping 64bit builds anymore. This native is basically
 *             guaranteed to return 0.
 *
 * @return  1 if the server is 64 bit, 0 otherwise
 */
native is_amd64_server();

/**
 * Returns plugin id by filename.
 *
 * @param filename      Filename to match
 * @param ignoreCase    If nonzero matches case insensitively, case sensitively
 *                      otherwise
 *
 * @return              Plugin id, -1 (INVALID_PLUGIN_ID) on failure
 */
native find_plugin_byfile(const filename[], ignoreCase=1);

/**
 * Called before plugin_init(), allows the plugin to register natives.
 *
 * @noreturn
 */
forward plugin_natives();

/**
 * Registers a native.
 *
 * @note Stlye 0 natives call the handler in the following manner:
 *
 * public native_handler(plugin_id, argc)
 *
 * plugin_id    - plugin calling the native
 * argc         - number of parameters
 *
 * @note Style 1 natives are deprecated. Plugins should not use them, they might
 *       break.
 * @note Style 1 natives work a little different. Instead of passing plugin id
 *       and number of parameters the handler should be prototyped just like the
 *       native would be called. For each by-reference parameter the plugin
 *       then has to use param_convert() to properly use them.
 * @note A native should *never* recurse. Bad things will happen.
 *
 * @param name      Native name
 * @param handler   Callback function
 * @param style     Native style
 *
 * @noreturn
 * @error           If an invalid callback is specified, an error is thrown.
 */
native register_native(const name[], const handler[], style=0);

/**
 * Registers the plugin as a library.
 *
 * @note To mark a library as required, place the following in the include
 *       file:
 *       #pragma reqlib <name>
 *       #if !defined AMXMODX_NOAUTOLOAD
 *          #pragma loadlib <name>
 *       #endif
 *
 * @noreturn
 */
native register_library(const library[]);

/**
 * Logs an error in the native and breaks into the AMXX debugger.
 *
 * @note This acts as if the calling plugin - the plugin that is calling the
 *       native, not the plugin calling this function - triggered the error,
 *       just like when AMXX natives error.
 *
 * @param error     Error number
 * @param fmt       Formatting rules
 * @param ...       Variable number of formatting parameters
 *
 * @noreturn
 * @error           The function is guaranteed to throw an error, but will make
 *                  it appear as if the plugin calling the native triggered it.
 */
native log_error(error, const fmt[], any:...);

/**
 * Converts a parameter to work as a by-reference parameter.
 *
 * @deprecated Style 1 natives are deprecated and should be converted to
 *             style 0. This should not be used.
 *
 * @note Only needs to be called this if the native was registered with style 1.
 * @note Remember that arrays (and strings) are always by-reference and need to
 *       be converted.
 *
 * @param num       Argument to convert, starting from 1
 *
 * @noreturn
 * @error           If used outside of a native callback or the native was
 *                  created with style 0, an error will be thrown.
 */
native param_convert(num);

/**
 * Retrieves a string from the plugin calling the native.
 *
 * @param param     Argument to retrieve, starting from 1
 * @param dest      Buffer to copy string to
 * @param maxlen    Maximum size of buffer
 *
 * @return          Number of cells copied to buffer
 * @error           If used outside of a native callback or the native was
 *                  created with style 1, an error will be thrown.
 */
native get_string(param, dest[], maxlen);

/**
 * Copies a string to the plugin calling the native.
 *
 * @param param     Argument to set, starting from 1
 * @param dest      Buffer to copy string from
 * @param maxlen    Maximum size of buffer
 *
 * @return          Number of cells copied from buffer
 * @error           If used outside of a native callback or the native was
 *                  created with style 1, an error will be thrown.
 */
native set_string(param, dest[], maxlen);

/**
 * Returns the integer value of a parameter from the plugin calling the native.
 *
 * @param param     Argument to retrieve, starting from 1
 *
 * @return          Integer value
 * @error           If used outside of a native callback or the native was
 *                  created with style 1, an error will be thrown.
 */
native get_param(param);

/**
 * Returns the float value of a parameter from the plugin calling the native.
 *
 * @param param     Argument to retrieve, starting from 1
 *
 * @return          Float value
 * @error           If used outside of a native callback or the native was
 *                  created with style 1, an error will be thrown.
 */
native Float:get_param_f(param);

/**
 * Returns the integer value of a by-reference parameter from the plugin calling
 * the native.
 *
 * @param param     Argument to retrieve, starting from 1
 *
 * @return          Integer value
 * @error           If used outside of a native callback or the native was
 *                  created with style 1, an error will be thrown.
 */
native get_param_byref(param);

/**
 * Returns the float value of a by-reference parameter from the plugin calling
 * the native.
 *
 * @param param     Argument to retrieve, starting from 1
 *
 * @return          Float value
 * @error           If used outside of a native callback or the native was
 *                  created with style 1, an error will be thrown.
 */
native Float:get_float_byref(param);

/**
 * Sets the integer value of a by-reference parameter to the plugin calling the
 * native.
 *
 * @param param     Argument to set, starting from 1
 * @param value     Value to set parameter to
 *
 * @noreturn
 * @error           If used outside of a native callback or the native was
 *                  created with style 1, an error will be thrown.
 */
native set_param_byref(param, value);

/**
 * Sets the float value of a by-reference parameter to the plugin calling the
 * native.
 *
 * @param param     Argument to set, starting from 1
 * @param value     Value to set parameter to
 *
 * @noreturn
 * @error           If used outside of a native callback or the native was
 *                  created with style 1, an error will be thrown.
 */
native set_float_byref(param, Float:value);

/**
 * Retrieves an array from the plugin calling the native.
 *
 * @param param     Argument to retrieve, starting from 1
 * @param dest      Buffer to copy array to
 * @param maxlen    Size of buffer
 *
 * @noreturn
 * @error           If used outside of a native callback or the native was
 *                  created with style 1, an error will be thrown.
 */
native get_array(param, dest[], size);

/**
 * Retrieves a float array from the plugin calling the native.
 *
 * @param param     Argument to retrieve, starting from 1
 * @param dest      Buffer to copy array to
 * @param maxlen    Size of buffer
 *
 * @noreturn
 * @error           If used outside of a native callback or the native was
 *                  created with style 1, an error will be thrown.
 */
native get_array_f(param, Float:dest[], size);

/**
 * Copies an array to the plugin calling the native.
 *
 * @param param     Argument to set, starting from 1
 * @param source    Buffer to copy array from
 * @param maxlen    Size of buffer
 *
 * @noreturn
 * @error           If used outside of a native callback or the native was
 *                  created with style 1, an error will be thrown.
 */
native set_array(param, const source[], size);

/**
 * Copies a float array to the plugin calling the native.
 *
 * @param param     Argument to set, starting from 1
 * @param source    Buffer to copy array from
 * @param maxlen    Size of buffer
 *
 * @noreturn
 * @error           If used outside of a native callback or the native was
 *                  created with style 1, an error will be thrown.
 */
native set_array_f(param, const Float:source[], size);

/**
 * Dispatches a client cvar query, allowing the plugin to query for its value on
 * the client.
 *
 * @note The callback will be called in the following manner:
 *
 * public cvar_query_callback(id, const cvar[], const value[], const param[])
 *
 *  id      - Client index
 *  cvar    - Cvar queried
 *  value   - Cvar value on the client
 *  param   - Extra data [optional]
 *
 * @param id            Client index
 * @param cvar          Cvar to query
 * @param resultFunc    Callback function
 * @param paramlen      Size of extra data
 * @param params        Extra data to pass through to callback
 *
 * @noreturn
 * @error               If the client index is not within the range of 1 to
 *                      MaxClients or the client is not connected, an error
 *                      will be thrown.
 *                      If the callback function is invalid, cvar querying is
 *                      unavailable or the querying process runs out of memory,
 *                      an error will be thrown.
 */
native query_client_cvar(id, const cvar[], const resultFunc[], paramlen=0, const params[]="");

/**
 * Allows to trap error messages that occur in a plugin.
 *
 * @note This can be used to override the debug messages that occur when the
 *       plugin causes some kind of runtime error.
 * @note The handler will be called in the following manner:
 *
 * public error_filter(error_code, bool:debugging, message[])
 *
 *  error_code      - AMX_ERR_* code.
 *  debugging       - True if the plugin is in debug mode, false otherwise
 *  message[]       - Message sent along with the error
 *
 * @note The handler should return PLUGIN_CONTINUE to let the error through the
 *       filter, or PLUGIN_HANDLED to block the error from displaying.
 *
 * @param handler       Callback function
 *
 * @error               If an invalid callback is specified, an error is thrown.
 */
native set_error_filter(const handler[]);

/**
 * Returns a trace handle for the item at the top of the traced call stack.
 *
 * @note Intended for use inside an error handler set with set_error_filter().
 *
 * @return      Trace handle, 0 if no debugging information is available
 */
native dbg_trace_begin();

/**
 * Returns the next item in a traced call stack.
 *
 * @param trace     Trace handle
 *
 * @return          New trace handle, 0 if no more traces exist
 */
native dbg_trace_next(trace);

/**
 * Retrieves the call stack info for a trace.
 *
 * @param trace         Trace handle
 * @param line          Variable to set line at which plugin failed to
 * @param function      Buffer to copy function to
 * @param maxLength1    Maximum function buffer size
 * @param file          Buffer to copy filename to
 * @param maxLength2    Maximum filename buffer size
 *
 * @return              1 on success, 0 if no trace data is available
 */
native dbg_trace_info(trace, &line, function[], maxLength1, file[], maxLength2);

/**
 * Retrieves the formatted error string from a trace.
 *
 * @note The string format is generally: "Run time error <errno>: <description>"
 *
 * @param buffer        Buffer to copy error message to
 * @param maxLength     Maximum buffer size
 *
 * @return              1 on success, 0 if no trace data is available
 */
native dbg_fmt_error(buffer[], maxLength);

/**
 * Sets a native filter, letting the plugin intercept and handle an
 * automatic native requirement.
 *
 * @note This has to be used inside the plugin_native() forward, otherwise it
 *       has no effect.
 * @note This is useful for creating plugins that can dynamically decide which
 *       modules or features to use at runtime, often necessary for cross-mod
 *       plugins. It allows to deploy a single version of the plugin instead
 *       of compiling multiple versions for each use-case.
 * @note The handler will be called in the following manner:
 *
 * public native_filter(const native[], index, trap)
 *
 *  native      - Native name
 *  index       - Native index
 *  trap        - 0 if native couldn't be found, 1 if native use was attempted
 *
 * @note The handler should return PLUGIN_CONTINUE to let the error through the
 *       filter (which will throw a run-time error), or return PLUGIN_HANDLED
 *       to continue operation.
 * @note Returning PLUGIN_CONTINUE if trap is 0 will result in the plugin
 *       failing to load!
 */
native set_native_filter(const handler[]);

/**
 * Sets a module/library filter, letting the plugin intercept and handle an
 * automatic module requirement.
 *
 * @note This has to be used inside the plugin_native() forward, otherwise it
 *       has no effect.
 * @note This is useful for creating plugins that can dynamically decide which
 *       modules or features to use at runtime, often necessary for cross-mod
 *       plugins. It allows to deploy a single version of the plugin instead
 *       of compiling multiple versions for each use-case.
 * @note For a list of possible libtypes see the LibType enum in amxconst.inc
 * @note The handler will be called in the following manner:
 *
 * public module_filter(const library[], LibType:type)
 *
 *  library     - Shortname of library or class that is required
 *  libtrype    - Type of requirement being checked (library/module or class)
 *
 * @note The handler should return PLUGIN_CONTINUE to let the error through the
 *       filter (which will result in the plugin failing to load), or
 *       PLUGIN_HANDLED to imply that load can continue without the module.
 * @note Errors occuring inside the handler will not be filtered and cause the
 *       plugin to fail load as if the handler returned PLUGIN_CONTINUE.
 *
 * @return      0 on success, -1 if filtering is not available, -2 if handler
 *              could not be found.
 */
native set_module_filter(const handler[]);

/**
 * Aborts execution of the current callback by throwing an error.
 *
 * @note Warning: This function should not be used inside error filters, module
 *       filters (native filters are safe if trap equals 1) or the
 *       plugin_natives() forward.
 * @note The message will automatically be tagged with the plugin's name and the
 *       log will include a timestamp with the message.
 * @note For a list of possible error codes see AMX_* constants in amxconst.inc
 *
 * @param error     Error code
 * @param fmt       Formatting rules
 * @param ...       Variable list of formatting parameters
 *
 * @noreturn
 * @error           The function is guaranteed to throw an error, using the
 *                  specified custom log message.
 */
native abort(error, const fmt[]="", any:...);

/**
 * Returns if a specific module is loaded.
 *
 * @note This uses the same method AMXX uses internally to see if a module is
 *       required by a plugin.
 * @note Example usage: module_exists("cstrike")
 *
 * @param logtag    Module shortname
 *
 * @return          1 if module is loaded, 0 otherwise
 */
native module_exists(const logtag[]);

/**
 * Returns if a specific library or class is loaded.
 *
 * @note This is the newer version of module_exists(), enabling users to
 *       distinguish between libraries and classes while module_exists() always
 *       checks for both types.
 * @note For a list of possible types see the LibType enum in amxconst.inc
 *
 * @param library   Library/Class shortname
 * @param type      Type to search for
 *
 * @return          1 if module is loaded, 0 otherwise
 */
native LibraryExists(const library[], LibType:type);

/**
 * Returns the next valid hudchannel for the client.
 *
 * @note This function uses the same method set_hudmessage() uses to determine
 *       the next channel if it is set to auto-select.
 *
 * @param player    Client index
 *
 * @return          Valid hudchannel (1-4)
 * @error           If the index is not within the range of 1 to MaxClients or
 *                  the client is not connected an error will be thrown.
 */
native next_hudchannel(player);

/**
 * Creates a HUD synchronization object.
 *
 * @note Create one of these for each section of the screen that contains
 *       overlapping HUD messages. For example, if using both sides of the
 *       screen to display three messages that could potentially overlap,
 *       each side is considered a synchronizable area. You can then use
 *       ShowSyncHudMsg() to correctly synchronize displaying the HUD message
 *       with any other messages potentially in its class.
 * @note This does not do anything like reserving screen area. Its sole
 *       purpose is to be able to wipe an old message on an auto-channel and
 *       ensure that it will not clear a message from another plugin.
 *
 * @param num   Unused and ignored
 * @param ...   Unused and ignored
 *
 * @return      HUD sync object handle
 */
native CreateHudSyncObj(num=0, ...);

/**
 * Displays a synchronized HUD message.
 *
 * @note This will check that the HUD object has its previous display on the
 *       screen cleared before it proceeds to write another message. It will
 *       only do this in the case of that channel not having been cleared
 *       already.
 * @note This uses the display parameters set with set_hudmessage(), ignoring
 *       the selected channel in favor of its own synchronization.
 *
 * @param target    Client index, use 0 to display to all clients
 * @param syncObj   HUD sync object handle
 * @param fmt       Formatting rules
 * @param ...       Variable number of formatting parameters
 *
 * @return          Number of printed characters
 *                  If 0 is specified as the index then 0 will be returned if
 *                  nothing has been sent. The number of printed characters will
 *                  otherwise refer to the message that is sent last, to the
 *                  client with the highest index.
 * @error           If a single client is specified and the index is not
 *                  within the range of 1 to MaxClients an error will be thrown
 */
native ShowSyncHudMsg(target, syncObj, const fmt[], any:...);

/**
 * Clears the display on a HUD sync object.
 *
 * @note This sends an empty message to the previously occupied HUD channel.
 *       It is not quite the same as manually sending an empty message to the
 *       sync object as that would send out two separate messages, one for
 *       clearing the occupied channel and another using a new channel, which
 *       will subsequently not mark the sync object as cleared.
 *
 * @param target    Client index, use 0 to display to all clients
 * @param syncObj   HUD sync object handle
 *
 * @noreturn
 * @error           If a single client is specified and the index is not
 *                  within the range of 1 to MaxClients an error will be thrown
 */
native ClearSyncHud(target, syncObj);

/**
 * Triggers the software interrupt 3, used for breaking into an attached
 * debugger.
 *
 * @note Warning: This is a debugging function that is not intended for general
 *       plugin use. Using this function will either halt the server and break
 *       into the attached debugger, or outright crash the server if no
 *       debugger is attached.
 *
 * @noreturn
 */
native int3();

/**
 * Sets the calling plugin to a failed state.
 *
 * @note Calling this will cause the calling plugin to completely cease
 *       operation. It is not possible to recover.
 * @note This should be used to gracefully handle fatal errors. The log message
 *       will appear in the AMXX error log.
 *
 * @param fmt   Formatting rules
 * @param ...   Variable number of formatting parameters
 *
 * @noreturn
 * @error       The function is guaranteed to throw a fatal error, ceasing
 *              further operation of the plugin.
 */
native set_fail_state(const fmt[], any:...);

/**
 * Returns the reference address of the variable passed in.
 *
 * @note Addresses are local to the plugin and do not represent a full CPU
 *       address.
 *
 * @param ...   Variable to retrieve address from
 *
 * @return      Variable address
 */
native get_var_addr(any:...);

/**
 * Returns the value of an address.
 *
 * @note Addresses can be acquired using get_var_addr().
 *
 * @param addr      Variable address
 *
 * @error           If the plugin attempts to access an address outside of the
 *                  stack or heap limits of the plugin, an error will be thrown.
 */
native get_addr_val(addr);

/**
 * Sets the value of an address.
 *
 * @note Addresses can be acquired using get_var_addr().
 *
 * @param addr      Variable address
 * @param val       Value to set
 *
 * @error           If the plugin attempts to access an address outside of the
 *                  stack or heap limits of the plugin, an error will be thrown.
 */
native set_addr_val(addr, val);

/**
 * Creates a global forward that will be called in all plugins.
 *
 * @note For a list of valid stop types see the ET_* constants in amxconst.inc
 * @note For a list of valid parameter types see the FP_* constants in
 *       amxconst.inc
 *
 * @param name          Function name to call
 * @param stop_type     Treatment of the plugin return values
 * @param ...           List of parameter types
 *
 * @return              Forward handle, -1 on failure
 */
native CreateMultiForward(const name[], stop_type, ...);

/**
 * Creates a private forward that will be called in a single plugin.
 *
 * @note Unlike other natives expecting a plugin id, specifying -1 will not
 *       select the calling plugin and instead throw an error.
 *
 * @param plugin_id     Plugin to call forward in. The plugin id can be
 *                      retrieved using find_plugin_byfile()
 * @param name          Function name to call
 * @param ...           List of parameter types
 *
 * @return              Forward handle, -1 on failure
 * @error               If an invalid plugin id is specified an error will be
 *                      thrown.
 */
native CreateOneForward(plugin_id, const name[], ...);

/**
 * Prepares an array for use in a forward. Pass the result ExecuteForward()
 * instead of the array itself.
 *
 * @param array         Array to prepare
 * @param size          Size of array
 * @param copyback      If nonzero modifications made by the called plugin(s)
 *                      will be copied back to the caller
 *
 * @return              Special handle for use in ExecuteForward()
 */
native PrepareArray(const array[], size, copyback=0);

/**
 * Executes a forward.
 *
 * @note Passing arrays requires them to be prepared using PrepareArray().
 *
 * @param forward_handle    Forward handle
 * @param ret               Variable to store return value in
 * @param ...               Variable number of parameters to pass through
 *
 * @return                  1 on success, 0 if forward can't be executed
 * @error                   If the number of parameters mismatch from the number
 *                          of parameters that the forward was declared with,
 *                          an error is thrown.
 */
native ExecuteForward(forward_handle, &ret, any:...);

/**
 * Destroys and deallocates a forward.
 *
 * @note Does not distinguish between private and global forwards.
 *
 * @param forward_handle    Forward handle
 *
 * @noreturn
 */
native DestroyForward(forward_handle);

/**
 * Returns the cvar pointer of the specified cvar.
 *
 * @note A pointer is also returned by register_cvar(). Plugins can (and should)
 *       retrieve and use pointers for already existing mod cvars.
 *
 * @param cvar      Cvar name to find
 *
 * @return          Cvar pointer on success, 0 if cvar was not found
 */
native get_cvar_pointer(const cvar[]);

/**
 * Returns flags of a cvar via direct pointer access.
 *
 * @note For a list of possible flags see the FCVAR_* constants in amxconst.inc
 *
 * @param pcvar     Pointer to cvar to retrieve flags from
 *
 * @return          1 on success, 0 if cvar pointer is invalid
 * @error           If an invalid cvar pointer is specified, an error is thrown.
 */
native get_pcvar_flags(pcvar);

/**
 * Sets specified flags to a cvar via direct pointer access.
 *
 * @note For a list of possible flags see the FCVAR_* constants in amxconst.inc
 * @note This function directly sets the provided bitflag, unlike set_cvar_flags
 *       which adds them using a bitwise OR.
 *
 * @param pcvar     Pointer to cvar to set flags of
 * @param flags     Bitflag sum of flags to set
 *
 * @return          1 on success, 0 if cvar does not exist or is not permitted
 * @error           If an invalid cvar pointer is specified, an error is thrown.
 */
native set_pcvar_flags(pcvar, flags);

/**
 * Returns an integer value from a cvar via direct pointer access.
 *
 * @param pcvar     Pointer to cvar to retrieve value from
 *
 * @return          Cvar value, converted to int
 * @error           If an invalid cvar pointer is specified, an error is thrown.
 */
native get_pcvar_num(pcvar);

/**
 * Sets an integer value to a cvar via direct pointer access.
 *
 * @param pcvar     Pointer to cvar to set value of
 * @param num       Value to set cvar to
 *
 * @noreturn
 * @error           If an invalid cvar pointer is specified, an error is thrown.
 */
native set_pcvar_num(pcvar, num);

/**
 * Returns a float value from a cvar via direct pointer access.
 *
 * @param pcvar     Pointer to cvar to retrieve value from
 *
 * @return          Cvar value, converted to float
 * @error           If an invalid cvar pointer is specified, an error is thrown.
 */
native Float:get_pcvar_float(pcvar);

/**
 * Sets a float value to a cvar via direct pointer access.
 *
 * @param pcvar     Pointer to cvar to set value of
 * @param num       Value to set cvar to
 *
 * @noreturn
 * @error           If an invalid cvar pointer is specified, an error is thrown.
 */
native set_pcvar_float(pcvar, Float:num);

/**
 * Returns a string value from a cvar via direct pointer access.
 *
 * @param pcvar     Pointer to cvar to retrieve value from
 * @param string    Buffer to copy cvar value to
 * @param maxlen    Maximum size of the buffer
 *
 * @return          Number of cells written to buffer.
 * @error           If an invalid cvar pointer is specified, an error is thrown.
 */
native get_pcvar_string(pcvar, string[], maxlen);

/**
 * Sets a string value to a cvar via direct pointer access.
 *
 * @param pcvar     Pointer to cvar to retrieve value from
 * @param string    Value to set cvar to
 *
 * @noreturn
 * @error           If an invalid cvar pointer is specified, an error is thrown.
 */
native set_pcvar_string(pcvar, const string[]);

/**
 * Sets all elements of array to a specified value.
 *
 * @param array     Array to modify
 * @param value     Value to set each element to
 * @param size      Size of array
 *
 * @noreturn
 */
native arrayset(array[], value, size);

/**
 * Returns the weapon id associated with a weapon name.
 *
 * @note The weapon name is case sensitive and has the weapon_* form.
 *
 * @param name      Weapon name
 *
 * @return          Weapon id, or 0 if no id was found
 */
native get_weaponid(const name[]);

/**
 * Adds an admin to the dynamic admin storage for lookup at a later time
 *
 * @note For a list of possible access flags see the ADMIN_* constans in
 *       amxconst.inc
 * @note For a list of possible auth flags see the FLAG_* constants in
 *       amxconst.inc
 *
 * @param AuthData      Auth information to set (can be name, IP or SteamID)
 * @param Password      Password to set
 * @param Access        Admin access flags
 * @param Flags         Auth behavior flags
 *
 * @noreturn
 */
native admins_push(const AuthData[], const Password[], Access, Flags);

/**
 * Returns the number of admins in the dynamic admin storage
 *
 * @return  Number of admins
 */
native admins_num();

/**
 * Retrieves information about a dynamically stored admin.
 *
 * @note For a list of possible props see the AdminProp enum in amxconst.inc
 *
 * @param num           Admin storage index
 * @param Property      Admin property to retrieve
 * @param Buffer        Buffer to copy property information to if AdminProp_Auth
 *                      or AdminProp_Password is specified
 * @param BufferSize    Maximum buffer size
 *
 * @return              Property value if AdminProp_Access or AdminProp_Flags
 *                      is requested. 0 otherwise.
 * @error               If an invalid storage index is specified, an error will
 *                      be thrown.
 */
native admins_lookup(num, AdminProp:Property, Buffer[]="", BufferSize=0);

/**
 * Clears the list of dynamically stored admins
 *
 * @noreturn
 */
native admins_flush();

/**
 * Returns if a map contains at least one entity with the provided class name.
 *
 * @param classname     Entity classname to match
 *
 * @return              True if an entity is found, false otherwise
 */
native bool:has_map_ent_class(const classname[]);


// Always keep this at the bottom of this file
#include <message_stocks>
// vim: set ts=4 sw=4 tw=99 noet:
//
// AMX Mod X, based on AMX Mod by Aleksander Naszko ("OLO").
// Copyright (C) The AMX Mod X Development Team.
//
// This software is licensed under the GNU General Public License, version 3 or higher.
// Additional exceptions apply. For full license details, see LICENSE.txt or visit:
//     https://alliedmods.net/amxmodx-license

#if defined _amxmodx_version_included
  #endinput
#endif
#define _amxmodx_version_included

#define AMXX_VERSION		1.83
#define AMXX_VERSION_NUM	183
stock const AMXX_VERSION_STR[] = "1.8.3-manual";
// vim: set ts=4 sw=4 tw=99 noet:
//
// AMX Mod X, based on AMX Mod by Aleksander Naszko ("OLO").
// Copyright (C) The AMX Mod X Development Team.
//
// This software is licensed under the GNU General Public License, version 3 or higher.
// Additional exceptions apply. For full license details, see LICENSE.txt or visit:
//     https://alliedmods.net/amxmodx-license

#if defined _cellarray_included
	#endinput
#endif

#define _cellarray_included

/**
 * Cellarray tag declaration
 *
 * @note These dynamic arrays are intended to be used for a form of global
 *       storage without requiring a #define that needs to be increased each
 *       time the plugin author requires more storage. These are not designed
 *       to be a full replacement for normal arrays, as those are faster and
 *       should be used whenever possible.
 * @note Plugins are responsible for freeing all Array handles they acquire,
 *       including those from ArrayClone. Failing to free handles will result
 *       in the plugin and AMXX leaking memory.
 */
enum Array
{
	Invalid_Array = 0
};

/**
 * Returns the number of cells required to fit a string of the specified size
 * (including the null terminator).
 *
 * @param size          Number of bytes.
 *
 * @return              Minimum number of cells required to fit the byte count.
 */
stock ByteCountToCells(size)
{
	if (!size)
	{
		return 1;
	}

	return (size + 3) / 4;
}

/**
 * Creates a handle to a dynamically sized array.
 *
 * @note It is very important that the provided cellsize matches up with the
 *       buffer sizes that are passed with subsequent Array[Get|Set|Push] calls.
 * @note Initially the "reserved" parameter was intended to create blank entries
 *       that would immediately be usable with Array[Get|Set] functions. This
 *       functionality was never working as intended, and can now be achieved
 *       using ArrayResize().
 *
 * @param cellsize      Size of each array entry in cells
 * @param reserved      Pre-allocates space in the array for the specified
 *                      number of items. The items are not valid to read or set
 *                      until they have actually been pushed into the array.
 *
 * @return              Handle to the array.
 */
native Array:ArrayCreate(cellsize = 1, reserved = 32);

/**
 * Clones an array, returning a new handle with the same size and data.
 *
 * @param which         Array handle
 *
 * @return              Handle to the cloned array on success, 0 otherwise
 * @error               If an invalid handle is provided an error will be
 *                      thrown.
 */
native Array:ArrayClone(Array:which);

/**
 * Clears all entries from the array.
 *
 * @param which         Array handle
 *
 * @noreturn
 * @error               Invalid handle
 */
native ArrayClear(Array:which);

/**
 * Returns the number of elements in the array.
 *
 * @param which         Array handle
 *
 * @return              Number of elements in the array
 * @error               If an invalid handle is provided an error will be
 *                      thrown.
 */
native ArraySize(Array:which);

/**
 * Resizes an array.
 *
 * @note If the size is smaller than the current array size the array is
 *       truncated and data lost.
 *
 * @param which         Array handle
 * @param newsize       New size
 *
 * @noreturn
 * @error               If an invalid handle is provided or the resizing
 *                      operation runs out of memory, an error will be thrown.
 */
native bool:ArrayResize(Array:which, newsize);

/**
 * Retrieves an array of data from a cellarray.
 *
 * @note If the size parameter is specified as -1 the output buffer has to match
 *       the size the array was created with.
 *
 * @param which         Array handle
 * @param item          Item index in the array
 * @param output        Buffer to copy value to
 * @param size          If not set, assumes the buffer size is equal to the
 *                      cellsize. Otherwise, the specified size is used.
 *
 * @return              Number of cells copied
 * @error               If an invalid handle or index is provided an error will
 *                      be thrown.
 */
native ArrayGetArray(Array:which, item, any:output[], size = -1);

/**
 * Returns a single cell of data from an array
 *
 * @param which         Array handle
 * @param item          Item index in the array
 * @param block         If the array has a cellsize >1 this optionally specifies
 *                      which block to read from
 * @param asChar        If true reads the value as a byte instead of a cell
 *
 * @return              Integer value
 * @error               If an invalid handle, index or block is provided an
 *                      error will be thrown.
 */
native any:ArrayGetCell(Array:which, item, block = 0, bool:asChar = false);

/**
 * Returieves string data from an array.
 *
 * @param which         Array handle
 * @param item          Item index in the array
 * @param output        Buffer to copy value to
 * @param size          Maximum size of the buffer
 *
 * @return              Number of characters copied
 * @error               If an invalid handle or an invalid index is provided an
 *                      error will be thrown.
 */
native ArrayGetString(Array:which, item, output[], size);

/**
 * Fills an item's data with the contents of an array.
 *
 * @note If the size parameter is specified as -1 the input buffer has to match
 *       the size the array was created with.
 * @note The item index must already be valid. Use ArrayPushArray to create
 *       a new array item in the cellarray.
 *
 * @param which         Array handle
 * @param item          Item index in the array
 * @param input         Array to copy to the cellarray
 * @param size          If not set, assumes the buffer size is equal to the
 *                      cellsize. Otherwise, the specified size is used.
 *
 * @return              Number of cells copied
 * @error               If an invalid handle or an invalid index is provided an
 *                      error will be thrown.
 */
native ArraySetArray(Array:which, item, const any:input[], size =-1);

/**
 * Sets an item's data to a single cell value.
 *
 * @note The item index must already be valid. Use ArrayPushArray to create
 *       a new array item in the cellarray.
 *
 * @param which         Array handle
 * @param item          Item index in the array
 * @param input         Value to set
 * @param block         If the array has a cellsize >1 this optionally specifies
 *                      which block to write to
 * @param asChar        If true writes the value as a byte instead of a cell
 *
 * @noreturn
 * @error               If an invalid handle, index or block is provided an
 *                      error will be thrown.
 */
native ArraySetCell(Array:which, item, any:input, block = 0, bool:asChar = false);

/**
 * Sets an item's data to a string value.
 *
 * @note The input will be truncated if it is longer than the cellsize the array
 *       was created with.
 * @note The item index must already be valid. Use ArrayPushString to create
 *       a new array item in the cellarray.
 *
 * @param which         Array handle
 * @param item          Item index in the array
 * @param input         String to copy to the array
 *
 * @return              Number of characters copied
 * @error               If an invalid handle or an invalid index is provided an
 *                      error will be thrown.
 */
native ArraySetString(Array:which, item, const input[]);

/**
 * Creates a new item at the end of the cellarray and copies the provided array
 * into it.
 *
 * @note The input will be truncated if it is bigger than the cellsize the array
 *       was created with.
 *
 * @param which         Array handle
 * @param input         Array to copy to the cellarray
 * @param size          If not set, assumes the buffer size is equal to the
 *                      cellsize. Otherwise, the specified size is used.
 *
 * @return              Index of the new entry
 * @error               If an invalid handle is provided or the resizing
 *                      operation runs out of memory, an error will be thrown.
 */
native ArrayPushArray(Array:which, const any:input[], size = -1);

/**
 * Creates a new item ath the end of the array and sets the item's single cell
 * value.
 *
 * @param which         Array handle
 * @param input         Value to set
 *
 * @return              Index of the new entry
 * @error               If an invalid handle is provided or the resizing
 *                      operation runs out of memory, an error will be thrown.
 */
native ArrayPushCell(Array:which, any:input);

/**
 * Creates a new item at the end of the array and copies the provided string
 * into it.
 *
 * @note The input will be truncated if it is longer than the cellsize the array
 *       was created with.
 *
 * @param which         Array handle
 * @param input         String to copy to the array
 *
 * @return              Index of the new entry
 * @error               If an invalid handle is provided or the resizing
 *                      operation runs out of memory, an error will be thrown.
 */
native ArrayPushString(Array:which, const input[]);

/**
 * Creates a new item behind the specified item and copies the provided array
 * into it. All items beyond it get shifted up by one.
 *
 * @param which         Array handle
 * @param item          Item index in the array
 * @param input         Array to copy to the cellarray
 *
 * @noreturn
 * @error               If an invalid handle or an invalid index is provided an
 *                      error will be thrown.
 */
native ArrayInsertArrayAfter(Array:which, item, const any:input[]);

/**
 * Creates a new item behind the specified item and sets the item's single cell
 * value. All items beyond it get shifted up by one.
 *
 * @param which         Array handle
 * @param item          Item index in the array
 * @param input         Value to set
 *
 * @noreturn
 * @error               If an invalid handle or an invalid index is provided an
 *                      error will be thrown.
 */
native ArrayInsertCellAfter(Array:which, item, any:input);

/**
 * Creates a new item behind the specified item and copies the provided string
 * into it. All items beyond it get shifted up by one.
 *
 * @note The input will be truncated if it is longer than the cellsize the array
 *       was created with.
 *
 * @param which         Array handle
 * @param item          Item index in the array
 * @param input         String to copy to the array
 *
 * @noreturn
 * @error               If an invalid handle or an invalid index is provided an
 *                      error will be thrown.
 */
native ArrayInsertStringAfter(Array:which, item, const input[]);

/**
 * Creates a new item in front of the specified item and copies the provided
 * array into it. All items beyond it get shifted up by one.
 *
 * @param which         Array handle
 * @param item          Item index in the array
 * @param input         Array to copy to the cellarray
 *
 * @noreturn
 * @error               If an invalid handle or an invalid index is provided an
 *                      error will be thrown.
 */
native ArrayInsertArrayBefore(Array:which, item, const any:input[]);

/**
 * Creates a new item in front of the specified item and sets the item's single
 * cell value. All items beyond it get shifted up by one.
 *
 * @param which         Array handle
 * @param item          Item index in the array
 * @param input         Value to set
 *
 * @noreturn
 * @error               If an invalid handle or an invalid index is provided an
 *                      error will be thrown.
 */
native ArrayInsertCellBefore(Array:which, item, const any:input);

/**
 * Creates a new item in front of the specified item and copies the provided
 * string into it. All items beyond it get shifted up by one.
 *
 * @note The input will be truncated if it is longer than the cellsize the array
 *       was created with.
 *
 * @param which         Array handle
 * @param item          Item index in the array
 * @param input         String to copy to the array
 *
 * @noreturn
 * @error               If an invalid handle or an invalid index is provided an
 *                      error will be thrown.
 */
native ArrayInsertStringBefore(Array:which, item, const input[]);

/**
 * Swaps the position of two items.
 *
 * @param which         Array handle
 * @param item1,item2   Item pair to swap
 *
 * @noreturn
 * @error               If an invalid handle or an invalid index is provided an
 *                      error will be thrown.
 */
native ArraySwap(Array:which, item1, item2);

/**
 * Deletes an item from the array. All items beyond it get shifted down by one.
 *
 * @param which         Array handle
 * @param item          Item to delete
 *
 * @noreturn
 * @error               If an invalid handle or an invalid index is provided an
 *                      error will be thrown.
 */
native ArrayDeleteItem(Array:which, item);

/**
 * Searches through the array and returns the index of the first occurence of
 * the specified string.
 *
 * @param which         Array handle
 * @param item          String to search for
 *
 * @return              Array index on success, -1 if the string can't be found
 * @error               Invalid handle.
 */
native ArrayFindString(Array:which, const item[]);

/**
 * Searches through the array and returns the index of the first occurence of
 * the specified value.
 *
 * @param which         Array handle
 * @param item          Value to search for
 *
 * @return              Array index on success, -1 if the value can't be found
 * @error               If an invalid handle is provided an error will be
 *                      thrown.
 */
native ArrayFindValue(Array:which, any:item);

/**
 * Creates a special handle that can be passed to a string format routine for
 * printing as a string (with the %a format option).
 *
 * @note It is recommended to pass the function as a parameter to the format
 *       routine directly. The array item must contain a null-terminated string!
 * @note Do not save or otherwise use the handles returned by this function.
 * @note Example usage:
 *       console_print(id, "%a", ArrayGetStringHandle(MessageArray, i));
 *
 * @param which         Array handle
 * @param item          Item to retrieve handle of
 *
 * @return              Handle to the item
 * @error               If an invalid handle or an invalid index is provided an
 *                      error will be thrown.
 */
native DoNotUse:ArrayGetStringHandle(Array:which, item);

/**
 * Destroys the array and frees its memory.
 *
 * @note The function automatically sets the variable passed to it to 0 to aid
 *       in preventing accidental usage after destroy.
 *
 * @param which         Array to destroy
 *
 * @return              1 if the array was destroyed, 0 if nothing had to be
 *                      destroyed (invalid handle)
 */
native ArrayDestroy(&Array:which);

/**
 * Similar to sorting.inc's CustomSort, the sorting algorithm then uses the
 * custom comparison function to sort the data.
 *
 * @note The function is called in the following manner:
 *
 * public MySortFunc(Array:array, item1, item2, const data[], data_size)
 *
 *  array           - Array handle in its current un-sorted state
 *  item1, item2    - Current item pair being compared
 *  data[]          - Extra data array passed to the sort func
 *  data_size       - Size of extra data
 *
 * @note The comparison function should return:
 *         -1 if item1 should go before item2
 *          0 if item1 and item2 are equal
 *          1 if item1 should go after item2
 *
 * @note All parameters after item2 are optional and do not need to be specified
 *       and used.
 * @note Unlike the sorting.inc version, the array passed to the callback is not
 *       in mid-sorted state.
 *
 * @param array         Array handle
 * @param comparefunc   Callback function used for comparison
 * @param data          Extra data that is passed through to the callback
 * @param data_size     Size of extra data
 *
 * @noreturn
 * @error               If an invalid handle or an invalid callback is provided
 *                      an error will be thrown.
 */
native ArraySort(Array:array, const comparefunc[], data[]="", data_size=0);

/**
 * A faster version of ArraySort, the sorting algorithm then uses the custom
 * comparison function to sort the data.
 *
 * @note The advantage of this function is that the data of the elements being
 *       compared is directly passed to the function, instead of the item
 *       indexes that are passed by ArraySort. This removes the need for calling
 *       ArrayGet[Cell|String|Array] every time before being able to compare the
 *       elements.
 *
 * @note For Arrays with a cellsize of 1 (used for storing integers and floats),
 *       the function is called in the following manner:
 *
 * public MySortFunc(Array:array, elem1, elem2, const data[], data_size)
 *
 *  array           - Array handle in its current un-sorted state
 *  elem1, elem2    - Current element pair being compared
 *  data[]          - Extra data array passed to the sort func
 *  data_size       - Size of extra data
 *
 * @note For Arrays with a cellsize larger than 1 (used for storing arrays and
 *       strings), the function is called in the following manner:
 *
 * public MySortFunc(Array:array, elem1[], elem2[], const data[], data_size)
 *
 *  array               - Array handle in its current un-sorted state
 *  elem1[], elem2[]    - Current element pair being compared
 *  data[]              - Extra data array passed to the sort func
 *  data_size           - Size of extra data
 *
 *
 * @note The comparison function should return:
 *         -1 if elem1 should go before elem2
 *          0 if elem1 and elem2 are equal
 *          1 if elem1 should go after elem2
 *
 * @note All parameters after item2 are optional and do not need to be specified
 *       and used.
 * @note Unlike the sorting.inc version, the array passed to the callback is not
 *       in mid-sorted state.
 *
 * @param array         Array handle
 * @param comparefunc   Callback function used for comparison
 * @param data          Extra data that is passed through to the callback
 * @param data_size     Size of extra data
 *
 * @noreturn
 * @error               If an invalid handle or an invalid callback is provided
 *                      an error will be thrown.
 */
native ArraySortEx(Array:array, const comparefunc[], data[]="", data_size=0);
// vim: set ts=4 sw=4 tw=99 noet:
//
// AMX Mod X, based on AMX Mod by Aleksander Naszko ("OLO").
// Copyright (C) The AMX Mod X Development Team.
//
// This software is licensed under the GNU General Public License, version 3 or higher.
// Additional exceptions apply. For full license details, see LICENSE.txt or visit:
//     https://alliedmods.net/amxmodx-license

#if defined _cellstack_included
	#endinput
#endif
#define _cellstack_included

enum Stack
{
	Invalid_Stack = 0
};

/**
 * Creates a stack structure.  A stack is a LIFO (last in, first out)
 * vector (array) of items.  It has O(1) insertion and O(1) removal.
 *
 * Stacks have two operations: Push (adding an item) and Pop (removes
 * items in reverse-push order).
 *
 * The contents of the stack are uniform; i.e. storing a string and then
 * retrieving it as an integer is NOT the same as StringToInt()!
 *
 * The "blocksize" determines how many cells each slot has; it cannot
 * be changed after creation.
 *
 * @param blocksize     The number of cells each entry in the stack can
 *                      hold.  For example, 32 cells is equivalent to:
 *                      new Array[X][32]
 *
 * @return              New stack Handle.
 * @error               Invalid block size.
 */
native Stack:CreateStack(blocksize = 1);

/**
 * Pushes a value onto the end of the stack, adding a new index.
 *
 * This may safely be used even if the stack has a blocksize
 * greater than 1.
 *
 * @param handle        Stack handle.
 * @param value         Value to push.
 *
 * @noreturn
 * @error               Invalid handle or out of memory.
 */
native PushStackCell(Stack:handle, any:value);

/**
 * Pushes a string onto the end of a stack, truncating it if it is
 * too big.
 *
 * @param handle        Stack handle.
 * @param value         String to push.
 *
 * @noreturn
 * @error               Invalid handle or out of memory.
 */
native PushStackString(Stack:handle, const value[]);

/**
 * Pushes an array of cells onto the end of a stack.  The cells
 * are pushed as a block (i.e. the entire array takes up one stack slot),
 * rather than pushing each cell individually.
 *
 * @param handle        Stack handle.
 * @param values        Block of values to copy.
 * @param size          If not set, the number of elements copied from the array
 *                      will be equal to the blocksize.  If set higher than the
 *                      blocksize, the operation will be truncated.
 * @noreturn
 * @error               Invalid handle or out of memory.
 */
native PushStackArray(Stack:handle, const any:values[], size= -1);

/**
 * Pops a cell value from a stack.
 *
 * @param handle        Stack handle.
 * @param value         Variable to store the value.
 * @param block         Optionally specify which block to read from
 *                      (useful if the blocksize > 0).
 * @param asChar        Optionally read as a byte instead of a cell.
 *
 * @return              True on success, false if the stack is empty.
 * @error               Invalid handle, Invalid block or Invalid byte.
 */
native bool:PopStackCell(Stack:handle, &any:value, block = 0, bool:asChar = false);

/**
 * Pops a string value from a stack.
 *
 * @param handle        Stack handle.
 * @param buffer        Buffer to store string.
 * @param maxlength     Maximum size of the buffer.
 * @param written       Number of characters copied.
 *
 * @return              True on success, false if the stack is empty.
 * @error               Invalid handle.
 */
native bool:PopStackString(Stack:handle, buffer[], maxlength, &written = 0);

/**
 * Pops an array of cells from a stack.
 *
 * @param handle        Stack handle.
 * @param buffer        Buffer to store the array in.
 * @param size          If not set, assumes the buffer size is equal to the
 *                      blocksize.  Otherwise, the size passed is used.
 *
 * @return              True on success, false if the stack is empty.
 * @error               Invalid handle.
 */
native bool:PopStackArray(Stack:handle, any:buffer[], size = -1);

/**
 * Checks if a stack is empty.
 *
 * @param handle        Stack handle.
 *
 * @return              True if empty, false if not empty.
 * @error               Invalid handle.
 */
native bool:IsStackEmpty(Stack:handle);

/**
 * Pops a value off a stack, ignoring it completely.
 *
 * @param handle        Stack handle.
 *
 * @return              True if something was popped, false otherwise.
 * @error               Invalid handle.
 */
stock PopStack(Stack:handle)
{
	new value;
	return PopStackCell(handle, value);
}

/**
 * Destroys the stack, and resets the handle to 0 to prevent accidental usage after it is destroyed.
 *
 * @param which         The stack to destroy.
 *
 * @noreturn
 */
native DestroyStack(&Stack:handle);
// vim: set ts=4 sw=4 tw=99 noet:
//
// AMX Mod X, based on AMX Mod by Aleksander Naszko ("OLO").
// Copyright (C) The AMX Mod X Development Team.
//
// This software is licensed under the GNU General Public License, version 3 or higher.
// Additional exceptions apply. For full license details, see LICENSE.txt or visit:
//     https://alliedmods.net/amxmodx-license

#if defined _celltrie_included
	#endinput
#endif
#define _celltrie_included

enum Trie
{
	Invalid_Trie = 0
};

enum Snapshot
{
	Invalid_Snapshot = 0
};

/**
 * Creates a hash map. A hash map is a container that can map strings (called
 * "keys") to arbitrary values (cells, arrays, or strings). Keys in a hash map
 * are unique. That is, there is at most one entry in the map for a given key.
 *
 * Insertion, deletion, and lookup in a hash map are all considered to be fast
 * operations, amortized to O(1), or constant time.
 *
 * The word "Trie" in this API is historical. As of AMX Mod X 1.8.3, tries have
 * been internally replaced with hash tables, which have O(1) insertion time
 * instead of O(n).
 *
 * @return 			New Map handle, which must be freed via TrieDestroy().
 */
native Trie:TrieCreate();

/**
 * Clears all entries from a Map.
 *
 * @param handle	Map handle.
 *
 * @error			Invalid handle.
 */
native TrieClear(Trie:handle);

/**
 * Sets a value in a hash map, either inserting a new entry or replacing an old one.
 *
 * @param handle	Map handle.
 * @param key		Key string.
 * @param value		Value to store at this key.
 * @param replace	If false, operation will fail if the key is already set.
 *
 * @return			True on success, false on failure.
 * @error			Invalid handle.
 */
native TrieSetCell(Trie:handle, const key[], any:value, bool:replace = true);

/**
 * Sets a string value in a Map, either inserting a new entry or replacing an old one.
 *
 * @param handle	Map handle.
 * @param key		Key string.
 * @param value		String to store.
 * @param replace	If false, operation will fail if the key is already set.
 *
 * @return			True on success, false on failure.
 * @error			Invalid handle.
 */
native TrieSetString(Trie:handle, const key[], const value[], bool:replace = true);

/**
 * Sets an array value in a Map, either inserting a new entry or replacing an old one.
 *
 * @param handle	Map handle.
 * @param key		Key string.
 * @param buffer	Array to store.
 * @param size		Number of items in the array.
 * @param replace	If false, operation will fail if the key is already set.
 *
 * @return			True on success, false on failure.
 * @error			Invalid handle.
 *					Invalid array size.
 */
native TrieSetArray(Trie:handle, const key[], const any:buffer[], size, bool:replace = true);

/**
 * Retrieves a value in a Map.
 *
 * @param handle	Map handle.
 * @param key		Key string.
 * @param value		Variable to store value.
 * @return			True on success.  False if the key is not set, or the key is set
 *					as an array or string (not a value).
 * @error			Invalid handle.
 */
native bool:TrieGetCell(Trie:handle, const key[], &any:value);

/**
 * Retrieves a string in a Map.
 *
 * @param handle		Map handle.
 * @param key			Key string.
 * @param output		Buffer to store value.
 * @param outputsize	Maximum size of string buffer.
 * @param size			Optional parameter to store the number of bytes written to the buffer.
 *
 * @return				True on success.  False if the key is not set, or the key is set
 *						as a value or array (not a string).
 * @error				Invalid handle.
 *						Invalid buffer size.
 */
native bool:TrieGetString(Trie:handle, const key[], output[], outputsize, &size = 0);

/**
 * Retrieves an array in a Map.
 *
 * @param handle		Map handle.
 * @param key			Key string.
 * @param output		Buffer to store array.
 * @param outputsize	Maximum size of array buffer.
 * @param size			Optional parameter to store the number of elements written to the buffer.
 *
 * @return				True on success.  False if the key is not set, or the key is set
 *						as a value or string (not an array).
 * @error				Invalid handle.
 *						Invalid array size.
 */
native bool:TrieGetArray(Trie:handle, const key[], any:output[], outputsize, &size = 0);

/**
 * Removes a key entry from a Map.
 *
 * @param handle	Map handle.
 * @param key		Key string.
 *
 * @return			True on success, false if the value was never set.
 * @error			Invalid handle.
 */
native bool:TrieDeleteKey(Trie:handle, const key[]);

/**
 * Checks a key entry existence from a Map.
 *
 * @param handle	Map handle.
 * @param key		Key string.
 *
 * @return			True on success, false if the value was never set.
 * @error			Invalid handle.
 */
native bool:TrieKeyExists(Trie:handle, const key[]);

/**
 * Destroys a Map.
 *
 * @param handle	Map handle.
 *
 * @return			True on success, false if the value was never set.
 * @error			Invalid handle.
 */
native TrieDestroy(&Trie:handle);

/**
 * Retrieves the number of elements in a map.
 *
 * @param handle	Map handle.
 *
 * @return			Number of elements in the trie.
 * @error			Invalid handle.
 */
native TrieGetSize(Trie:handle);

/**
 * Creates a snapshot of all keys in the map. If the map is changed after this
 * call, the changes are not reflected in the snapshot. Keys are not sorted.
 *
 * @param handle    Map handle.
 *
 * @return			New map snapshot handle, which must be freed via TrieSnapshotDestroy().
 * @error			Invalid handle.
 */
native Snapshot:TrieSnapshotCreate(Trie:handle);

/**
 * Returns the number of keys in a map snapshot. Note that this may be
 * different from the size of the map, since the map can change after the
 * snapshot of its keys was taken.
 *
 * @param handle	Map snapshot.
 *
 * @return			Number of keys.
 * @error			Invalid handle.
 */
native TrieSnapshotLength(Snapshot:handle);

/**
 * Returns the buffer size required to store a given key. That is, it returns
 * the length of the key plus one.
 *
 * @param handle	Map snapshot.
 * @param index		Key index (starting from 0).
 *
 * @return 			Buffer size required to store the key string.
 * @error			Invalid handle or index out of range.
 */
native TrieSnapshotKeyBufferSize(Snapshot:handle, index);

/**
 * Retrieves the key string of a given key in a map snapshot.
 *
 * @param handle	Map snapshot.
 * @param index		Key index (starting from 0).
 * @param buffer	String buffer.
 * @param maxlength	Maximum buffer length.
 *
 * @return			Number of bytes written to the buffer.
 * @error			Invalid handle or index out of range.
 */
native TrieSnapshotGetKey(Snapshot:handle, index, buffer[], maxlength);

/**
 * Destroys a Map snapshot
 *
 * @param handle	Map snapshot.
 *
 * @return			True on success, false if the value was never set.
 * @error			Invalid handle.
 */
native TrieSnapshotDestroy(&Snapshot:handle);
/* Core functions
*
* (c) Copyright 1998-2003, ITB CompuPhase
*
* This file is provided as is (no warranties).
*/

#if defined _core_included
  #endinput
#endif
#define _core_included

native heapspace();

native funcidx(const name[]);

native numargs();
native getarg(arg, index=0);
native setarg(arg, index=0, value);

native tolower(c);
native toupper(c);
native swapchars(c);

native random(max);

native min(value1, value2);
native max(value1, value2);
native clamp(value, min=cellmin, max=cellmax);

native power(value, exponent);
native sqroot(value);

native time(&hour=0,&minute=0,&second=0);
native date(&year=0,&month=0,&day=0);

native tickcount(&granularity=0);

stock abs(x)
{
	return x > 0 ? x : -x;
}
// vim: set ts=4 sw=4 tw=99 noet:
//
// AMX Mod X, based on AMX Mod by Aleksander Naszko ("OLO").
// Copyright (C) The AMX Mod X Development Team.
//
// This software is licensed under the GNU General Public License, version 3 or higher.
// Additional exceptions apply. For full license details, see LICENSE.txt or visit:
//     https://alliedmods.net/amxmodx-license

#if defined _csstats_included
  #endinput
#endif
#define _csstats_included

/* Gets stats from given weapon index. If wpnindex is 0
* then the stats are from all weapons. If weapon has not been used function
* returns 0 in other case 1. Fields in stats are:
* 0 - kills
* 1 - deaths
* 2 - headshots
* 3 - teamkilling
* 4 - shots
* 5 - hits
* 6 - damage

* For body hits fields see amxconst.inc. */
native get_user_wstats(index,wpnindex,stats[8],bodyhits[8]);

/* Gets round stats from given weapon index.*/
native get_user_wrstats(index,wpnindex,stats[8],bodyhits[8]);

/* Gets overall stats which are stored in file on server
* and updated on every respawn or user disconnect.
* Function returns the position in stats by diff. kills to deaths. */
native get_user_stats(index,stats[8],bodyhits[8]);

/* Gets round stats of player. */
native get_user_rstats(index,stats[8],bodyhits[8]);

/* Gets stats with which user have killed/hurt his victim. If victim is 0
* then stats are from all victims. If victim has not been hurt, function
* returns 0 in other case 1. User stats are reset on his respawn. */
native get_user_vstats(index,victim,stats[8],bodyhits[8],wpnname[]="",len=0);

/* Gets stats with which user have been killed/hurt. If killer is 0
* then stats are from all attacks. If killer has not hurt user, function
* returns 0 in other case 1. User stats are reset on his respawn. */
native get_user_astats(index,wpnindex,stats[8],bodyhits[8],wpnname[]="",len=0);

/* Resets life, weapon, victims and attackers user stats. */
native reset_user_wstats(index);

/* Gets overall stats which stored in stats.dat file in amx folder
* and updated on every mapchange or user disconnect.
* Function returns next index of stats entry or 0 if no more exists. */
native get_stats(index,stats[8],bodyhits[8],name[],len,authid[] = "",authidlen = 0);

/* Returns number of all entries in stats. */
native get_statsnum();

/*
* new stats:
* 0 - total defusions
* 1 - bomb defused
* 2 - bomb plants
* 3 - bomb explosions
*/
native get_user_stats2(index,stats[4]);
native get_stats2(index,stats[4],authid[] = "",authidlen = 0);
// vim: set ts=4 sw=4 tw=99 noet:
//
// AMX Mod X, based on AMX Mod by Aleksander Naszko ("OLO").
// Copyright (C) The AMX Mod X Development Team.
//
// This software is licensed under the GNU General Public License, version 3 or higher.
// Additional exceptions apply. For full license details, see LICENSE.txt or visit:
//     https://alliedmods.net/amxmodx-license

//
// Counter-Strike Functions
//

#if defined _cstrike_included
  #endinput
#endif
#define _cstrike_included

#if AMXX_VERSION_NUM >= 175
 #pragma reqlib cstrike
 #if !defined AMXMODX_NOAUTOLOAD
  #pragma loadlib cstrike
 #endif
#else
 #pragma library cstrike
#endif

/* Returns player deaths.
 */
native cs_get_user_deaths(index);

/* Sets player deaths.
 */
native cs_set_user_deaths(index, newdeaths);

/* Returns index of entity (does not have to be a player) which hostage is following. 0 is hostage doesn't follow anything.
 * Note: this native does not work on Condition Zero, which has a different hostage AI than CS.
 */
native cs_get_hostage_foll(index);

/* Set hostage to follow entity specified in followedindex. Does not have to be a player. If followedindex is 0 the hostage will stop following.
 * Note: this native does not work on Condition Zero, which has a different hostage AI than CS.
 */
native cs_set_hostage_foll(index, followedindex = 0);

/* Get unique hostage id.
 */
native cs_get_hostage_id(index);

/* Get amount of ammo in backpack on a user for a specific weapon.
 * Look in amxconst.inc for weapon types: CSW_*.
 * Weapons on the same line uses the same ammo type:
 * awm
 * scout, ak, g3
 * para
 * famas, m4a1, aug, sg550, galil, sg552
 * m3, xm
 * usp, ump, mac
 * fiveseven, p90
 * deagle
 * p228
 * glock, mp5, tmp, elites
 * flash
 * he
 * smoke
 */
native cs_get_user_bpammo(index, weapon);

/* Restock/remove ammo in a user's backpack.
 */
native cs_set_user_bpammo(index, weapon, amount);

/* Returns 1 if user has a defuse kit.
 */
native cs_get_user_defuse(index);

/* If defusekit is 1, the user will have a defuse kit.
 * You can specify a different colour for the defuse kit icon showing on hud. Default is the normal green.
 * You can specify an icon. Default is "defuser". Set flash to 1 if you want the icon to flash red.
 */
native cs_set_user_defuse(index, defusekit = 1, r = 0, g = 160, b = 0, icon[] = "defuser", flash = 0);

/* Is user in buyzone? Returns 1 when true, 0 when false.
 */
native cs_get_user_buyzone(index);

/* Returns 1 when user has a primary weapon OR a shield in inventory, else 0.
 */
native cs_get_user_hasprim(index);

/* Get user model.
 */
native cs_get_user_model(index, model[], len);

/* Set user model.
 */
native cs_set_user_model(index, const model[]);

/* Use to reset model to standard selected model.
 */
native cs_reset_user_model(index);

/* Returns users money.
 */
native cs_get_user_money(index);

/* Gives money to user. If flash is 1, the difference between new and old amount will flash red or green.
 */
native cs_set_user_money(index, money, flash = 1);

/* Does user have night vision goggles?
 */
native cs_get_user_nvg(index);

/* Set nvgoggles to 1 to give night vision goggles to index. Set it to 0 to remove them.
 */
native cs_set_user_nvg(index, nvgoggles = 1);

/* Returns 1 if user has the "skill" to plant bomb, else 0. Normally this would only be true for a terrorist carrying a bomb.
 */
native cs_get_user_plant(index);

/* If plant is 1, a user will be set to be able to plant bomb within the usual bomb target areas if having one.
 * You should use this if you give a player a weapon_c4, or he won't be able to plant it
 * without dropping it and picking it up again (only possible for terrorists).
 * If showbombicon is 1, the green C4 icon will be shown on user hud (if plant "skill" was enabled).
 */
native cs_set_user_plant(index, plant = 1, showbombicon = 1);

/* Set user team without killing player.
 * If model is anything other than CS_DONTCHANGE, that will be set as player's model.
 */
enum CsInternalModel {
	CS_DONTCHANGE = 0,
	CS_CT_URBAN = 1,
	CS_T_TERROR = 2,
	CS_T_LEET = 3,
	CS_T_ARCTIC = 4,
	CS_CT_GSG9 = 5,
	CS_CT_GIGN = 6,
	CS_CT_SAS = 7,
	CS_T_GUERILLA = 8,
	CS_CT_VIP = 9,
	CZ_T_MILITIA = 10,
	CZ_CT_SPETSNAZ = 11
};
native cs_set_user_team(index, {CsTeams,_}:team, {CsInternalModel,_}:model = CS_DONTCHANGE);

/* Get team directly from player's entity.
 * 1 = terrorist
 * 2 = counter-terrorist
 * 3 = spectator
 */
enum CsTeams {
	CS_TEAM_UNASSIGNED = 0,
	CS_TEAM_T = 1,
	CS_TEAM_CT = 2,
	CS_TEAM_SPECTATOR = 3
};
native CsTeams:cs_get_user_team(index, &{CsInternalModel,_}:model = CS_DONTCHANGE);

/* Is user vip? Returns 1 if true, 0 if false.
 */
native cs_get_user_vip(index);

/* If vip = 1, user is set to vip.
 * If model = 1, then user's model will be changed to VIP model or random CT model if vip = 0.
 * If scoreboard = 1, then scoreboard will be updated to show that user is VIP.
 * This shouldn't be used for players on teams other than CT.
 * NOTE:	this is mostly useful for unsetting vips, so they can change teams and/or buy items properly.
 * It does not alter game play; the one being VIP at start of round will retain internal status as VIP; terrorists
 * can terminate him and accomplish their objective, etc.
 */
 native cs_set_user_vip(index, vip = 1, model = 1, scoreboard = 1);

/* Returns 1 of specified user has tk:ed (team killed).
 */
native cs_get_user_tked(index);

/* Returns 1 of specified user has TKed (team killed).
 * tk = 1: player has TKed
 * tk = 0: player hasn't TKed
 * Set subtract to how many frags to subtract. Set subtract to negative value to add frags.
 */
native cs_set_user_tked(index, tk = 1, subtract = 1);

/* Returns different values depending on if user is driving a vehicle - and if so at what speed.
 * 0: no driving
 * 1: driving, but standing still
 * 2-4: driving, different positive speeds
 * 5: driving, negative speed (backing)
 * Note: these values were tested quickly, they may differ.
 */
native cs_get_user_driving(index);

/* Returns 1 if user has a shield, else 0.
 */
native cs_get_user_shield(index);

/* Returns 1 if user is using a stationary gun, else 0.
 */
native cs_get_user_stationary(index);

/* Returns armor value and sets by reference the armor type in second parameter.
 */
enum CsArmorType {
	CS_ARMOR_NONE = 0, // no armor
	CS_ARMOR_KEVLAR = 1, // armor
	CS_ARMOR_VESTHELM = 2 // armor and helmet
};
native cs_get_user_armor(index, &CsArmorType:armortype);

/* Use this instead of fun's set_user_armor.
 * Appropriate message to update client's HUD will be sent if armortype is kevlar or vesthelm.
 */
native cs_set_user_armor(index, armorvalue, CsArmorType:armortype);

/* Returns 1 if specified weapon is in burst mode.
 */
native cs_get_weapon_burst(index);

/* If burstmode = 1, weapon will be changed to burst mode, 0 and non-burst mode (semiautomatic/automatic) will be activated.
 * Only GLOCK and FAMAS can enter/leave burst mode.
 */
native cs_set_weapon_burst(index, burstmode = 1);

/* Returns 1 if weapon is silenced, else 0.
 */
native cs_get_weapon_silen(index);

/* If silence = 1, weapon will be silenced, 0 and silencer will be removed. Only USP and M4A1 can be silenced.
 */
native cs_set_weapon_silen(index, silence = 1, draw_animation = 1);

/* Returns amount of ammo in weapon's clip.
 */
native cs_get_weapon_ammo(index);

/* Set amount of ammo in weapon's clip.
 */
native cs_set_weapon_ammo(index, newammo);

/* Get weapon type. Corresponds to CSW_* in amxconst.inc: 1 is CSW_P228, 2 is CSW_SCOUT and so on...
 */
native cs_get_weapon_id(index);

/* Returns 1 if no knives mode is enabled, else 0.
 */
native cs_get_no_knives();

/* Enabled no knives mode by calling this with value 1. Disabled with 0.
 * No knives mode means that player will not be given a knife when spawning.
 * You can still give knives (ie through fun's give_item).
 */
native cs_set_no_knives(noknives = 0);

/* Spawns a Counter-Strike player
 */
native cs_user_spawn(player);

/* Get what weapon type (CSW_*) an armoury_entity is.
 */
native cs_get_armoury_type(index);

/* Set an armoury_entity to be of specified type. You will have to set the appropriate model.
 * The second argument, type, should be a CSW_* constant. Not all weapons are supported by Counter-strike.
 * Supported weapons/items: CSW_MP5NAVY, CSW_TMP, CSW_P90, CSW_MAC10, CSW_AK47, CSW_SG552, CSW_M4A1, CSW_AUG, CSW_SCOUT
 * CSW_G3SG1, CSW_AWP, CSW_M3, CSW_XM1014, CSW_M249, CSW_FLASHBANG, CSW_HEGRENADE, CSW_VEST, CSW_VESTHELM, CSW_SMOKEGRENADE
 */
native cs_set_armoury_type(index, type);

#define CS_MAPZONE_BUY 			(1<<0)
#define CS_MAPZONE_BOMBTARGET 		(1<<1)
#define CS_MAPZONE_HOSTAGE_RESCUE 	(1<<2)
#define CS_MAPZONE_ESCAPE		(1<<3)
#define CS_MAPZONE_VIP_SAFETY 		(1<<4)

/* Returns in bitwise form if the user is in a specific map zone.
 * NOTE: If user can't plant (cs_get_user_plant(index) is 0) then cs_get_user_mapzones(index) & CS_MAPZONE_BOMBTARGET will return 0 too.
 */
native cs_get_user_mapzones(index);

/* Zoom type enum. Used for get/set_user_zoom() natives.
 */
enum
{
	CS_RESET_ZOOM = 0,		// Reset any zoom blocking (when using this type, mode has no effect)
	CS_SET_NO_ZOOM,			// Disable any sort of zoom (ie: to disable zoom in all weapons use this with mode=0)
	CS_SET_FIRST_ZOOM,		// Set first zoom (awp style) 
	CS_SET_SECOND_ZOOM,		// Set second zoom (awp style)
	CS_SET_AUGSG552_ZOOM,		// Set aug/sg552 zoom style
};
/* Sets a weapon zoom type on a player, any zoom type will work for all weapons, so you can even set an awp zoom to pistols :D
 * The 2nd param has to be one of the above zoom types in the enum. Mode can only be 0 or 1.
 * If mode=0 (blocking mode), the user will be forced to use the zoom type set by the native, and wont be able to change it (even by changing weapon)
 * until the native resets the zoom with CS_RESET_ZOOM.
 * If mode=1 the user will be able to restore back to a normal view by changing weapon.
 */
native cs_set_user_zoom(index, type, mode);

/* Returns how a user is zooming during the native call. Values correspond to the above enum, but will return 0 if an error occurred.
 */
native cs_get_user_zoom(index);

/* Returns the submodel setting of the player.
 * If this is 1, then the user has a backpack or defuser on their model (depending on team)
 */
native cs_get_user_submodel(index);

/* Sets the submodel setting of the player.
 * If this is 1, then the user has a backpack or defuser on their model (depending on team)
 * 0 removes it.
 */
native cs_set_user_submodel(index, value);

/* Gets or sets the user's last activity time.  This is the time that CS's internal afk kicker
 * checks to see who has been afk too long.
 */
native Float:cs_get_user_lastactivity(index);

native cs_set_user_lastactivity(index, Float:value);

/* Gets or sets the number of hostages that a user has killed.
 */
native cs_get_user_hostagekills(index);

native cs_set_user_hostagekills(index, value);

/* Gets or sets the time that the hostage was last used.
 */
native Float:cs_get_hostage_lastuse(index);

native cs_set_hostage_lastuse(index, Float:value);

/* Gets or sets the time which the hostage can next be used.
 */
native Float:cs_get_hostage_nextuse(index);

native cs_set_hostage_nextuse(index, Float:value);

/* Gets or sets the time in which the C4 will explode.
 */
native Float:cs_get_c4_explode_time(index);

native cs_set_c4_explode_time(index, Float:value);

/* Gets or sets whether the C4 is being defused.
 */
native bool:cs_get_c4_defusing(c4index);

native cs_set_c4_defusing(c4index, bool:defusing);

/**
 * Called when CS internally fires a command to a player.  It does this for a few 
 * functions, most notably rebuy/autobuy functionality.  This is also used to pass
 * commands to CZ bots internally.
 *
 * @param id			Client index.
 * @param cmd			Command string.
 * @return				PLUGIN_HANDLED to block, PLUGIN_CONTINUE for normal operation.
 */
forward CS_InternalCommand(id, const cmd[]);


/**
 * The following constants are used with CS_OnBuy[Attempt] forwards.
 */
#define CSI_P228				CSW_P228
#define CSI_SCOUT				CSW_SCOUT
#define CSI_HEGRENADE			CSW_HEGRENADE
#define CSI_XM1014				CSW_XM1014
#define CSI_C4					CSW_C4
#define CSI_MAC10				CSW_MAC10
#define CSI_AUG					CSW_AUG
#define CSI_SMOKEGRENADE		CSW_SMOKEGRENADE
#define CSI_ELITE				CSW_ELITE
#define CSI_FIVESEVEN			CSW_FIVESEVEN
#define CSI_UMP45				CSW_UMP45
#define CSI_SG550				CSW_SG550
#define CSI_GALIL				CSW_GALIL
#define CSI_FAMAS				CSW_FAMAS
#define CSI_USP					CSW_USP
#define CSI_GLOCK18				CSW_GLOCK18
#define CSI_AWP					CSW_AWP
#define CSI_MP5NAVY				CSW_MP5NAVY
#define CSI_M249				CSW_M249
#define CSI_M3					CSW_M3
#define CSI_M4A1				CSW_M4A1
#define CSI_TMP					CSW_TMP
#define CSI_G3SG1				CSW_G3SG1
#define CSI_FLASHBANG			CSW_FLASHBANG
#define CSI_DEAGLE				CSW_DEAGLE
#define CSI_SG552				CSW_SG552
#define CSI_AK47				CSW_AK47
#define CSI_P90					CSW_P90
#define CSI_SHIELDGUN			CSW_SHIELDGUN
#define CSI_VEST				CSW_VEST		// Custom
#define CSI_VESTHELM			CSW_VESTHELM	// Custom
#define CSI_DEFUSER				33				// Custom
#define CSI_NVGS				34				// Custom
#define CSI_PRIAMMO				36				// Custom
#define CSI_SECAMMO				37				// Custom

/**
 * Called when a player attempts to purchase an item.
 * This is ususally called right away on buy commands issued by a player.
 * 
 * @note Return PLUGIN_CONTINUE to allow the purchase or return a higher action to deny.
 *
 * @param index			Player index.
 * @param item			Item index, see CSI_* constants.
 */
forward CS_OnBuyAttempt(index, item);

/**
 * Called when a player purchases an item.
 * This usually called right before a player gets the purchased item.
 *
 * @note Return PLUGIN_CONTINUE to allow the purchase or return a higher action to deny.
 *
 * @param index			Player index.
 * @param item			Item index, see CSI_* constants.
 */
forward CS_OnBuy(index, item);
// vim: set ts=4 sw=4 tw=99 noet:
//
// AMX Mod X, based on AMX Mod by Aleksander Naszko ("OLO").
// Copyright (C) The AMX Mod X Development Team.
//
// This software is licensed under the GNU General Public License, version 3 or higher.
// Additional exceptions apply. For full license details, see LICENSE.txt or visit:
//     https://alliedmods.net/amxmodx-license

//
// CSX Functions
//

#if defined _csx_included
  #endinput
#endif
#define _csx_included

#include <csstats>

#if AMXX_VERSION_NUM >= 175
 #pragma reqclass xstats
 #if !defined AMXMODX_NOAUTOLOAD
  #pragma defclasslib xstats csx
 #endif
#else
 #pragma library csx
#endif

/*
 * Forwards
 */

/* Function is called after player to player attacks ,
* if players were damaged by teammate TA is set to 1 */
forward client_damage(attacker,victim,damage,wpnindex,hitplace,TA);

/* Function is called after player death ,
* if player was killed by teammate TK is set to 1 */
forward client_death(killer,victim,wpnindex,hitplace,TK);

forward grenade_throw( index,greindex,wId );

forward bomb_planting(planter);
forward bomb_planted(planter);
forward bomb_explode(planter,defuser);
forward bomb_defusing(defuser);
forward bomb_defused(defuser);

/************* Shared Natives Start ********************************/

/* Custom Weapon Support */
/* function will return index of new weapon */
native custom_weapon_add( const wpnname[],melee = 0,const logname[]="" ); 
/* Function will pass damage done by this custom weapon to stats module and other plugins */
native custom_weapon_dmg( weapon, att, vic, damage, hitplace=0 ); 
/* Function will pass info about custom weapon shot to stats module */
native custom_weapon_shot( weapon,index ); // weapon id , player id

/* function will return 1 if true */
native xmod_is_melee_wpn(wpnindex);

/* Returns weapon name. */
native xmod_get_wpnname(wpnindex,name[],len);

/* Returns weapon logname. */
native xmod_get_wpnlogname(wpnindex,name[],len);

/* Returns weapons array size */
native xmod_get_maxweapons();

/* Returns stats array size */
native xmod_get_stats_size();

/************* Shared Natives End ********************************/

enum MapObjective
{
	MapObjective_Bomb	 = (1<<0),
	MapObjective_Hostage = (1<<1),
	MapObjective_Vip	 = (1<<2),
	MapObjective_Escape  = (1<<3),
};

/**
 * Gets current map objectives.
 *
 * @return 		Returns a bits sum if objectives are found, otherwise 0. 
 * 				See MapObjective_* constants.
 */
native MapObjective:get_map_objectives();
// vim: set ts=4 sw=4 tw=99 noet:
//
// AMX Mod X, based on AMX Mod by Aleksander Naszko ("OLO").
// Copyright (C) The AMX Mod X Development Team.
//
// This software is licensed under the GNU General Public License, version 3 or higher.
// Additional exceptions apply. For full license details, see LICENSE.txt or visit:
//     https://alliedmods.net/amxmodx-license

#if defined _datapack_included
	#endinput
#endif
#define _datapack_included	

/**
 * DataPacks are a way to store and move around various types of data in AMX Mod X Scripting. 
 * Since some things are not possible in AMX Mod X, such as a function consuming a String, 
 * DataPacks help us get these Strings and other items where they need to go.
 */

enum DataPack
{
	Invalid_DataPack = 0
};

/**
 * Creates a new data pack.
 *
 * @return			A Handle to the data pack.
 */
native DataPack:CreateDataPack();

/**
 * Packs a normal cell into a data pack.
 *
 * @param pack		Handle to the data pack.
 * @param cell		Cell to add.
 * @noreturn
 * @error			Invalid handle.
 */
native WritePackCell(DataPack:pack, any:cell);

/**
 * Packs a float into a data pack.
 *
 * @param pack		Handle to the data pack.
 * @param val		Float to add.
 * @noreturn
 * @error			Invalid handle.
 */
native WritePackFloat(DataPack:pack, Float:val);

/**
 * Packs a string into a data pack.
 *
 * @param pack		Handle to the data pack.
 * @param str		String to add.
 * @return			Length of copied string.
 * @error			Invalid handle.
 */
native WritePackString(DataPack:pack, const str[]);

/**
 * Reads a cell from a data pack.
 *
 * @param pack		Handle to the data pack.
 * @return			Cell value.
 * @error			Invalid handle, or bounds error.
 */
native any:ReadPackCell(DataPack:pack);

/**
 * Reads a float from a data pack.
 *
 * @param pack		Handle to the data pack.
 * @return			Float value.
 * @error			Invalid handle, or bounds error.
 */
native Float:ReadPackFloat(DataPack:pack);

/**
 * Reads a string from a data pack.
 *
 * @param pack		Handle to the data pack.
 * @param buffer	Destination string buffer.
 * @param maxlen	Maximum length of output string buffer.
 * @return			Length of output string.
 * @error			Invalid handle, or bounds error.
 */
native ReadPackString(DataPack:pack, buffer[], maxlen);

/**
 * Resets the position in a data pack.
 *
 * @param pack		Handle to the data pack.
 * @param clear		If true, clears the contained data.
 * @noreturn
 * @error			Invalid handle.
 */
native ResetPack(DataPack:pack, bool:clear=false);

/**
 * Returns the read or write position in a data pack.
 *
 * @param pack		Handle to the data pack.
 * @return			Numerical position in the data pack.
 * @error			Invalid handle.
 */
native GetPackPosition(DataPack:pack);

/**
 * Sets the read/write position in a data pack.
 *
 * @param pack		Handle to the data pack.
 * @param position	New position to set.
 * @noreturn
 * @error			Invalid handle, or position is beyond the pack bounds.
 */
native SetPackPosition(DataPack:pack, position);

/**
 * Returns whether or not a specified number of bytes from the data pack
 *  position to the end can be read.
 *
 * @param pack		Handle to the data pack.
 * @param bytes		Number of bytes to simulate reading.
 * @return			True if can be read, false otherwise.
 * @error			Invalid handle.
 */
native bool:IsPackReadable(DataPack:pack, bytes);

/**
 * Disposes of a data pack.
 *
 * @param pack		Handle to the data pack.
 * @return			True if disposed, false otherwise.
 */
native DestroyDataPack(&DataPack:pack);
// vim: set ts=4 sw=4 tw=99 noet:
//
// AMX Mod X, based on AMX Mod by Aleksander Naszko ("OLO").
// Copyright (C) The AMX Mod X Development Team.
//
// This software is licensed under the GNU General Public License, version 3 or higher.
// Additional exceptions apply. For full license details, see LICENSE.txt or visit:
//     https://alliedmods.net/amxmodx-license

//
// SQL Database API
//

//
// Notes - Read the comments! Make sure your plugins use
//  nice ANSI SQL and don't use database column names like "key"
//  otherwise this API will be a nightmare
// 
// Never do error checking with the not operator! This is bad:
//   if (!dbi_query())
// You should do:
//   ret = dbi_query()
//   if (ret < 0)
// This is because DBI functions can and will return negative numbers
// Negative numbers evaluate to "true" in AMX.
//

#if defined _dbi_included
  #endinput
#endif
#define _dbi_included

// You can't include SQLX first!
// there's really no reason to anyway.
#assert !defined _sqlx_included

#if AMXX_VERSION_NUM >= 175
 #pragma reqclass dbi
#else
 #pragma library dbi
#endif

enum Sql
{
	SQL_FAILED=0,
	SQL_OK
};

enum Result
{
	RESULT_FAILED=-1,
	RESULT_NONE,
	RESULT_OK
};

/* This will return a number equal to or below 0 on failure.
 * If it does fail, the error will be mirrored in dbi_error()
 * The return value will otherwise be a resource handle, not an
 * OK code or cell pointer.
 */
native Sql:dbi_connect(_host[], _user[], _pass[], _dbname[], _error[]="", _maxlength=0);

/* This will do a simple query execution on the SQL server.
 * If it fails, it will return a number BELOW ZERO (0)
 * If zero, it succeeded with NO RETURN RESULT.
 * If greater than zero, make sure to call dbi_free_result() on it!
 *  The return is a handle to the result set
 */
native Result:dbi_query(Sql:_sql, _query[], any:...);

/* Has the same usage as dbi_query, but this native returns by
 * reference the number of rows affected in the query. If the
 * query fails rows will be equal to -1.
 */
native Result:dbi_query2(Sql:_sql, &rows, _query[], any:...);

/* Returns 0 on failure or End of Results.
 * Advances result pointer by one row.
 */
native dbi_nextrow(Result:_result);

/* Gets a field by number.  Returns 0 on failure.
 * Although internally fields always start from 0, 
 * This function takes fieldnum starting from 1.
 * No extra params: returns int
 * One extra param: returns Float: byref
 * Two extra param: Stores string with length
 */
native dbi_field(Result:_result, _fieldnum, {Float,_}:... );

/* Gets a field by name.  Returns 0 on failure.
 * One extra param: returns Float: byref
 * Two extra param: Stores string with length
 */
native dbi_result(Result:_result, _field[], {Float,_}:... );

/* Returns the number of rows returned from a query
 */
native dbi_num_rows(Result:_result);

/* Frees memory used by a result handle.  Do this or get memory leaks.
 */
native dbi_free_result(&Result:result);

/* Closes a database handle.  Internally, it will also 
 * mark the handle as free, so this particular handle may
 * be re-used in the future to save time.
 */
native dbi_close(&Sql:_sql);

/* Returns an error message set.  For PGSQL and MySQL,
 * this is a direct error return from the database handle/API.
 * For MSSQL, it returns the last error message found from a 
 * thrown exception.
 */
native dbi_error(Sql:_sql, _error[], _len);

/* Returns the type of database being used.  So far:
 * "mysql", "pgsql", "mssql", "sqlite"
 */
native dbi_type(_type[], _len);

/* Returns the number of fields/colums in a result set.
 * Unlike dbi_nextrow, you must pass a valid result handle.
 */
native dbi_num_fields(Result:result);

/* Retrieves the name of a field/column in a result set.
 * Requires a valid result handle, and columns are numbered 1 to n.
 */
native dbi_field_name(Result:result, field, name[], maxLength);

/* This function can be used to find out if a table in a Sqlite database exists.
 */
stock bool:sqlite_table_exists(Sql:sql, table[]) 
{
	new bool:exists;
	new query[128];
	format(query, 127, "SELECT name FROM sqlite_master WHERE type='table' AND name='%s' LIMIT 1;", table);

	new Result:result = dbi_query(sql, query);

	if (dbi_nextrow(result))
	{
		exists = true;
	}
	else
	{
		exists = false;
	}

	if (result > RESULT_NONE)
	{
		dbi_free_result(result);
	}

	return exists;
}
// vim: set ts=4 sw=4 tw=99 noet:
//
// AMX Mod X, based on AMX Mod by Aleksander Naszko ("OLO").
// Copyright (C) The AMX Mod X Development Team.
//
// This software is licensed under the GNU General Public License, version 3 or higher.
// Additional exceptions apply. For full license details, see LICENSE.txt or visit:
//     https://alliedmods.net/amxmodx-license

#if defined _dodconst_included
  #endinput
#endif
#define _dodconst_included

/* DoD teams */
#define ALLIES			1
#define AXIS 			2

#define FT_NEW			1<<0
#define FT_OLD			1<<1

#define STAMINA_SET		0
#define STAMINA_RESET		1

#define FUSE_SET		0
#define FUSE_RESET		1

#define DODMAX_WEAPONS		46 // 5 slots for custom weapons

// DoD Weapon Types
enum
{
	DODWT_PRIMARY = 0,
	DODWT_SECONDARY,
	DODWT_MELEE,
	DODWT_GRENADE, 
	DODWT_OTHER
};

// Ammo Channels
#define AMMO_SMG 1 		// thompson, greasegun, sten, mp40
#define AMMO_ALTRIFLE 2 	// carbine, k43, mg34
#define AMMO_RIFLE 3 		// garand, enfield, scoped enfield, k98, scoped k98
#define AMMO_PISTOL 4 		// colt, webley, luger
#define AMMO_SPRING 5 		// springfield
#define AMMO_HEAVY 6 		// bar, bren, stg44, fg42, scoped fg42
#define AMMO_MG42 7    		// mg42
#define AMMO_30CAL 8 		// 30cal
#define AMMO_GREN 9 		// grenades (should be all 3 types)
#define AMMO_ROCKET 13 		// bazooka, piat, panzerschreck
enum { 
	PS_NOPRONE =0,
	PS_PRONE,
	PS_PRONEDEPLOY,
	PS_DEPLOY,
};

/* info types for dod_get_map_info native */
enum {
	MI_ALLIES_TEAM = 0,
	MI_ALLIES_PARAS,
	MI_AXIS_PARAS,
};

/* DoD weapons */
enum {
	DODW_AMERKNIFE = 1,
	DODW_GERKNIFE,
	DODW_COLT,
	DODW_LUGER,
	DODW_GARAND,
	DODW_SCOPED_KAR,
	DODW_THOMPSON,
	DODW_STG44,
	DODW_SPRINGFIELD,
	DODW_KAR,
	DODW_BAR,
	DODW_MP40,
	DODW_HANDGRENADE,
	DODW_STICKGRENADE,
	DODW_STICKGRENADE_EX,
	DODW_HANDGRENADE_EX,
	DODW_MG42,
	DODW_30_CAL,
	DODW_SPADE,
	DODW_M1_CARBINE,
	DODW_MG34,
	DODW_GREASEGUN,
	DODW_FG42,
	DODW_K43,
	DODW_ENFIELD,
	DODW_STEN,
	DODW_BREN,
	DODW_WEBLEY,
	DODW_BAZOOKA,
	DODW_PANZERSCHRECK,
	DODW_PIAT,
	DODW_SCOPED_FG42,
	DODW_FOLDING_CARBINE,
	DODW_KAR_BAYONET,
	DODW_SCOPED_ENFIELD,
	DODW_MILLS_BOMB,
	DODW_BRITKNIFE,
	DODW_GARAND_BUTT,
	DODW_ENFIELD_BAYONET,
	DODW_MORTAR,
	DODW_K43_BUTT,
};

/* DoD Classes */
enum {
	DODC_GARAND = 1,
	DODC_CARBINE,
	DODC_THOMPSON, 
	DODC_GREASE, 
	DODC_SNIPER, 
	DODC_BAR, 
	DODC_30CAL, 
	DODC_BAZOOKA, 
	//DODC_ALLIES_MORTAR,
	DODC_KAR = 10, 
	DODC_K43, 
	DODC_MP40, 
	DODC_MP44, 
	DODC_SCHARFSCHUTZE, 
	DODC_FG42, 
	DODC_SCOPED_FG42, 
	DODC_MG34, 
	DODC_MG42, 
	DODC_PANZERJAGER, 
	//DODC_AXIS_MORTAR,
	DODC_ENFIELD = 21, 
	DODC_STEN, 
	DODC_MARKSMAN, 
	DODC_BREN, 
	DODC_PIAT, 
	//DODC_BRIT_MORTAR,
};
// vim: set ts=4 sw=4 tw=99 noet:
//
// AMX Mod X, based on AMX Mod by Aleksander Naszko ("OLO").
// Copyright (C) The AMX Mod X Development Team.
//
// This software is licensed under the GNU General Public License, version 3 or higher.
// Additional exceptions apply. For full license details, see LICENSE.txt or visit:
//     https://alliedmods.net/amxmodx-license

//
// DoD Fun Functions
//

#if defined _dodfun_included
  #endinput
#endif
#define _dodfun_included

#include <dodconst>

#if AMXX_VERSION_NUM >= 175
 #pragma reqlib dodfun
 #if !defined AMXMODX_NOAUTOLOAD
  #pragma loadlib dodfun
 #endif
#else
 #pragma library dodfun
#endif

/* Function is called after grenade throw */
forward grenade_throw(index,greindex,wId);

/* Function is called after a rocket is shot */
forward rocket_shoot(index,rocketindex,wId);

/* Example: for full stamina use dod_player_stamina(1,STAMINA_SET,100,100) */
/* value is from 0 - 100 */
native dod_set_stamina(index,set=STAMINA_SET,minvalue=0,maxvalue=100);

/* Sets fuse for grenades. Valid number is from 0.1-20.0 */
/* types : new or preprimed */
native dod_set_fuse(index,set=FUSE_SET,Float:newFuse=5.0, Type=FT_NEW);

/* Sets player class */
native dod_set_user_class(index,classId);

/* Sets player team and random class. Don't work for spectators. */
native dod_set_user_team(index,teamId,refresh=1);

/* Returns next player class. Usefull is player is using random class */
native dod_get_next_class(index);

/* Returns 1 if player choose random class */
native dod_is_randomclass(index);

/* Returns player deaths */
native dod_get_pl_deaths(index);

/* Sets player deaths. 
 * Note if you opt to refresh the scoreboard, it
 * will make the player appear as "DEAD" in the scoreboard.
 */
native dod_set_pl_deaths(index,value,refresh=1);

/* Returns player deaths. */
native dod_get_user_kills(index);

/* Sets player kills. */
native dod_set_user_kills(index,value,refresh=1);

/* Sets player score. */
native dod_set_user_score(index,value,refresh=1);

/* Sets new team name for this player */
native dod_set_pl_teamname(index,const szName[]);

/* Gets player team name */
native dod_get_pl_teamname(index,szName[],len);

/* Returns 1 is player weapon is deployed (bar,mg..) */
native dod_is_deployed(index);

/*Sets the ammo of the specified weapon entity id */
native dod_set_user_ammo(index,wid,value);

/*Gets the ammo of the specified weapon entity id */
native dod_get_user_ammo(index,wid);

/* called after first InitObj */
forward controlpoints_init();

enum CP_VALUE {
	CP_edict = 1,		// read only
	CP_area,			// read only
	CP_index,			// read only
	CP_owner,
	CP_default_owner,
	CP_visible,			// reinit after change
	CP_icon_neutral,		// reinit after change
	CP_icon_allies,		// reinit after change
	CP_icon_axis,		// reinit after change
	CP_origin_x,		// reinit after change
	CP_origin_y,		// reinit after change
	
	CP_can_touch,
	CP_pointvalue,

	CP_points_for_cap,
	CP_team_points,

	CP_model_body_neutral,
	CP_model_body_allies,
	CP_model_body_axis,

	// strings
	CP_name,
	CP_reset_capsound,
	CP_allies_capsound,
	CP_axis_capsound,
	CP_targetname,

	CP_model_neutral,
	CP_model_allies,
	CP_model_axis,
};

/* returns number of objectives */
native objectives_get_num();

/* use this function to update client(s) hud. You need to do this sometimes. Check CP_VALUE comments.
   if player is 0 , all clients will get this message */
native objectives_reinit( player=0 );

/* use this function to get info about specified control point */
native objective_get_data( index, CP_VALUE:key, szValue[]="", len=0 );

/* use this function to change control point's data */
native objective_set_data( index, CP_VALUE:key , iValue=-1, const szValue[]="" );

enum CA_VALUE {
	CA_edict = 1,
	CA_allies_numcap,
	CA_axis_numcap,
	CA_timetocap,
	CA_can_cap,

	// strings
	CA_target,
	CA_sprite,
};

/* use this function to get info about specified control point's area */
native area_get_data( index, CA_VALUE:key, szValue[]="", len=0 );

/* use this function to change control point's area data */
native area_set_data( index, CA_VALUE:key , iValue=-1, const szValue[]="" );
// vim: set ts=4 sw=4 tw=99 noet:
//
// AMX Mod X, based on AMX Mod by Aleksander Naszko ("OLO").
// Copyright (C) The AMX Mod X Development Team.
//
// This software is licensed under the GNU General Public License, version 3 or higher.
// Additional exceptions apply. For full license details, see LICENSE.txt or visit:
//     https://alliedmods.net/amxmodx-license

//
// DODX Stats Functions
//

#if defined _dodstats_included
  #endinput
#endif
#define _dodstats_included

/* Gets stats from given weapon index. If wpnindex is 0
* then the stats are from all weapons. If weapon has not been used function
* returns 0 in other case 1. Fields in stats are:
* 0 - kills
* 1 - deaths
* 2 - headshots
* 3 - teamkilling
* 4 - shots
* 5 - hits
* 6 - damage
* 7 - score
* For body hits fields see amxconst.inc. */
native get_user_wstats(index,wpnindex,stats[9],bodyhits[8]);

/* Gets round stats from given weapon index.*/
native get_user_wrstats(index,wpnindex,stats[9],bodyhits[8]);

/* Gets life (from spawn to spawn) stats from given weapon index.*/
native get_user_wlstats(index,wpnindex,stats[9],bodyhits[8]);

/* Gets overall stats which are stored in file on server
* and updated on every respawn or user disconnect.
* Function returns the position in stats by diff. kills to deaths. */
native get_user_stats(index,stats[9],bodyhits[8]);

/* Gets round stats of player. */
native get_user_rstats(index,stats[9],bodyhits[8]);

/* Gets life (from spawn to spawn) stats of player. */
native get_user_lstats(index,stats[9],bodyhits[8]);

/* Gets stats with which user have killed/hurt his victim. If victim is 0
* then stats are from all victims. If victim has not been hurt, function
* returns 0 in other case 1. User stats are reset on his respawn. */
native get_user_vstats(index,victim,stats[9],bodyhits[8],wpnname[]="",len=0);

/* Gets stats with which user have been killed/hurt. If killer is 0
* then stats are from all attacks. If killer has not hurt user, function
* returns 0 in other case 1. User stats are reset on his respawn. */
native get_user_astats(index,wpnindex,stats[9],bodyhits[8],wpnname[]="",len=0);

/* Resets life, weapon, victims and attackers user stats. */
native reset_user_wstats(index);

/* Gets overall stats which stored in stats.dat file in amx folder
* and updated on every mapchange or user disconnect.
* Function returns next index of stats entry or 0 if no more exists. */
native get_stats(index,stats[9],bodyhits[8],name[],len);

/* Returns number of all entries in stats. */
native get_statsnum();
// vim: set ts=4 sw=4 tw=99 noet:
//
// AMX Mod X, based on AMX Mod by Aleksander Naszko ("OLO").
// Copyright (C) The AMX Mod X Development Team.
//
// This software is licensed under the GNU General Public License, version 3 or higher.
// Additional exceptions apply. For full license details, see LICENSE.txt or visit:
//     https://alliedmods.net/amxmodx-license

//
// DODX Functions
//

#if defined _dodx_included
  #endinput
#endif
#define _dodx_included

#include <dodconst>
#include <dodstats>

#if AMXX_VERSION_NUM >= 175
 #pragma reqclass xstats
 #if !defined AMXMODX_NOAUTOLOAD
  #pragma defclasslib xstats dodx
 #endif
#else
 #pragma library dodx
#endif

/************* Shared Natives Start ********************************/

/* Forward types */
enum {
  XMF_DAMAGE = 0,
  XMF_DEATH,
  XMF_SCORE,
};

/* Use this function to register forwards */
native register_statsfwd(ftype);

/* Function is called after player to player attacks ,
* if players were damaged by teammate TA is set to 1 */
forward client_damage(attacker, victim, damage, wpnindex, hitplace, TA);

/* Function is called after player death ,
* if player was killed by teammate TK is set to 1 */
forward client_death(killer, victim, wpnindex, hitplace, TK);

/* Function is called if player scored  */
forward client_score(id, score, total);

/* This Forward is called when a player changes team */
forward dod_client_changeteam(id, team, oldteam);

/* This Forward is called if a player changes class, but just after spawn */
forward dod_client_changeclass(id, class, oldclass);

/* This Forward is called when a player spawns */
forward dod_client_spawn(id);

/* This will be called whenever a player scopes or unscopes
value = 1 scope up
value = 0 scope down */
forward dod_client_scope(id, value);

/* This will be called whenever a player drops a weapon 
weapon is weapon dropped or picked up 
value = 1 picked up
value = 0 dropped */
forward dod_client_weaponpickup(id, weapon, value);

/* Called whenever the the player goes to or comes from prone position 
value = 1 going down
value = 0 getting up */
forward dod_client_prone(id, value);

/* This will be called whenever a player switches a weapon */
forward dod_client_weaponswitch(id, wpnew, wpnold);

/* Forward for when a grenade explodes and its location */
forward dod_grenade_explosion(id, Float:pos[3], wpnid);

/* Forward for when a rocket explodes and its location */
forward dod_rocket_explosion(id, Float:pos[3], wpnid);

/* Forward for when a player picks up a object */
forward dod_client_objectpickup(id, objid, Float:pos[3], value);

/* Forward for when a users stamina decreases */
forward dod_client_stamina(id, stamina);

/* We want to get just the weapon of whichever type that the player is on him 
Use DODWT_* in dodconst.inc for type */
native dod_weapon_type(id, type);

/* This native will change the position of a weapon within the users slots and its ammo ammount */
native dod_set_weaponlist(id, wpnID, slot, dropslot, totalrds);

/* Sets the model for a player */
native dod_set_model(id, const model[]);

/* Sets the model for a player */
native dod_set_body_number(id, bodynumber);

/* Un-Sets the model for a player */
native dod_clear_model(id);

/* Custom Weapon Support */
/* function will return index of new weapon */
native custom_weapon_add( const wpnname[], melee = 0, const logname[]="" ); 

/* Function will pass damage done by this custom weapon to stats module and other plugins */
native custom_weapon_dmg( weapon, att, vic, damage, hitplace=0 ); 

/* Function will pass info about custom weapon shot to stats module */
native custom_weapon_shot( weapon, index ); // weapon id , player id

/* function will return 1 if true */
native xmod_is_melee_wpn(wpnindex);

/* Returns weapon name. */
native xmod_get_wpnname(wpnindex, name[], len);

/* Returns weapon logname. */
native xmod_get_wpnlogname(wpnindex, name[], len);

/* Returns weapons array size */
native xmod_get_maxweapons();

/* Returns stats array size ex. 8 in TS , 9 in DoD */
native xmod_get_stats_size();

/* Returns 1 if true */
native xmod_is_custom_wpn(wpnindex);

/************* Shared Natives End ********************************/

/* weapon logname to weapon name convertion */
native dod_wpnlog_to_name(const logname[],name[],len);

/* weapon logname to weapon index convertion */
native dod_wpnlog_to_id(const logname[]);

native dod_get_map_info( info );

/* Returns id of currently carried weapon. Gets also 
* ammount of ammo in clip and backpack. */
native dod_get_user_weapon(index,&clip=0,&ammo=0);

/* Returns team score */
native dod_get_team_score(teamId);

/* Returns player class id */
native dod_get_user_class(index);

/* Returns player score */
native dod_get_user_score(index);

/* values are: 0-no prone, 1-prone, 2-prone + w_deploy */
native dod_get_pronestate(index);

/* It is not as safe as original but player deaths will not be increased */
native dod_user_kill(index);
// vim: set ts=4 sw=4 tw=99 noet:
//
// AMX Mod X, based on AMX Mod by Aleksander Naszko ("OLO").
// Copyright (C) The AMX Mod X Development Team.
// Special thanks to Vexd and mahnsawce.
//
// This software is licensed under the GNU General Public License, version 3 or higher.
// Additional exceptions apply. For full license details, see LICENSE.txt or visit:
//     https://alliedmods.net/amxmodx-license

//
// Engine Functions
//

#if defined _engine_included
  #endinput
#endif
#define _engine_included

#include <engine_const>

#if AMXX_VERSION_NUM >= 175
 #pragma reqlib engine
 #if !defined AMXMODX_NOAUTOLOAD
  #pragma loadlib engine
 #endif
#else
 #pragma library engine
#endif

native traceresult(type,any:...);

/* Registers a client impulse to a function.  Function is passed the ID of the user. */
native register_impulse(impulse, const function[]);

/* Registers a touch action to a function by classnames.  Use * to specify any classname. */
native register_touch(const Touched[], const Toucher[], const function[]);

/* Registers a think action to a function by classname. */
native register_think(const Classname[], const function[]);

/* NOTE: In old engine versions, this was not the case.  Values are now WINDOWS values.
 * You must pass with the windows offset (e.g. if 230 on windows, pass 230 no matter what) 
 * The module will automatically add +5 for Linux.
 */

/* Precaches an event. */
native precache_event(type, const Name[], any:...);

/* set/get a user's speak flags */
native set_speak(iIndex, iSpeakFlags);
native get_speak(iIndex);

/* Drops an entity to the floor (work?) */
native drop_to_floor(entity);

/* Get whole buffer containing keys and their data. */
native get_info_keybuffer(id, buffer[], length);

/* Use an entity with another entity. "entUsed" could be a hostage, "entUser" a player. */
native force_use(entUsed, entUser);

/* Get globals from server. */
native Float:get_global_float(variable);
native get_global_int(variable);
native get_global_string(variable, string[], maxlen);
native get_global_vector(variable, Float:vector[3]);
native get_global_edict(variable);

/* Set entity bounds. */
native entity_set_size(index, const Float:mins[3], const Float:maxs[3]);

/* Get decal index */
native get_decal_index(const szDecalName[]);

/* Returns the distance between two entities. */
native Float:entity_range(ida,idb);

/* Sets/gets things in an entities Entvars Struct. */
native entity_get_int(iIndex, iKey);
native entity_set_int(iIndex, iKey, iVal);
native Float:entity_get_float(iIndex, iKey);
native entity_set_float(iIndex, iKey, Float:iVal);
native entity_get_vector(iIndex, iKey, Float:vRetVector[3]);
native entity_set_vector(iIndex, iKey, const Float:vNewVector[3]);
native entity_get_edict(iIndex, iKey);
native entity_set_edict(iIndex, iKey, iNewIndex);
native entity_get_string(iIndex, iKey, szReturn[], iRetLen);
native entity_set_string(iIndex, iKey, const szNewVal[]);
native entity_get_byte(iIndex, iKey);
native entity_set_byte(iIndex, iKey, iVal);

/* Creates an entity, will return the index of the created entity. ClassName must be valid. */
native create_entity(const szClassname[]);

/* Finds an entity in the world, will return 0 if nothing is found */
native find_ent_by_class(iIndex, const szClass[]);
//optionally you can set a jghg2 type
// 1: target, 2:targetname, 0:classname (default)
native find_ent_by_owner(iIndex, const szClass[], iOwner, iJghgType=0);
native find_ent_by_target(iIndex, const szClass[]);
native find_ent_by_tname(iIndex, const szClass[]);
native find_ent_by_model(iIndex, const szClass[], const szModel[]);
native find_ent_in_sphere(start_from_ent, const Float:origin[3], Float:radius);

//this will CBaseEntity::Think() or something from the entity
native call_think(entity);

/* Is entity valid? */
native is_valid_ent(iIndex);

/* Proper origin setting, keeps updated with Half-Life engine. */
native entity_set_origin(iIndex, const Float:fNewOrigin[3]);

/* Sets the model of an Entity. */
native entity_set_model(iIndex, const szModel[]);

/* Remove an entity from the world. */
native remove_entity(iIndex);

/* Return current number of entities in the map */
native entity_count();

/* Simulate two entities colliding/touching. */
native fake_touch(entTouched, entToucher);

/* 2 formats.
   Format: DispatchKeyValue("KeyName","Value") - sets keyvalues for the entity specified in the keyvalue() forward.
   Format: DispatchKeyValue(index,"KeyName","Value") - Sets keyvalue for entity not specified in keyvalue() forward. */
native DispatchKeyValue(...);

native get_keyvalue(entity, const szKey[], value[], maxLength);

native copy_keyvalue(szClassName[],sizea,szKeyName[],sizeb,szValue[],sizec);

/* Runs the GameDLL's DispatchSpawn for an entity, I think it's used with DispatchKeyValue. */
native DispatchSpawn(iIndex);

/* Hurts/Kills players in a sphere, like an explosion, Multiplier determines damage. */
native radius_damage(const Float:fExplodeAt[3], iDamageMultiplier, iRadiusMultiplier);

/* Will return the contents of a point (inside map? in sky? outside map? etc.). */
native point_contents(const Float:fCheckAt[3]);

/* Trace a line from Start(X, Y, Z) to End(X, Y, Z), will return the point hit in vReturn[3]
 * and an entity index if an entity is hit. */
native trace_line(iIgnoreEnt, const Float:fStart[3], const Float:fEnd[3], Float:vReturn[3]);

/* Traces a hull. */
native trace_hull(const Float:origin[3],hull,ignoredent=0,ignoremonsters=0);

/* Traces a line, and returns the normal to the plane hit in vReturn.
 * Returns 0 if theres no normal. */
native trace_normal(iIgnoreEnt, const Float:fStart[3], const Float:fEnd[3], Float:vReturn[3]);

/* Gets the ID of a grenade. */
native get_grenade_id(id, model[], len, grenadeid = 0);

/* Gets gpGlobals->time from Half-Life */
native Float:halflife_time();

/* Sets map lighting, #OFF to disable. */
native set_lights(const Lighting[]);

/* Sets Player's View to entity iTargetIndex. */
native attach_view(iIndex, iTargetIndex);

/* Sets Player's View Mode.
 * rpgrocket.mdl must be precached in order for this function to work */
native set_view(iIndex, ViewType);

/* Direct copy of PLAYBACK_EVENT_FULL from Metamod/HLSDK.  If you don't know how that works, you probably shouldn't be using it. */
native playback_event(flags,invoker,eventindex,Float:delay,const Float:origin[3],const Float:angles[3],Float:fparam1,Float:fparam2,iparam1,iparam2,bparam1,bparam2);

/* Gets parameters sent from CmdStart.
   Note that you will receive modified values if any other plugin have
   changed them. */
native get_usercmd(type,any:...);

/* Sets the parameters sent from CmdStart.
   Note that your changes will be seen by any other plugin doing get_usercmd() */
native set_usercmd(type,any:...);

/* Converts a string offset into a real string. Some of the forwards in fakemeta
   uses string offsets. (FM_CreateNamedEntity) */
native eng_get_string(_string, _returnString[], _len);

/* FORWARDS 
 **********/

/* Called when 2 entities touch. 
 * ptr - touched entity
 * ptd - toucher entity
 */
forward pfn_touch(ptr, ptd);

/* Called once every server frame. May cause lag. */
forward server_frame();

/* Called when a client types kill in console. */
forward client_kill(id);

/* Forward for PreThink()/PostThink() on a player. */
forward client_PreThink(id);
forward client_PostThink(id);

/* Forward for impulses. */
forward client_impulse(id, impulse);

/* Forward for CmdStart() on a player. */
forward client_cmdStart(id);

/* Called when an entity "thinks" (DispatchThink) */
forward pfn_think(entid);

/* Called when an event is played */
forward pfn_playbackevent(flags, entid, eventid, Float:delay, Float:Origin[3], Float:Angles[3], Float:fparam1, Float:fparam2, iparam1, iparam2, bparam1, bparam2);

/* Called when an entity gets a keyvalue set on it from the engine (ie: map load)  Use copy_keyvalue to get the keyvalue information */
forward pfn_keyvalue(entid);

/* Called when an entity is spawned */
forward pfn_spawn(entid);

//from jghg2
/* As above, but returns number of ents stored in entlist. Use to find a specific type of entity classname (specify in _lookforclassname) around a
 * certain entity specified in aroundent. All matching ents are stored in entlist. Specify max amount of entities to find in maxents.
 * If aroundent is 0 its origin is not used, but origin in 6th parameter. Ie, do not specify 6th parameter (origin) if you specified an entity
 * in aroundent.
 */
native find_sphere_class(aroundent, const _lookforclassname[], Float:radius, entlist[], maxents, const Float:origin[3] = {0.0, 0.0, 0.0});

/* SDK function - checks if an origin is in an entity's view cone
 * Set use3d to 1 to do the calculation in 3D. Otherwise it will be in 2D.
 */
native is_in_viewcone(entity, const Float:origin[3], use3d = 0);

//SDK function - checks if an entity is visible to an entity
native is_visible(entity, target);

//Added at twistedeuphoria's request, see funcwiki for details
native trace_forward(const Float:start[3], const Float:angle[3], Float:give, ignoreEnt, &Float:hitX, &Float:hitY, &Float:shortestDistance, &Float:shortestDistLow, &Float:shortestDistHigh);

/**
 * Sets rendering of an entity, including player entities.
 * This is basically the same as set_rendering() stock.
 * 
 * @param index		The entity index to apply the render.
 * @param fx		The render effect. See kRenderFx* constants.
 * @param r			The amount of red.
 * @param g			The amount of green.
 * @param b			The amount of blue.
 * @param render	The render mode. See kRender* constants.
 * @param amount	The render thickness generally. It can have others meaning depending effect/mode.
 * @noreturn
 */
native set_ent_rendering(index, fx = kRenderFxNone, r = 0, g = 0, b = 0, render = kRenderNormal, amount = 0);

/**
 * Checks whether two entities intersect by comparing
 * their absolute minimum and maximum coordinates.
 * 
 * @param entity    The first entity index to check.
 * @param other     The second entity index to check.
 *
 * @return          true on success, false otherwise.
 */
native bool:entity_intersects(entity, other);

#include <engine_stocks>
// vim: set ts=4 sw=4 tw=99 noet:
//
// AMX Mod X, based on AMX Mod by Aleksander Naszko ("OLO").
// Copyright (C) The AMX Mod X Development Team.
//
// This software is licensed under the GNU General Public License, version 3 or higher.
// Additional exceptions apply. For full license details, see LICENSE.txt or visit:
//     https://alliedmods.net/amxmodx-license

//
// Engine Constants
//

#if defined _engine_const_included
  #endinput
#endif
#define _engine_const_included

#include <hlsdk_const>

#define SPEAK_NORMAL	0
#define SPEAK_MUTED		1
#define SPEAK_ALL		2
#define SPEAK_LISTENALL	4

#define CAMERA_NONE		0
#define CAMERA_3RDPERSON	1
#define CAMERA_UPLEFT	2
#define CAMERA_TOPDOWN	3

/* Int */
enum {
	EV_INT_gamestate = 0,
	EV_INT_oldbuttons,
	EV_INT_groupinfo,
	EV_INT_iuser1,
	EV_INT_iuser2,
	EV_INT_iuser3,
	EV_INT_iuser4,
	EV_INT_weaponanim,
	EV_INT_pushmsec,
	EV_INT_bInDuck,
	EV_INT_flTimeStepSound,
	EV_INT_flSwimTime,
	EV_INT_flDuckTime,
	EV_INT_iStepLeft,
	EV_INT_movetype,
	EV_INT_solid,
	EV_INT_skin,
	EV_INT_body,
	EV_INT_effects,
	EV_INT_light_level,
	EV_INT_sequence,
	EV_INT_gaitsequence,
	EV_INT_modelindex,
	EV_INT_playerclass,
	EV_INT_waterlevel,
	EV_INT_watertype,
	EV_INT_spawnflags,
	EV_INT_flags,
	EV_INT_colormap,
	EV_INT_team,
	EV_INT_fixangle,
	EV_INT_weapons,
	EV_INT_rendermode,
	EV_INT_renderfx,
	EV_INT_button,
	EV_INT_impulse,
	EV_INT_deadflag,
};

/* Float */
enum {
	EV_FL_impacttime = 0,
	EV_FL_starttime,
	EV_FL_idealpitch,
	EV_FL_pitch_speed,
	EV_FL_ideal_yaw,
	EV_FL_yaw_speed,
	EV_FL_ltime,
	EV_FL_nextthink,
	EV_FL_gravity,
	EV_FL_friction,
	EV_FL_frame,
	EV_FL_animtime,
	EV_FL_framerate,
	EV_FL_health,
	EV_FL_frags,
	EV_FL_takedamage,
	EV_FL_max_health,
	EV_FL_teleport_time,
	EV_FL_armortype,
	EV_FL_armorvalue,
	EV_FL_dmg_take,
	EV_FL_dmg_save,
	EV_FL_dmg,
	EV_FL_dmgtime,
	EV_FL_speed,
	EV_FL_air_finished,
	EV_FL_pain_finished,
	EV_FL_radsuit_finished,
	EV_FL_scale,
	EV_FL_renderamt,
	EV_FL_maxspeed,
	EV_FL_fov,
	EV_FL_flFallVelocity,
	EV_FL_fuser1,
	EV_FL_fuser2,
	EV_FL_fuser3,
	EV_FL_fuser4,
};

/* Vector */
enum {
	EV_VEC_origin = 0,
	EV_VEC_oldorigin,
	EV_VEC_velocity,
	EV_VEC_basevelocity,
	EV_VEC_clbasevelocity,
	EV_VEC_movedir,
	EV_VEC_angles,
	EV_VEC_avelocity,
	EV_VEC_punchangle,
	EV_VEC_v_angle,
	EV_VEC_endpos,
	EV_VEC_startpos,
	EV_VEC_absmin,
	EV_VEC_absmax,
	EV_VEC_mins,
	EV_VEC_maxs,
	EV_VEC_size,
	EV_VEC_rendercolor,
	EV_VEC_view_ofs,
	EV_VEC_vuser1,
	EV_VEC_vuser2,
	EV_VEC_vuser3,
	EV_VEC_vuser4,
};

/* Edict */
enum {
	EV_ENT_chain = 0,
	EV_ENT_dmg_inflictor,
	EV_ENT_enemy,
	EV_ENT_aiment,
	EV_ENT_owner,
	EV_ENT_groundentity,
	EV_ENT_pContainingEntity,
	EV_ENT_euser1,
	EV_ENT_euser2,
	EV_ENT_euser3,
	EV_ENT_euser4,
};

/* String */
enum {
	EV_SZ_classname = 0,
	EV_SZ_globalname,
	EV_SZ_model,
	EV_SZ_target,
	EV_SZ_targetname,
	EV_SZ_netname,
	EV_SZ_message,
	EV_SZ_noise,
	EV_SZ_noise1,
	EV_SZ_noise2,
	EV_SZ_noise3,
	EV_SZ_viewmodel,
	EV_SZ_weaponmodel,
};

/* Byte */
enum {
	EV_BYTE_controller1 = 0,
	EV_BYTE_controller2,
	EV_BYTE_controller3,
	EV_BYTE_controller4,
	EV_BYTE_blending1,
	EV_BYTE_blending2,
};

#if defined _jghg_enums
  #endinput
#endif
#define _jghg_enums
enum {
    // Edict
    GL_trace_ent = 0,

    // Float
    GL_coop,
    GL_deathmatch,
    GL_force_retouch,
    GL_found_secrets,
    GL_frametime,
    GL_serverflags,
    GL_teamplay,
    GL_time,
    GL_trace_allsolid,
    GL_trace_fraction,
    GL_trace_inopen,
    GL_trace_inwater,
    GL_trace_plane_dist,
    GL_trace_startsolid,

    // Int
    GL_cdAudioTrack,
    GL_maxClients,
    GL_maxEntities,
    GL_msg_entity,
    GL_trace_flags,
    GL_trace_hitgroup,

    // String
    GL_pStringBase,
    GL_mapname,
    GL_startspot,

    // Vector
    GL_trace_endpos,
    GL_trace_plane_normal,
    GL_v_forward,
    GL_v_right,
    GL_v_up,
    GL_vecLandmarkOffset,

    // Void (not supported)
    GL_pSaveData
};

enum
{
	usercmd_float_start,
	usercmd_forwardmove,	// Float
	usercmd_sidemove,		// Float
	usercmd_upmove,		// Float
	usercmd_float_end,
	usercmd_int_start,
	usercmd_lerp_msec,		// short
	usercmd_msec,			// byte
	usercmd_lightlevel,		// byte
	usercmd_buttons,		// unsigned short
	usercmd_impulse,		// byte
	usercmd_weaponselect,	// byte
	usercmd_impact_index,	// int
	usercmd_int_end,
	usercmd_vec_start,
	usercmd_viewangles,		// Vector
	usercmd_impact_position,	// vec
	usercmd_vec_end
};

// Used by the traceresult() native.
enum
{
	TR_AllSolid,			// (int) if true, plane is not valid
	TR_StartSolid,		// (int) if true, the initial point was in a solid area
	TR_InOpen,		// (int)
	TR_InWater,	// (int)
	TR_Fraction,			// (float) time completed, 1.0 = didn't hit anything
	TR_EndPos,			// (vector) final position
	TR_PlaneDist,		// (float)
	TR_PlaneNormal,		// (vector) surface normal at impact
	TR_Hit,				// (entity) entity the surface is on
	TR_Hitgroup			// (int) 0 == generic, non zero is specific body part
};

// vim: set ts=4 sw=4 tw=99 noet:
//
// AMX Mod X, based on AMX Mod by Aleksander Naszko ("OLO").
// Copyright (C) The AMX Mod X Development Team.
// Special thanks to AssKicR, Freecode, and T(+)rget.
//
// This software is licensed under the GNU General Public License, version 3 or higher.
// Additional exceptions apply. For full license details, see LICENSE.txt or visit:
//     https://alliedmods.net/amxmodx-license

//
// Engine Stocks
//

#if defined _engine_stocks_included
  #endinput
#endif
#define _engine_stocks_included

#if !defined _amxmodx_included
  #include <amxmodx>
#endif

#if !defined _engine_included
  #include <engine>
#endif

stock fakedamage(idvictim,const szClassname[],Float:takedmgdamage,damagetype)
{
	new entity = create_entity("trigger_hurt");
	if (entity)
	{
		DispatchKeyValue(entity,"classname","trigger_hurt");
		new szDamage[16];
		// Takedamages only do half damage per attack (damage is damage per second, and it's triggered in 0.5 second intervals).
		// Compensate for that.
		format(szDamage,15,"%f",takedmgdamage * 2);
		DispatchKeyValue(entity,"dmg",szDamage);
		format(szDamage,15,"%i",damagetype);
		DispatchKeyValue(entity,"damagetype",szDamage);
		DispatchKeyValue(entity,"origin","8192 8192 8192");
		DispatchSpawn(entity);
		entity_set_string(entity, EV_SZ_classname, szClassname);
		fake_touch(entity,idvictim);
		remove_entity(entity);
		return 1;
	}
	return 0;
}

//wrapper for find_ent_by_class
stock find_ent(iStart, const szClassname[])
{
	return find_ent_by_class(iStart, szClassname);
}

/* Get the Button(s) user is pressing */
stock get_user_button(id)
{
	return entity_get_int(id, EV_INT_button);
}

stock get_user_oldbutton(id)
{
	return entity_get_int(id, EV_INT_oldbuttons);
}

/* Get flags an entity is flagged with */
stock get_entity_flags(ent)
{
	return entity_get_int(ent, EV_INT_flags);
}

/* Get the distance between two entities */
stock get_entity_distance(ent1, ent2)
{
	return floatround(entity_range(ent1, ent2));
}

/* Get grenade thrown by this user */
stock get_grenade(id)
{
	new iGrenade = find_ent_by_class(-1, "grenade");
	while(iGrenade > 0)
	{
		if(entity_get_edict(iGrenade, EV_ENT_owner) == id)
			return iGrenade;

		iGrenade = find_ent_by_class(iGrenade, "grenade");
	}

	return 0;
}

/* Get origin of a brush entity */
stock get_brush_entity_origin(ent, Float:orig[3])
{
	new Float:Min[3], Float:Max[3];

	entity_get_vector(ent, EV_VEC_origin, orig);
	entity_get_vector(ent, EV_VEC_mins, Min);
	entity_get_vector(ent, EV_VEC_maxs, Max);
	
	orig[0] += (Min[0] + Max[0]) * 0.5;
	orig[1] += (Min[1] + Max[1]) * 0.5;
	orig[2] += (Min[2] + Max[2]) * 0.5;

	return 1;
}

/* Remove entity by name */
stock remove_entity_name(const eName[])
{
	new iEntity = find_ent_by_class(-1, eName);
	while (iEntity > 0)
	{
		remove_entity(iEntity);
		iEntity = find_ent_by_class(-1, eName);
	}

	return 1;
}

/* Get the contents of the point a user is aiming at */
stock ViewContents(id)
{
	new origin[3], Float:Orig[3];
	get_user_origin(id, origin, 3);
	Orig[0] = float(origin[0]);
	Orig[1] = float(origin[1]);
	Orig[2] = float(origin[2]);

	return point_contents(Orig);
}

stock get_speed(ent)
{
	new Float:Vel[3];
	entity_get_vector(ent, EV_VEC_velocity, Vel);

	return floatround(vector_length(Vel));
}

/*  Set rendering of an entity */
stock set_rendering(index, fx=kRenderFxNone, r=255, g=255, b=255, render=kRenderNormal, amount=16)
{
	entity_set_int(index,EV_INT_renderfx,fx);
	new Float:RenderColor[3];
	RenderColor[0] = float(r);
	RenderColor[1] = float(g);
	RenderColor[2] = float(b);
	entity_set_vector(index,EV_VEC_rendercolor,RenderColor);
	entity_set_int(index,EV_INT_rendermode,render);
	entity_set_float(index,EV_FL_renderamt,float(amount));

	return 1;
}

/* Set flags on an entity */
stock set_entity_flags(ent,flag,onoff)
{
	if ((entity_get_int(ent,EV_INT_flags)&flag) > 0)
	{
		if (onoff == 1)
		{
			return 2;
		}
		else
		{
			entity_set_int(ent,EV_INT_flags,entity_get_int(ent,EV_INT_flags)-flag);
			return 1;
		}
	}
	else
	{
		if (onoff == 0)
		{
			return 2;
		}
		else
		{
			entity_set_int(ent,EV_INT_flags,entity_get_int(ent,EV_INT_flags)+flag);
			return 1;
		}
	}

	return 0;
}

/* If visible = 1, entity will be set to be visible, else invisible. */
stock set_entity_visibility(entity, visible = 1) 
{
	entity_set_int(entity, EV_INT_effects, visible == 1 ? entity_get_int(entity, EV_INT_effects) & ~EF_NODRAW : entity_get_int(entity, EV_INT_effects) | EF_NODRAW);

	return 1;
}

/* Returns 1 if entity is visible. */
stock get_entity_visibility(entity) 
{
	return !(entity_get_int(entity, EV_INT_effects) & EF_NODRAW);
}

stock set_user_velocity(entity, const Float:vec[3])
{
	return entity_set_vector(entity, EV_VEC_velocity, vec);
}

stock get_user_velocity(entity, Float:vec[3])
{
	return entity_get_vector(entity, EV_VEC_velocity, vec);
}

/* Backwards compatible */
/* Hurts/Kills players in a sphere, like an explosion, Multiplier determines damage. */
stock RadiusDamage(const Float:fExplodeAt[3], iDamageMultiplier, iRadiusMultiplier) 
{
	return radius_damage(fExplodeAt, iDamageMultiplier, iRadiusMultiplier);
}
/* Gives you a velocity in the direction a player is looking, iVelocity is the multiplier. */
stock VelocityByAim(iIndex,iVelocity, Float:vRetValue[3]) 
{
	return velocity_by_aim(iIndex,iVelocity,vRetValue);
}
/* Will return the contents of a point (inside map? in sky? outside map? etc.). */
stock PointContents(const Float:fCheckAt[3]) 
{
	return point_contents(fCheckAt);
}

stock set_size(index, const Float:mins[3], const Float:maxs[3]) 
{
	return entity_set_size(index,mins,maxs);
}

//by Twilight Suzuka, request addition at29428
//"Lifted from HLSDK"
stock IsInWorld( ent )
{
   new Float:origin[3];
   entity_get_vector(ent,EV_VEC_origin,origin);

   if (origin[0] >= 4096.0) return 0;
   if (origin[1] >= 4096.0) return 0;
   if (origin[2] >= 4096.0) return 0;
   if (origin[0] <= -4096.0) return 0;
   if (origin[1] <= -4096.0) return 0;
   if (origin[2] <= -4096.0) return 0;

   new Float:velocity[3];
   entity_get_vector(ent,EV_VEC_velocity,velocity);

   if (velocity[0] >= 2000) return 0;
   if (velocity[1] >= 2000) return 0;
   if (velocity[2] >= 2000) return 0;
   if (velocity[0] <= -2000) return 0;
   if (velocity[1] <= -2000) return 0;
   if (velocity[2] <= -2000) return 0;

   return 1;
}
/***********************************************

[ Corona-Bytes.NET ] EvolutionX Core Plugin

	(c) Corona - Bytes .NET coders :: coders@corona-bytes.net
	
		> 2005 Corona Bytes :: http://www.corona-bytes.net

***********************************************/

#if defined __EVOLUTION_CORE__
  #endinput
#endif
#define __EVOLUTION_CORE__

#pragma library EvolutionXCore

native setClientPL 				( Client, PowerLevel );
native getClientPL 				( Client );
native setClientACPL 			( Client, ActualPowerLevel );
native getClientACPL 			( Client );
native setClientADPL 			( Client, AfterDeathPowerLevel );
native getClientADPL 			( Client );
native setClientSPL 			( Client, PowerLevel );
native setClientPLtoADPL 		( Client );

native setClientKI 				( Client, Ki );
native getClientKI 				( Client );

native setClientHP 				( Client, Health );
native getClientHP 				( Client );
native setClientMHP	 			( Client, MaximumHealth );
native getClientMHP 			( Client );

native setClientSPEED 			( Client, Speed );
native getClientSPEED 			( Client );
native setClientSWOOPSPEED 		( Client, SwoopSpeed );
native getClientSWOOPSPEED 		( Client );

native setClientPROTECT 		( Client, bool:Enable = true );
native getClientPROTECT 		( Client );

native setClientFROZEN 			( Client, bool:Enable = true );
native getClientFROZEN 			( Client );

native setClientGOD 			( Client, bool:Enable = true );
native getClientGOD 			( Client );

native getClientFLY 			( Client );

native setClientHiddenTURBO 	( Client, bool:Enable = true );
native getClientTURBO 			( Client );

native getClientBLOCK 			( Client );

native setClientHiddenPOWERUP 	( Client, bool:Enable = true );
native getClientPOWERUP 		( Client );

native getClientSWOOPING 		( Client );
native getClientATKSHOOT 		( Client );
native getClientATKCHARGE 		( Client );
native getClientMELEE 			( Client );
native getClientTHROWAWAY 		( Client );
native getClientTHROW	 		( Client );
native getClientWALLGND			( Client );
native getClientINFREEFALL		( Client );
native getClientBEAMJUMP		( Client );

// kills a player without score/death msg
native silentClientKILL			( Client );// vim: set ts=4 sw=4 tw=99 noet:
//
// AMX Mod X, based on AMX Mod by Aleksander Naszko ("OLO").
// Copyright (C) The AMX Mod X Development Team.
// Based on stocks and information provided by LynX.
//
// This software is licensed under the GNU General Public License, version 3 or higher.
// Additional exceptions apply. For full license details, see LICENSE.txt or visit:
//     https://alliedmods.net/amxmodx-license
 
#if defined _esfconst_included
  #endinput
#endif
#define _esfconst_included

enum 
{
	Character_Buu = 1,		
	Character_Goku = 2,
	Character_Gohan = 3,	//my favorite :)
	Character_Krillin = 4,
	Character_Frieza = 5,
	Character_Piccolo = 6,
	Character_Trunks = 7,
	Character_Vegeta = 8,
	Character_Cell = 9,
};

enum
{
	Explosion_Blue = 0,
	Explosion_Green,
	Explosion_Orange,
	Explosion_Purple,
	Explosion_Yellow,
	Explosion_Red,
	Explosion_White,
	Explosions_Total,
};

enum
{
	Attack_Kamehameha=1,
	Attack_SpiritBomb,
	Attack_GalletGun,
	Attack_FinalFlash,
	Attack_Renzoku,
	Attack_Kametorpedo,
	Attack_GenericBeam,
	Attack_Throw,
};

enum
{
	Direction_Left=1,
	Direction_Right,
	Direction_Up,
	Direction_Down,
	Direction_Forward,
	Direction_Backward,
};

enum 
{
	Recovery_Kicked=1,
	Recovery_Tumbled,
	Recovery_Lying,
	Recovery_Thrown,
};

#define ESF_CHARGING		1
#define ESF_CONTROLLING		2
#define ESF_SHOOTING		3
#define ESF_SHOT			4
// vim: set ts=4 sw=4 tw=99 noet:
//
// AMX Mod X, based on AMX Mod by Aleksander Naszko ("OLO").
// Copyright (C) The AMX Mod X Development Team.
//
// This software is licensed under the GNU General Public License, version 3 or higher.
// Additional exceptions apply. For full license details, see LICENSE.txt or visit:
//     https://alliedmods.net/amxmodx-license

//
// Fakemeta Functions
//

#if defined _fakemeta_included
	#endinput
#endif
#define _fakemeta_included

#include <fakemeta_const> 

#if AMXX_VERSION_NUM >= 175
 #pragma reqlib fakemeta
 #if !defined AMXMODX_NOAUTOLOAD
  #pragma loadlib fakemeta
 #endif
#else
 #pragma library fakemeta
#endif

/**
 * Returns entvar data from an entity.  Use the pev_* enum (in fakemeta_const.inc) to specify which data you want retrieved.
 *
 * @note	This function uses "read_data" style data syntax.  It returns integer values,
 *				by-references float data, and sets a buffer for string data.
 *
 * @note	If retrieving strings, you may optionally get a pointer into the global string table. Depending on
 * 			your situation, there are two ways to do this.
 * 			1: This simply gets the pointer.
 * 			   new ptr = pev(entid, pev_classname)
 * 			2: The pointer will be stored in ptr AND the actual string is retrieved.
 * 			   new ptr, classname[32]
 * 			   pev(entid, pev_classname, ptr, classname, 31)
 *
 * @param	_index		The entity index to lookup.
 * @param	_value		The pev field to lookup (look in fakemeta_const.inc)
 */
native pev(_index,_value,any:...);

/**
 * Sets entvar data for an entity.  Use the pev_* enum from fakemeta_const.inc for reference.
 *
 * @note	Setting string data will automatically allocate a new string (via AllocString)
 *			If you have a string already allocated with your own call to AllocString, use
 *			set_pev_string_ptr instead.
 *
 * @param	_index		The entity index to set the value on.
 * @param	_value		The pev field to set, (look in fakemeta_const.inc)
 */
native set_pev(_index,_value,any:...);

/**
 * Use this native to set a pev field to a string that is already allocated (via a function such
 * as EngFunc_AllocString).
 *
 * @note	If you specify _value as anything other than string fields, an error will be thrown.
 * @note	Pass 0 as the _string field to set it to an empty string.
 *
 * @param	_index		The entity index to set the value on.
 * @param	_value		The pev field to set - MUST be a string field.
 * @param	_string		The string handle, retrieved from places like AllocString.
 */
native set_pev_string(_index, _value, _string);


/**
 * Checks the validity of an entity.
 *
 * @param entindex		The entity id to check.
 *
 * @return 			0 on invalid entity
 *						1 on entity is valid
 *						2 on entity is valid and it has private data (safe to use pdata natives on).
 */
native pev_valid(entindex);

/**
 * Returns the serial number for each entity.  The serial number is a unique identity 
 * generated when an entity is created.
 * 
 * @param	entindex	The entity id.
 *
 * @return				The serial number for the entity.
 */
native pev_serial(entindex);

/* Returns any global variable inside globalvars_t structure. Use the glb_* enum.
 *
 * When returning data from glb_pStringBase (the global string table), you may give a pointer into that table
 * in order to get different strings.
 * Example:
 * new model[128]
 * new ptr = pev(id, pev_viewmodel)
 * global_get(glb_pStringBase, ptr, model, 127)
 */
native global_get(_value, any:...);

/**
 * Returns a integer from an entity's private data.
 *
 * _linuxdiff value is what to add to the _Offset for linux servers.
 * _macdiff value is what to add to the _Offset for os x servers.
 * 
 * A log error is thrown on invalid _index and _Offset.
 * 
 * @param _index        Entity index.
 * @param _Offset       Offset to search.
 * @param _linuxdiff    Linux difference.
 * @param _macdiff      Mac OS X difference.
 * @return              An integer value is returned.
 */
native get_pdata_int(_index, _Offset, _linuxdiff = 5, _macdiff = 5);

/**
 * Sets an integer to an entity's private data.
 *
 * _linuxdiff value is what to add to the _Offset for linux servers.
 * _macdiff value is what to add to the _Offset for os x servers.
 * 
 * A log error is thrown on invalid _index and _Offset.
 * 
 * @param _index        Entity index.
 * @param _Offset       Offset to search.
 * @param _Value        Value to set.
 * @param _linuxdiff    Linux difference.
 * @param _macdiff      Mac OS X difference.
 * @return              1 on success.
 */
native set_pdata_int(_index, _Offset, _Value, _linuxdiff = 5, _macdiff = 5);

/**
 * Returns a float from an entity's private data.
 *
 * _linuxdiff value is what to add to the _Offset for linux servers.
 * _macdiff value is what to add to the _Offset for os x servers.
 * 
 * A log error is thrown on invalid _index and _Offset.
 * 
 * @param _index        Entity index.
 * @param _Offset       Offset to search.
 * @param _linuxdiff    Linux difference.
 * @param _macdiff      Mac OS X difference.
 * @return              An float value is returned.
 */
native Float:get_pdata_float(_index, _Offset, _linuxdiff = 5, _macdiff = 5);

/**
 * Sets a float to an entity's private data.
 *
 * _linuxdiff value is what to add to the _Offset for linux servers.
 * _macdiff value is what to add to the _Offset for os x servers.
 * 
 * A log error is thrown on invalid _index and _Offset.
 * 
 * @param _index        Entity index.
 * @param _Offset       Offset to search.
 * @param _Value        Value to set.
 * @param _linuxdiff    Linux difference.
 * @param _macdiff      Mac OS X difference.
 * @return              1 on success.
 */
native set_pdata_float(_index, _Offset, Float:_Value, _linuxdiff = 5, _macdiff = 5);

/**
 * Tries to retrieve an edict pointer from an entity's private data.
 *
 * This function is byte-addressable.  Unlike get_pdata_int() which searches in byte increments of 4, 
 * get_pdata_ent searches in increments of 1.
 *
 * _linuxdiff value is what to add to the _offset for linux servers.
 * _macdiff value is what to add to the _offset for os x servers.
 *
 * A log error is thrown on invalid _index and _Offset.
 * 
 * @param _index		Entity index.
 * @param _offset		Offset to search.
 * @param _linuxdiff	Linux difference.
 * @param _macdiff		Mac OS X difference.
 * @return				-2 if an invalid entity was found.
 *						-1 if an empty entity was found.
 * 						Otherwise, an entity index is returned.
 */
native get_pdata_ent(_index, _offset, _linuxdiff = 20, _macdiff = 20);

/**
 * Sets an edict pointer to an entity's private data.
 *
 * This function is byte-addressable.  Unlike set_pdata_int() which searches in byte increments of 4, 
 * set_pdata_ent searches in increments of 1.
 *
 * _linuxdiff value is what to add to the _offset for linux servers.
 * _macdiff value is what to add to the _offset for os x servers.
 * 
 * A log error is thrown on invalid _index and _offset.
 * 
 * @param _index        Entity index.
 * @param _offset       Offset to search.
 * @param _value        Value to set.
 * @param _linuxdiff    Linux difference.
 * @param _macdiff      Mac OS X difference.
 * @return              1 on success.           
 */
native set_pdata_ent(_index, _offset, _value, _linuxdiff = 20, _macdiff = 20);

/**
 * Returns a boolean from an entity's private data.
 *
 * This function is byte-addressable. Unlike get_pdata_int() which searches in byte increments of 4, 
 * get_pdata_bool searches in increments of 1.
 *
 * _linuxdiff value is what to add to the _offset for linux servers.
 * _macdiff value is what to add to the _offset for os x servers.
 * 
 * A log error is thrown on invalid _index and _offset.
 * 
 * @param _index        Entity index.
 * @param _offset       Offset to search.
 * @param _linuxdiff    Linux difference.
 * @param _macdiff      Mac OS X difference.
 * @return              An boolean value is returned.
 */
native bool:get_pdata_bool(_index, _offset, _linuxdiff = 20, _macdiff = 20);

/**
 * Sets a boolean to an entity's private data.
 *
 * This function is byte-addressable. Unlike set_pdata_int() which searches in byte increments of 4, 
 * set_pdata_bool searches in increments of 1.
 * 
 * _linuxdiff value is what to add to the _offset for linux servers.
 * _macdiff value is what to add to the _offset for os x servers.
 *
 * A log error is thrown on invalid _index and _offset.
 * 
 * @param _index        Entity index.
 * @param _offset       Offset to search.
 * @param _value        Value to set.
 * @param _linuxdiff    Linux difference.
 * @param _macdiff      Mac OS X difference.
 * @return              1 on success.
 */
native set_pdata_bool(_index, _offset, bool:_value, _linuxdiff = 20, _macdiff = 20);

/**
 * Returns a byte value from an entity's private data.
 *
 * This function is byte-addressable. Unlike get_pdata_int() which searches in byte increments of 4, 
 * get_pdata_byte searches in increments of 1.
 * 
 * _linuxdiff value is what to add to the _offset for linux servers.
 * _macdiff value is what to add to the _offset for os x servers.
 *
 * A log error is thrown on invalid _index and _offset.
 * 
 * @param _index        Entity index.
 * @param _offset       Offset to search.
 * @param _linuxdiff    Linux difference.
 * @param _macdiff      Mac OS X difference.
 * @return              A byte value is returned.
 */
native get_pdata_byte(_index, _offset, _linuxdiff = 20, _macdiff = 20);

/**
 * Sets a byte value to an entity's private data.
 *
 * This function is byte-addressable. Unlike set_pdata_int() which searches in byte increments of 4, 
 * set_pdata_byte searches in increments of 1.
 *
 * _linuxdiff value is what to add to the _offset for linux servers.
 * _macdiff value is what to add to the _offset for os x servers.
 * 
 * A log error is thrown on invalid _index and _offset.
 * 
 * @param _index        Entity index.
 * @param _offset       Offset to search.
 * @param _value        Value to set.
 * @param _linuxdiff    Linux difference.
 * @param _macdiff      Mac OS X difference.
 * @return              1 on success.
 */
native set_pdata_byte(_index, _offset, _value, _linuxdiff = 20, _macdiff = 20);

/**
 * Returns a short value from an entity's private data.
 *
 * This function is byte-addressable. Unlike get_pdata_int() which searches in byte increments of 4, 
 * get_pdata_short searches in increments of 1.
 * 
 * _linuxdiff value is what to add to the _offset for linux servers.
 * _macdiff value is what to add to the _offset for os x servers.
 *
 * A log error is thrown on invalid _index and _offset.
 * 
 * @param _index        Entity index.
 * @param _offset       Offset to search.
 * @param _linuxdiff    Linux difference.
 * @param _macdiff      Mac OS X difference.
 * @return              A short value is returned.
 */
native get_pdata_short(_index, _offset, _linuxdiff = 20, _macdiff = 20);

/**
 * Sets a short value to an entity's private data.
 *
 * This function is byte-addressable.  Unlike set_pdata_int() which searches in byte increments of 4, 
 * set_pdata_short searches in increments of 1.
 *
 * _linuxdiff value is what to add to the _offset for linux servers.
 * _macdiff value is what to add to the _offset for os x servers.
 * 
 * A log error is thrown on invalid _index and _offset.
 * 
 * @param _index        Entity index.
 * @param _offset       Offset to search.
 * @param _value        Value to set.
 * @param _linuxdiff    Linux difference.
 * @param _macdiff      Mac OS X difference.
 * @return              1 on success.  
 */
native set_pdata_short(_index, _offset, _value, _linuxdiff = 20, _macdiff = 20);

/**
 * Returns a vector from an entity's private data.
 *
 * This function is byte-addressable. Unlike get_pdata_int() which searches in byte increments of 4, 
 * get_pdata_vector searches in increments of 1.
 * 
 * _linuxdiff value is what to add to the _offset for linux servers.
 * _macdiff value is what to add to the _offset for os x servers.
 *
 * A log error is thrown on invalid _index and _offset.
 * 
 * @param _index        Entity index.
 * @param _offset       Offset to search.
 * @param _output       Vector returned by reference.
 * @param _linuxdiff    Linux difference.
 * @param _macdiff      Mac OS X difference.
 * @return              1 on success.     
 */
native get_pdata_vector(_index, _offset, Float:_output[3], _linuxdiff = 20, _macdiff = 20);

/**
 * Sets a vector to an entity's private data.
 *
 * This function is byte-addressable.  Unlike set_pdata_int() which searches in byte increments of 4, 
 * set_pdata_vector searches in increments of 1.
 *
 * _linuxdiff value is what to add to the _offset for linux servers.
 * _macdiff value is what to add to the _offset for os x servers.
 * 
 * A log error is thrown on invalid _index and _Offset.
 * 
 * @param _index        Entity index.
 * @param _offset       Offset to search.
 * @param _origin       Value to set.
 * @param _linuxdiff    Linux difference.
 * @param _macdiff      Mac OS X difference.
 * @return              1 on success.   
 */
native set_pdata_vector(_index, _offset, Float:_origin[3], _linuxdiff = 20, _macdiff = 20);

/**
 * Tries to retrieve an edict (entity encapsulation) pointer from an entity's private data.
 *
 * This function is byte-addressable.  Unlike get_pdata_int() which searches in byte increments of 4, 
 * get_pdata_ehandle searches in increments of 1.
 *
 * _linuxdiff value is what to add to the _offset for linux servers.
 * _macdiff value is what to add to the _offset for os x servers.
 * 
 * A log error is thrown on invalid _index and _offset.
 * 
 * @param _index        Entity index.
 * @param _offset       Offset to search.
 * @param _linuxdiff    Linux difference.
 * @param _macdiff      Mac OS X difference.
 * @return              -2 if an invalid entity was found.
 *                      -1 if an empty entity was found.
 *                      0 if serialnumber is not matching.
 *                      Otherwise, an entity index is returned.
 */
native get_pdata_ehandle(_index, _offset, _linuxdiff = 20, _macdiff = 20);

/**
 * Sets an edict (entity encapsulation) pointer to an entity's private data.
 *
 * This function is byte-addressable.  Unlike set_pdata_int() which searches in byte increments of 4, 
 * set_pdata_ehandle searches in increments of 1.
 *
 * _linuxdiff value is what to add to the _offset for linux servers.
 * _macdiff value is what to add to the _offset for os x servers.
 * 
 * A log error is thrown on invalid _index and _Offset.
 * 
 * @param _index        Entity index.
 * @param _offset       Offset to search.
 * @param _value        Value to set.
 * @param _linuxdiff    Linux difference.
 * @param _macdiff      Mac OS X difference.
 * @return              1 on success.          
 */
native set_pdata_ehandle(_index, _offset, _value, _linuxdiff = 20, _macdiff = 20);

/* Registers a forward.
 * Returns an id you can pass to unregister_forward
 */
native register_forward(_forwardType,const _function[],_post=0);

/* Unregisters a forward.
 * The registerId must be from register_forward, and
 * post/forwardtype must match what you registered the forward as.
 */
native unregister_forward(_forwardType, registerId, post=0);

/* Returns data for metamod */
native forward_return(type,any:...);

/* Returns the original return value of an engine function. 
 * This is only valid in forwards that were registered as post.
 *
 * get_orig_retval() - no params, retrieves integer return value
 * get_orig_retval(&Float:value) - retrieves float return value by reference
 * get_orig_retval(value[], len) - retrives string return value
 */
native get_orig_retval({Float,_}:...);

native engfunc(type,any:...);
native dllfunc(type,any:...);

//only use this with functions that pass a Trace
// get: zero extra params - return int, one extra param = byref float or vector
// set: use anything
native get_tr(TraceResult:tr_member, {Float,_}:...);
native set_tr(TraceResult:tr_member, {Float,_}:...);

//Upgraded version takes in a TraceResult handle, optionally passed in as the last parameter to the
//TraceResult forward.  Use 0 to specify the global traceresult handle set from calling 
// some of the Engfucs.
native get_tr2(tr_handle, {TraceResult,_}:tr_member, {Float,_}:...);
native set_tr2(tr_handle, {TraceResult,_}:tr_member, {Float,_}:...);

/**
 * Creates a traceresult handle.  This value should never be altered.
 * The handle can be used in get/set_tr2 and various traceresult engine functions.
 *
 * NOTE: You must call free_tr2() on every handle made with create_tr2().
 *
 * @return		A new TraceResult handle.
 */
native create_tr2();

/** 
 * Frees a traceresult handle created with free_tr2().  Do not call
 * this more than once per handle, or on handles not created through
 * create_tr2().
 *
 * @param tr_handle	TraceResult handle created via create_tr2().
 * @noreturn
 */
native free_tr2(tr_handle);

//Same as above, use either a kvd_handle or 0 for global reserved kvd data
//kvd_handle is passed by the kvd hook, last param
native get_kvd(kvd_handle, KeyValueData:member, {Float,_}:...);

//Using set_kvd with the handle from the hook for anything under KV_fHandled
// is considered an undefined operation (it could crash).  You should fire a new
// keyvalues structure rather than changing the internal engine strings.
native set_kvd(kvd_handle, KeyValueData:member, {Float,_}:...);

// These functions are used with the clientdata data structure (FM_UpdateClientData)
// Get: 0 extra params - Return integer; 1 extra param - by ref float or vector; 2 extra params - string and length
// Set: Use anything
// Use 0 for cd_handle to specify the global clientdata handle
native get_cd(cd_handle, ClientData:member, {Float,_}:...);
native set_cd(cd_handle, ClientData:member, {Float,_}:...);

// These functions are used with the entity_state data structure (FM_AddToFullPack)
// Get: 0 extra params - Return integer; 1 extra param - by ref float or vector or array
// Set: Use anything
// Use 0 for es_handle to specify the global entity_state handle
native get_es(es_handle, EntityState:member, {Float,_}:...);
native set_es(es_handle, EntityState:member, {Float,_}:...);

// These functions are used with the usercmd data structure (FM_CmdStart)
// Get: 0 extra params - Return integer; 1 extra param - by ref float or vector
// Set: Use anything
// Use 0 for uc_handle to specify the global usercmd handle
native get_uc(uc_handle, UserCmd:member, {Float,_}:...);
native set_uc(uc_handle, UserCmd:member, {Float,_}:...);

//NOTE that for the string offsets below, on AMD64, a byref (char **) offset is NOT the same as an int offset
//In fact it's QWORD aligned rather than DWORD aligned, so the offset will be exactly half.
//Gets a string from a private offset.  If byref is false, the string is treated as static rather than dynamic.
//linux value is what to add to the offset for linux servers.
//mac value is what to add to the offset for os x servers. Default (cellmin) means that linux value will be used.
//this cannot use a default value due to older version using an awkward default value.
native get_pdata_string(entity, offset, dest[], maxlength, byref=1, linux, mac=cellmin);

//Sets a string in a private offset.
//realloc = -1 - nonbyref copy (static
//realloc = 0 - copy byref, no realloc *(char **)
//realloc = 1 - reallocate new string with free+malloc
//realloc = 2 - reallocate new string with delete[]+new[]
//linux value is what to add to the offset for linux servers.
//mac value iswhat to add to the offset for os x servers.
//this cannot use a default value due to older version using an awkward default value.
native set_pdata_string(entity, offset, const source[], realloc=2, linux, mac=cellmin);

// Copies the given infoBuffer pointer into out[]
// An infoBuffer pointer is returned by EngFunc_GetInfoKeyBuffer
native copy_infokey_buffer(infoBuffer, out[], maxlen);


/**
 * Looks up the sequence for the entity.
 *
 * @param entity		The entity id to lookup.
 * @param name			The sequence name to lookup, case insensitive. ("JUMP" would match "jump")
 * @param framerate		The framerate of the sequence, if found.
 * @param loops			Whether or not the sequence loops.
 * @param groundspeed	The groundspeed setting of the sequence.
 * @return				-1 on failed lookup, the sequence number on successful lookup.
 */
native lookup_sequence(entity, const name[], &Float:framerate = 0.0, &bool:loops = false, &Float:groundspeed = 0.0);

/**
 * Sets a bone controller with the specified value.
 *
 * @param entity		The entity id to set the value on.
 * @param controller	Which controller to set (0 through 3).
 * @param value			The value to set it to.
 * @return				The percentage that the controller is extended (0.0 through 1.0)
 */
native Float:set_controller(entity, controller, Float:value);


enum
{
    Model_DefaultSize     = -2,
    Model_CurrentSequence = -1,
};

/**
 * Gets size of the entity models collision box.
 *
 * @param entity        The entity index to use.
 * @param mins          The local negative collision box distance.    
 * @param maxs          The local positive collision box distance.    
 * 
 * @return              1 on success, 0 on faillure.
 * 
 * @error               Invalid entity.
 *                      Invalid model pointer.
 */
native GetModelCollisionBox(entity, Float:mins[3], Float:maxs[3]);

/**
 * Sets entity size to the models collision box.
 *
 * @param entity        The entity index to set the value on.
 * 
 * @return              1 on success, 0 on faillure.
 * 
 * @error               Invalid entity.
 *                      Invalid model pointer.
 */
native SetModelCollisionBox(entity);

/**
 * Gets size of a model bounding box.
 *
 * @param entity        The entity index to use.
 * @param mins          The local negative bounding box distance.    
 * @param maxs          The local positive bounding box distance.     
 * @param sequence      The animation sequence to retrieve.
 *                      Model_DefaultSize retrieves ideal moevement hull size.
 *                      Model_CurrentSequence retrieves hull size of the current sequence.
 *                      Values >= 0 will specify which sequence to retrieve size from.
 * 
 * @return              1 on success, 0 on faillure.
 * 
 * @error               Invalid entity.
 *                      Invalid model pointer.
 */
native GetModelBoundingBox(entity, Float:mins[3], Float:maxs[3], sequence = Model_DefaultSize);

/**
 * Sets size to a model bounding box.
 *
 * @param entity        The entity index to set the value on. 
 * @param sequence      The sequence to apply.
 *                      Model_DefaultSize sets size of ideal movement hull.
 *                      Model_CurrentSequence sets size of the current sequence.
 *                      Values >= 0 will specify which sequence to use.
 * 
 * @return              1 on success, 0 on faillure.
 * 
 * @error               Invalid entity.
 *                      Invalid model pointer.
 */
native SetModelBoundingBox(index, sequence = Model_DefaultSize);
// vim: set ts=4 sw=4 tw=99 noet:
//
// AMX Mod X, based on AMX Mod by Aleksander Naszko ("OLO").
// Copyright (C) The AMX Mod X Development Team.
//
// This software is licensed under the GNU General Public License, version 3 or higher.
// Additional exceptions apply. For full license details, see LICENSE.txt or visit:
//     https://alliedmods.net/amxmodx-license

//
// Fakemeta Constants
//

#if defined _fakemeta_const_included
  #endinput
#endif
#define _fakemeta_const_included

// For forward_return
#define	FMV_STRING		1
#define FMV_FLOAT		2
#define FMV_CELL		3

#include <hlsdk_const>

/* The actual return value of the function, use these instead of PLUGIN_HANDLED etc when
 * returning from registered forwards.
 */
#define FMRES_IGNORED	1	// Calls target function, returns normal value
#define FMRES_HANDLED	2	// Tells metamod you did something, still calls target function and returns normal value
#define FMRES_OVERRIDE	3	// Supposed to still call the target function but return your value instead
							// however this does not work properly with metamod; use supercede instead.
#define FMRES_SUPERCEDE	4	// Block the target call, and use your return value (if applicable)

// Use this with GetInfoKeyBuffer if you want the server's localinfo buffer
#define FM_NULLENT		-1


/* Used with engfunc()
 */
enum {
	EngFunc_PrecacheModel,				// int  )			(char *s);
	EngFunc_PrecacheSound,				// int  )			(char *s);
	EngFunc_SetModel,					// void )			(edict_t *e, const char *m);
	EngFunc_ModelIndex,					// int  )			(const char *m);
	EngFunc_ModelFrames,				// int	)			(int modelIndex);
	EngFunc_SetSize,					// void )			(edict_t *e, const float *rgflMin, const float *rgflMax);
	EngFunc_ChangeLevel,				// void )			(char* s1, char* s2);
	EngFunc_VecToYaw,					// float)			(const float *rgflVector);
	EngFunc_VecToAngles,				// void )			(const float *rgflVectorIn, float *rgflVectorOut);
	EngFunc_MoveToOrigin,				// void )			(edict_t *ent, const float *pflGoal, float dist, int iMoveType);
	EngFunc_ChangeYaw,					// void )			(edict_t* ent);
	EngFunc_ChangePitch,				// void )			(edict_t* ent);
	EngFunc_FindEntityByString,			// edict)			(edict_t *pEdictStartSearchAfter, const char *pszField, const char *pszValue);
	EngFunc_GetEntityIllum,				// int	)			(edict_t* pEnt);
	EngFunc_FindEntityInSphere,			// edict)			(edict_t *pEdictStartSearchAfter, const float *org, float rad);
	EngFunc_FindClientInPVS,			// edict)			(edict_t *pEdict);
	EngFunc_EntitiesInPVS,				// edict)			(edict_t *pplayer);
	EngFunc_MakeVectors,				// void )			(const float *rgflVector);
	EngFunc_AngleVectors,				// void )			(const float *rgflVector, float *forward, float *right, float *up);
	EngFunc_CreateEntity,				// edict)			(void);
	EngFunc_RemoveEntity,				// void )			(edict_t *e);
	EngFunc_CreateNamedEntity,			// edict)			(int className);
	EngFunc_MakeStatic,					// void )			(edict_t *ent);
	EngFunc_EntIsOnFloor,				// int  )			(edict_t *e);
	EngFunc_DropToFloor,				// int  )			(edict_t *e);
	EngFunc_WalkMove,					// int  )			(edict_t *ent, float yaw, float dist, int iMode);
	EngFunc_SetOrigin,					// void )			(edict_t *e, const float *rgflOrigin);
	EngFunc_EmitSound,					// void )			(edict_t *entity, int channel, const char *sample, float volume, float attenuation, int fFlags, int pitch);
	EngFunc_EmitAmbientSound,			// void )			(edict_t *entity, float *pos, const char *samp, float vol, float attenuation, int fFlags, int pitch);

	//With 1.71 you can pass an optional TraceLine ptr for trace natives
	// it can be 0, for meaning "global tr handle" (for get/set_tr2), or
	// it can be any other TR handle (such as one from a TR hook)
	EngFunc_TraceLine,					// void )			(const float *v1, const float *v2, int fNoMonsters, edict_t *pentToSkip, TraceResult *ptr);
	EngFunc_TraceToss,					// void )			(edict_t *pent, edict_t *pentToIgnore, TraceResult *ptr);
	EngFunc_TraceMonsterHull,			// int  )			(edict_t *pEdict, const float *v1, const float *v2, int fNoMonsters, edict_t *pentToSkip, TraceResult *ptr);
	EngFunc_TraceHull,					// void )			(const float *v1, const float *v2, int fNoMonsters, int hullNumber, edict_t *pentToSkip, TraceResult *ptr);
	EngFunc_TraceModel,					// void )			(const float *v1, const float *v2, int hullNumber, edict_t *pent, TraceResult *ptr);
	EngFunc_TraceTexture,				// const char *)	(edict_t *pTextureEntity, const float *v1, const float *v2 );
	EngFunc_TraceSphere,				// void )			(const float *v1, const float *v2, int fNoMonsters, float radius, edict_t *pentToSkip, TraceResult *ptr);
	
	EngFunc_GetAimVector,				// void )			(edict_t *ent, float speed, float *rgflReturn);
	EngFunc_ParticleEffect,				// void )			(const float *org, const float *dir, float color, float count);
	EngFunc_LightStyle,					// void )			(int style, char *val);
	EngFunc_DecalIndex,					// int  )			(const char *name);
	EngFunc_PointContents,				// int  )			(const float *rgflVector);
	EngFunc_FreeEntPrivateData,			// void )			(edict_t *pEdict);
	EngFunc_SzFromIndex,				// const char *)	(int iString);
	EngFunc_AllocString,				// int  )			(const char *szValue);
	EngFunc_RegUserMsg,					// int	)			(const char *pszName, int iSize);
	EngFunc_AnimationAutomove,			// void )			(const edict_t *pEdict, float flTime);
	EngFunc_GetBonePosition,			// void )			(const edict_t *pEdict, int iBone, float *rgflOrigin, float *rgflAngles);
	EngFunc_GetAttachment,				// void	)			(const edict_t *pEdict, int iAttachment, float *rgflOrigin, float *rgflAngles);
	EngFunc_SetView,					// void )			(const edict_t *pClient, const edict_t *pViewent);
	EngFunc_Time,						// float)			( void );
	EngFunc_CrosshairAngle,				// void )			(const edict_t *pClient, float pitch, float yaw);
	EngFunc_FadeClientVolume,			// void )			(const edict_t *pEdict, int fadePercent, int fadeOutSeconds, int holdTime, int fadeInSeconds);
	EngFunc_SetClientMaxspeed,			// void )			(const edict_t *pEdict, float fNewMaxspeed);
	EngFunc_CreateFakeClient,			// edict)			(const char *netname);	// returns NULL if fake client can't be created
	EngFunc_RunPlayerMove,				// void )			(edict_t *fakeclient, const float *viewangles, float forwardmove, float sidemove, float upmove, unsigned short buttons, byte impulse, byte msec);
	EngFunc_NumberOfEntities,			// int  )			( void );
	EngFunc_StaticDecal,				// void )			(const float *origin, int decalIndex, int entityIndex, int modelIndex);
	EngFunc_PrecacheGeneric,			// int  )			(char* s);
	EngFunc_BuildSoundMsg,				// void )			(edict_t *entity, int channel, const char *sample, /*int*/float volume, float attenuation, int fFlags, int pitch, int msg_dest, int msg_type, const float *pOrigin, edict_t *ed);
	EngFunc_GetPhysicsKeyValue,			// const char *)	(const edict_t *pClient, const char *key);
	EngFunc_SetPhysicsKeyValue,			// void )			(const edict_t *pClient, const char *key, const char *value);
	EngFunc_GetPhysicsInfoString,		// const char *)	(const edict_t *pClient);
	EngFunc_PrecacheEvent,				// unsigned short)	(int type, const char*psz);
	EngFunc_PlaybackEvent,				// void )			(int flags, const edict_t *pInvoker, unsigned short eventindex, float delay, float *origin, float *angles, float fparam1, float fparam2, int iparam1, int iparam2, int bparam1, int bparam2);
	EngFunc_CheckVisibility,			// int  )			(const edict_t *entity, unsigned char *pset);
	EngFunc_GetCurrentPlayer,			// int  )			( void );
	EngFunc_CanSkipPlayer,				// int  )			(const edict_t *player);
	EngFunc_SetGroupMask,				// void )			(int mask, int op);
	EngFunc_GetClientListening,			// bool )			(int iReceiver, int iSender)
	EngFunc_SetClientListening,			// bool )			(int iReceiver, int iSender, bool Listen)
	EngFunc_MessageBegin,				// void )			(int msg_dest, int msg_type, const float *pOrigin, edict_t *ed)
	EngFunc_WriteCoord,					// void )			(float flValue)
	EngFunc_WriteAngle,					// void )			(float flValue)
	EngFunc_InfoKeyValue,				// char*)			(char *infobuffer, char *key);
	EngFunc_SetKeyValue,				// void )			(char *infobuffer, char *key, char *value);
	EngFunc_SetClientKeyValue,			// void )			(int clientIndex, char *infobuffer, char *key, char *value);
	EngFunc_CreateInstBaseline,			// int  )			(int classname, struct entity_state_s *baseline);
	
	// Returns pointer to info buffer that can be used with the infobuffer param of InfoKeyValue, SetKeyValue, and SetClientKeyValue
	EngFunc_GetInfoKeyBuffer,			// char*)			(edict_t *e);
	EngFunc_AlertMessage,				// void )			(ALERT_TYPE atype, char *szFmt, ...);
	EngFunc_ClientPrintf,				// void )			(edict_t* pEdict, PRINT_TYPE ptype, const char *szMsg);
	EngFunc_ServerPrint					// void )			(const char *szMsg);
};

/* Used with dllfunc()
 */
enum
{
	DLLFunc_GameInit,					// void )			( void );				
	DLLFunc_Spawn,						// int  )			(edict_t *pent);
	DLLFunc_Think,						// void )			(edict_t *pent);
	DLLFunc_Use,						// void )			(edict_t *pentUsed, edict_t *pentOther);
	DLLFunc_Touch,						// void )			(edict_t *pentTouched, edict_t *pentOther);
	DLLFunc_Blocked,					// void )			(edict_t *pentBlocked, edict_t *pentOther);
	
	//You can pass in 0 for glb kvd handle or a kvd handle here
	DLLFunc_KeyValue,					// void )			(edict_t *pentKeyvalue, KeyValueData *pkvd);
	DLLFunc_SetAbsBox,					// void )			(edict_t *pent);
	DLLFunc_ClientConnect,				// bool )			(edict_t *pEntity, const char *pszName, const char *pszAddress, char szRejectReason[128]);
	
	DLLFunc_ClientDisconnect,			// void )			(edict_t *pEntity);
	DLLFunc_ClientKill,					// void )			(edict_t *pEntity);
	DLLFunc_ClientPutInServer,			// void )			(edict_t *pEntity);
	DLLFunc_ClientCommand,				// void )			(edict_t *pEntity);

	DLLFunc_ServerDeactivate,			// void )			( void );

	DLLFunc_PlayerPreThink,				// void )			(edict_t *pEntity);
	DLLFunc_PlayerPostThink,			// void )			(edict_t *pEntity);

	DLLFunc_StartFrame,					// void )			( void );
	DLLFunc_ParmsNewLevel,				// void )			( void );
	DLLFunc_ParmsChangeLevel,			// void )			( void );

	// Returns string describing current .dll.  E.g., TeamFotrress 2, Half-Life
	// This also gets called when the server is queried for information (for example, by a server browser tool)
	DLLFunc_GetGameDescription,	 		// const char *)	( void );     

	// Spectator funcs
	DLLFunc_SpectatorConnect,			// void )			(edict_t *pEntity);
	DLLFunc_SpectatorDisconnect,		// void )			(edict_t *pEntity);
	DLLFunc_SpectatorThink,				// void )			(edict_t *pEntity);

	// Notify game .dll that engine is going to shut down.  Allows mod authors to set a breakpoint.
	DLLFunc_Sys_Error,					// void )			(const char *error_string);

	DLLFunc_PM_FindTextureType,			// char )			(char *name);
	DLLFunc_RegisterEncoders,			// void )			( void );

	// Enumerates player hulls.  Returns 0 if the hull number doesn't exist, 1 otherwise
	DLLFunc_GetHullBounds,				// int  )			(int hullnumber, float *mins, float *maxs);

	// Create baselines for certain "unplaced" items.
	DLLFunc_CreateInstBaselines,		// void )			( void );
	DLLFunc_pfnAllowLagCompensation,	// int  )			( void );
	// I know this does not fit with DLLFUNC(), but I don't want another native just for it.
	MetaFunc_CallGameEntity,			// bool	)			(plid_t plid, const char *entStr,entvars_t *pev);
	DLLFunc_ClientUserInfoChanged,		// void	)			(edict *pEntity, char *infobuffer);
	// You can pass in 0 for global cd handle or another cd handle here
	DLLFunc_UpdateClientData,			// void )			(const struct edict_s *ent, int sendweapons, struct clientdata_s *cd);
	// You can pass in 0 for global entity state handle or another entity state handle here
	DLLFunc_AddToFullPack,				// int  )			(struct entity_state_s *state, int e, edict_t *ent, edict_t *host, int hostflags, int player, unsigned char *pSet);
	// You can pass in 0 for global usercmd handle or another usercmd handle here
	DLLFunc_CmdStart,					// void )			(const edict_t *player, const struct usercmd_s *cmd, unsigned int random_seed);
	DLLFunc_CmdEnd,						// void )			(const edict_t *player);
	DLLFunc_CreateBaseline				// void )			(int player, int eindex, struct entity_state_s *baseline, struct edict_s *entity, int playermodelindex, vec3_t player_mins, vec3_t player_maxs);
};

enum {
	pev_string_start = 0,
	pev_classname,
	pev_globalname,
	pev_model,
	pev_target,
	pev_targetname,
	pev_netname,
	pev_message,
	pev_noise,
	pev_noise1,
	pev_noise2,
	pev_noise3,
	pev_string_end,
	pev_edict_start,
	pev_chain,
	pev_dmg_inflictor,
	pev_enemy,
	pev_aiment,
	pev_owner,
	pev_groundentity,
	pev_euser1,
	pev_euser2,
	pev_euser3,
	pev_euser4,
	pev_edict_end,
	pev_float_start,
	pev_impacttime,
	pev_starttime,
	pev_idealpitch,
	pev_ideal_yaw,
	pev_pitch_speed,
	pev_yaw_speed,
	pev_ltime,
	pev_nextthink,
	pev_gravity,
	pev_friction,
	pev_frame,
	pev_animtime,
	pev_framerate,
	pev_scale,
	pev_renderamt,
	pev_health,
	pev_frags,
	pev_takedamage,
	pev_max_health,
	pev_teleport_time,
	pev_armortype,
	pev_armorvalue,
	pev_dmg_take,
	pev_dmg_save,
	pev_dmg,
	pev_dmgtime,
	pev_speed,
	pev_air_finished,
	pev_pain_finished,
	pev_radsuit_finished,
	pev_maxspeed,
	pev_fov,
	pev_flFallVelocity,
	pev_fuser1,
	pev_fuser2,
	pev_fuser3,
	pev_fuser4,
	pev_float_end,
	pev_int_start,
	pev_fixangle,
	pev_modelindex,
	pev_viewmodel,
	pev_weaponmodel,
	pev_movetype,
	pev_solid,
	pev_skin,
	pev_body,
	pev_effects,
	pev_light_level,
	pev_sequence,
	pev_gaitsequence,
	pev_rendermode,
	pev_renderfx,
	pev_weapons,
	pev_deadflag,
	pev_button,
	pev_impulse,
	pev_spawnflags,
	pev_flags,
	pev_colormap,
	pev_team,
	pev_waterlevel,
	pev_watertype,
	pev_playerclass,
	pev_weaponanim,
	pev_pushmsec,
	pev_bInDuck,
	pev_flTimeStepSound,
	pev_flSwimTime,
	pev_flDuckTime,
	pev_iStepLeft,
	pev_gamestate,
	pev_oldbuttons,
	pev_groupinfo,
	pev_iuser1,
	pev_iuser2,
	pev_iuser3,
	pev_iuser4,
	pev_int_end,
	pev_byte_start,
	pev_controller_0,
	pev_controller_1,
	pev_controller_2,
	pev_controller_3,
	pev_blending_0,
	pev_blending_1,
	pev_byte_end,
	pev_bytearray_start,
	pev_controller,
	pev_blending,
	pev_bytearray_end,
	pev_vecarray_start,
	pev_origin,
	pev_oldorigin,
	pev_velocity,
	pev_basevelocity,
	pev_clbasevelocity,
	pev_movedir,
	pev_angles,
	pev_avelocity,
	pev_v_angle,
	pev_endpos,
	pev_startpos,
	pev_absmin,
	pev_absmax,
	pev_mins,
	pev_maxs,
	pev_size,
	pev_rendercolor,
	pev_view_ofs,
	pev_vuser1,
	pev_vuser2,
	pev_vuser3,
	pev_vuser4,
	pev_punchangle,
	pev_vecarray_end,
	pev_string2_begin,	/* anything after here are string corrections */
	pev_weaponmodel2,
	pev_viewmodel2,
	pev_string2_end,
	pev_edict2_start,	/* edict corrections */
	pev_pContainingEntity,
	pev_absolute_end
};

/* Used with global_get()
 */
enum
{
	glb_start_int = 0, 
	glb_trace_hitgroup, 
	glb_trace_flags, 
	glb_msg_entity, 
	glb_cdAudioTrack, 
	glb_maxClients, 
	glb_maxEntities, 
	glb_end_int, 
	glb_start_float, 
	glb_time, 
	glb_frametime, 
	glb_force_retouch, 
	glb_deathmatch, 
	glb_coop, 
	glb_teamplay, 
	glb_serverflags, 
	glb_found_secrets, 
	glb_trace_allsolid, 
	glb_trace_startsolid, 
	glb_trace_fraction, 
	glb_trace_plane_dist, 
	glb_trace_inopen, 
	glb_trace_inwater, 
	glb_end_float, 
	glb_start_edict, 
	glb_trace_ent, 
	glb_end_edict, 
	glb_start_vector, 
	glb_v_forward, 
	glb_v_up, 
	glb_v_right, 
	glb_trace_endpos, 
	glb_trace_plane_normal, 
	glb_vecLandmarkOffset,
	glb_end_vector,
	glb_start_string, 
	glb_mapname, 
	glb_startspot, 
	glb_end_string, 
	glb_start_pchar, 
	glb_pStringBase, 
	glb_end_pchar
};

/* Used with register_forward()
 */
enum {
	FM_PrecacheModel = 1,
	FM_PrecacheSound,
	FM_SetModel,	
	FM_ModelIndex,
	FM_ModelFrames,
	FM_SetSize,
	FM_ChangeLevel,
	FM_VecToYaw,
	FM_VecToAngles,
	FM_MoveToOrigin,
	FM_ChangeYaw,
	FM_ChangePitch,
	FM_FindEntityByString,
	FM_GetEntityIllum,
	FM_FindEntityInSphere,
	FM_FindClientInPVS,
	FM_EntitiesInPVS,
	FM_MakeVectors,
	FM_AngleVectors,
	FM_CreateEntity,
	FM_RemoveEntity,
	FM_CreateNamedEntity,
	FM_MakeStatic,
	FM_EntIsOnFloor,
	FM_DropToFloor,
	FM_WalkMove,
	FM_SetOrigin,
	FM_EmitSound,
	FM_EmitAmbientSound,
	FM_TraceLine,
	FM_TraceToss,
	FM_TraceMonsterHull,
	FM_TraceHull,
	FM_TraceModel,
	FM_TraceTexture,
	FM_TraceSphere,
	FM_GetAimVector,
	FM_ParticleEffect,
	FM_LightStyle,
	FM_DecalIndex,
	FM_PointContents,
	FM_MessageBegin,
	FM_MessageEnd,
	FM_WriteByte,
	FM_WriteChar,
	FM_WriteShort,
	FM_WriteLong,
	FM_WriteAngle,
	FM_WriteCoord,
	FM_WriteString,
	FM_WriteEntity,
	FM_CVarGetFloat,
	FM_CVarGetString,
	FM_CVarSetFloat,
	FM_CVarSetString,
	FM_FreeEntPrivateData,
	FM_SzFromIndex,
	FM_AllocString,
	FM_RegUserMsg,
	FM_AnimationAutomove,
	FM_GetBonePosition,
	FM_GetAttachment,
	FM_SetView,
	FM_Time,
	FM_CrosshairAngle,
	FM_FadeClientVolume,
	FM_SetClientMaxspeed,
	FM_CreateFakeClient,
	FM_RunPlayerMove,
	FM_NumberOfEntities,
	FM_StaticDecal,
	FM_PrecacheGeneric,
	FM_BuildSoundMsg,
	FM_GetPhysicsKeyValue,
	FM_SetPhysicsKeyValue,
	FM_GetPhysicsInfoString,
	FM_PrecacheEvent,
	FM_PlaybackEvent,
	FM_CheckVisibility,
	FM_GetCurrentPlayer,
	FM_CanSkipPlayer,
	FM_SetGroupMask,
	FM_Voice_GetClientListening,
	FM_Voice_SetClientListening,
	FM_InfoKeyValue,
	FM_SetKeyValue,
	FM_SetClientKeyValue,
	FM_GetPlayerAuthId,
	FM_GetPlayerWONId,
	FM_IsMapValid,

	FM_Spawn,
	FM_Think,
	FM_Use,
	FM_Touch,
	FM_Blocked,
	FM_KeyValue,
	FM_SetAbsBox,
	FM_ClientConnect,
	
	FM_ClientDisconnect,
	FM_ClientKill,
	FM_ClientPutInServer,
	FM_ClientCommand,

	FM_ServerDeactivate,

	FM_PlayerPreThink,
	FM_PlayerPostThink,

	FM_StartFrame,
	FM_ParmsNewLevel,
	FM_ParmsChangeLevel,

	// Returns string describing current .dll.  E.g., TeamFotrress 2, Half-Life
	// This also gets called when the server is queried for information (for example, by a server browser tool)
	FM_GetGameDescription,

	// Spectator funcs
	FM_SpectatorConnect,
	FM_SpectatorDisconnect,
	FM_SpectatorThink,

	// Notify game .dll that engine is going to shut down.  Allows mod authors to set a breakpoint.
	FM_Sys_Error,

	FM_PM_FindTextureType,
	FM_RegisterEncoders,

	// Create baselines for certain "unplaced" items.
	FM_CreateInstBaselines,
	
	FM_AllowLagCompensation,
	FM_AlertMessage,
	
	// NEW_DLL_FUNCTIONS:
	FM_OnFreeEntPrivateData,
	FM_GameShutdown,
	FM_ShouldCollide,
	
	// LATE ADDITIONS (v1.71)
	FM_ClientUserInfoChanged,
	
	// LATE ADDITIONS (v1.75)
	FM_UpdateClientData,
	FM_AddToFullPack,
	FM_CmdStart,
	FM_CmdEnd,
	FM_CreateInstBaseline,
	FM_CreateBaseline,
	FM_GetInfoKeyBuffer,
	FM_ClientPrintf,
	
	// LATE ADDITIONS (v1.80)
	FM_ServerPrint
};

enum TraceResult
{
	TR_AllSolid,		// int
	TR_StartSolid,		// int
	TR_InOpen,			// int
	TR_InWater,			// int
	TR_flFraction,		// float
	TR_vecEndPos,		// float array[3]
	TR_flPlaneDist,		// float
	TR_vecPlaneNormal,	// float array[3]
	TR_pHit,			// int (edict_t*)
	TR_iHitgroup,		// int
};

enum KeyValueData
{
	KV_ClassName,		// string
	KV_KeyName,			// string
	KV_Value,			// string
	KV_fHandled			// int
};

enum ClientData
{
	CD_Origin,			// float array[3]
	CD_Velocity,		// float array[3]
	CD_ViewModel,		// int
	CD_PunchAngle,		// float array[3]
	CD_Flags,			// int
	CD_WaterLevel,		// int
	CD_WaterType,		// int
	CD_ViewOfs,			// float array[3]
	CD_Health,			// float
	CD_bInDuck,			// int
	CD_Weapons,			// int
	CD_flTimeStepSound,	// int
	CD_flDuckTime,		// int
	CD_flSwimTime,		// int
	CD_WaterJumpTime,	// int
	CD_MaxSpeed,		// float
	CD_FOV,				// float
	CD_WeaponAnim,		// int
	CD_ID,				// int
	CD_AmmoShells,		// int
	CD_AmmoNails,		// int
	CD_AmmoCells,		// int
	CD_AmmoRockets,		// int
	CD_flNextAttack,	// float
	CD_tfState,			// int
	CD_PushMsec,		// int
	CD_DeadFlag,		// int
	CD_PhysInfo,		// string[256]
	CD_iUser1,			// int
	CD_iUser2,			// int
	CD_iUser3,			// int
	CD_iUser4,			// int
	CD_fUser1,			// float
	CD_fUser2,			// float
	CD_fUser3,			// float
	CD_fUser4,			// float
	CD_vUser1,			// float array[3]
	CD_vUser2,			// float array[3]
	CD_vUser3,			// float array[3]
	CD_vUser4			// float array[3]
};

enum EntityState
{
	// Fields which are filled in by routines outside of delta compression
	ES_EntityType,		// int
	// Index into cl_entities array for this entity
	ES_Number,			// int
	ES_MsgTime,			// float
	
	// Message number last time the player/entity state was updated
	ES_MessageNum,		// int
	
	// Fields which can be transitted and reconstructed over the network stream
	ES_Origin,			// float array[3]
	ES_Angles,			// float array[3]
	
	ES_ModelIndex,		// int
	ES_Sequence,		// int
	ES_Frame,			// float
	ES_ColorMap,		// int
	ES_Skin,			// short
	ES_Solid,			// short
	ES_Effects,			// int 
	ES_Scale,			// float
	ES_eFlags,			// byte
	
	// Render information
	ES_RenderMode,		// int
	ES_RenderAmt,		// int
	ES_RenderColor,		// byte array[3], RGB value
	ES_RenderFx,		// int
	
	ES_MoveType,		// int
	ES_AnimTime,		// float
	ES_FrameRate,		// float
	ES_Body,			// int
	ES_Controller,		// byte array[4]
	ES_Blending,		// byte array[4]
	ES_Velocity,		// float array[3]
	
	// Send bbox down to client for use during prediction
	ES_Mins,			// float array[3]
	ES_Maxs,			// float array[3]
	
	ES_AimEnt,			// int
	// If owned by a player, the index of that player (for projectiles)
	ES_Owner,			// int
	
	// Friction, for prediction
	ES_Friction,		// float
	// Gravity multiplier
	ES_Gravity,			// float
	
	// PLAYER SPECIFIC
	ES_Team,			// int
	ES_PlayerClass,		// int
	ES_Health,			// int
	ES_Spectator,		// bool
	ES_WeaponModel,		// int
	ES_GaitSequence,	// int
	// If standing on conveyor, e.g.
	ES_BaseVelocity,	// float array[3]
	// Use the crouched hull, or the regular player hull
	ES_UseHull,			// int
	// Latched buttons last time state updated
	ES_OldButtons,		// int
	// -1 = in air, else pmove entity number
	ES_OnGround,		// int
	ES_iStepLeft,		// int
	// How fast we are falling
	ES_flFallVelocity,	// float
	
	ES_FOV,				// float
	ES_WeaponAnim,		// int	
	
	// Parametric movement overrides
	ES_StartPos,		// float array[3]
	ES_EndPos,			// float array[3]
	ES_ImpactTime,		// float
	ES_StartTime,		// float
	
	// For mods
	ES_iUser1,			// int
	ES_iUser2,			// int
	ES_iUser3,			// int
	ES_iUser4,			// int
	ES_fUser1,			// float
	ES_fUser2,			// float
	ES_fUser3,			// float
	ES_fUser4,			// float
	ES_vUser1,			// float array[3]
	ES_vUser2,			// float array[3]
	ES_vUser3,			// float array[3]
	ES_vUser4			// float array[3]
};

enum UserCmd
{
	// Interpolation time on client
	UC_LerpMsec,		// short
	// Duration in ms of command
	UC_Msec,			// byte
	// Command view angles
	UC_ViewAngles,		// float array[3]
	
	// Intended velocities
	// Forward velocity
	UC_ForwardMove,		// float
	// Sideways velocity
	UC_SideMove,		// float
	// Upward velocity
	UC_UpMove,			// float
	// Light level at spot where we are standing
	UC_LightLevel,		// byte
	// Attack buttons
	UC_Buttons,			// unsigned short
	// Impulse command issued
	UC_Impulse,			// byte
	// Current weapon id
	UC_WeaponSelect,	// byte
	
	// Experimental player impact stuff
	UC_ImpactIndex,		// int
	UC_ImpactPosition	// float array[3]
};

enum AlertType
{
	at_notice = 0,
	at_console,		// same as at_notice, but forces a ConPrintf, not a message box
	at_aiconsole,	// same as at_console, but only shown if developer level is 2!
	at_warning,
	at_error,
	at_logged		// Server print to console (only in multiplayer games)
};
// vim: set ts=4 sw=4 tw=99 noet:
//
// AMX Mod X, based on AMX Mod by Aleksander Naszko ("OLO").
// Copyright (C) The AMX Mod X Development Team.
//
// This software is licensed under the GNU General Public License, version 3 or higher.
// Additional exceptions apply. For full license details, see LICENSE.txt or visit:
//     https://alliedmods.net/amxmodx-license

//
// Fakemeta Stocks
//

#if !defined _fakemeta_included
	#include <fakemeta>
#endif

#if defined _fakemeta_stocks_included
  #endinput
#endif
#define _fakemeta_stocks_included

// EngFuncs
stock EF_PrecacheModel(const string[])
	return engfunc(EngFunc_PrecacheModel, string);

stock EF_PrecacheSound(const string[])
	return engfunc(EngFunc_PrecacheSound, string);
stock EF_SetModel(const ID, const STRING[])
	return engfunc(EngFunc_SetModel, ID, STRING);
stock EF_ModelIndex(const STRING[])
	return engfunc(EngFunc_ModelIndex, STRING);
stock EF_ModelFrames(modelIndex)
	return engfunc(EngFunc_ModelFrames, modelIndex);

stock EF_SetSize(const ENTITY, const Float:MIN[3], const Float:MAX[3])
	return engfunc(EngFunc_SetSize, ENTITY, MIN, MAX);
stock EF_ChangeLevel(const S1[], const S2[])
	return engfunc(EngFunc_ChangeLevel, S1, S2);
stock EF_VecToYaw(const Float:VECTOR[3], &Float:returnValue)
	return engfunc(EngFunc_VecToYaw, VECTOR, returnValue);
stock EF_VecToAngles(const Float:VECTORIN[3], const Float:VECTOROUT[3])
	return engfunc(EngFunc_VecToAngles, VECTORIN, VECTOROUT);
stock EF_MoveToOrigin(const ENTITY, const Float:GOAL[3], const Float:DISTANCE, const MOVETYPE)
	return engfunc(EngFunc_MoveToOrigin, ENTITY, GOAL, DISTANCE, MOVETYPE);

stock EF_ChangeYaw(const ENTITY)
	return engfunc(EngFunc_ChangeYaw, ENTITY);
stock EF_ChangePitch(const ENTITY)
	return engfunc(EngFunc_ChangePitch, ENTITY);
stock EF_FindEntityByString(const STARTSEARCHAFTER, const FIELD[], const VALUE[])
	return engfunc(EngFunc_FindEntityByString, STARTSEARCHAFTER, FIELD, VALUE);
stock EF_GetEntityIllum(const ENTITY)
	return engfunc(EngFunc_GetEntityIllum, ENTITY);
stock EF_FindEntityInSphere(const STARTSEARCHAFTER, const Float:ORIGIN[3], Float:radius)
	return engfunc(EngFunc_FindEntityInSphere, STARTSEARCHAFTER, ORIGIN, radius);

stock EF_FindClientInPVS(const CLIENT)
	return engfunc(EngFunc_FindClientInPVS, CLIENT);
stock EF_EntitiesInPVS(const CLIENT)
	return engfunc(EngFunc_EntitiesInPVS, CLIENT);
stock EF_MakeVectors(const Float:VECTOR[3])
	return engfunc(EngFunc_MakeVectors, VECTOR);
stock EF_AngleVectors(const Float:VECTOR[3], Float:forward_[3], Float:right[3], Float:up[3])
	return engfunc(EngFunc_AngleVectors, VECTOR, forward_, right, up);
stock EF_CreateEntity()
	return engfunc(EngFunc_CreateEntity);

stock EF_RemoveEntity(const ENTITY)
	return engfunc(EngFunc_RemoveEntity, ENTITY);
stock EF_CreateNamedEntity(const CLASSNAME)
	return engfunc(EngFunc_CreateNamedEntity, CLASSNAME);
stock EF_MakeStatic(const ENTITY)
	return engfunc(EngFunc_MakeStatic, ENTITY);
stock EF_EntIsOnFloor(const ENTITY)
	return engfunc(EngFunc_EntIsOnFloor, ENTITY);
stock EF_DropToFloor(const ENTITY)
	return engfunc(EngFunc_DropToFloor, ENTITY);

stock EF_WalkMove(const ENTITY, Float:yaw, Float:distance, iMode)
	return engfunc(EngFunc_WalkMove, ENTITY, yaw, distance, iMode);
stock EF_SetOrigin(const ENTITY, const Float:ORIGIN[3])
	return engfunc(EngFunc_SetOrigin, ENTITY, ORIGIN);
stock EF_EmitSound(const ENTITY, channel, const SAMPLE[], Float:volume, Float:attenuation, fFlags, pitch)
	return engfunc(EngFunc_EmitSound, ENTITY, channel, SAMPLE, volume, attenuation, fFlags, pitch);
stock EF_EmitAmbientSound(const ENTITY, Float:pos[3], const SAMPLE[], Float:volume, Float:attenuation, fFlags, pitch)
	return engfunc(EngFunc_EmitAmbientSound, ENTITY, pos, SAMPLE, volume, attenuation, fFlags, pitch);
stock EF_TraceLine(const Float:V1[3], const Float:V2[3], fNoMonsters, const ENT_TO_SKIP)
	return engfunc(EngFunc_TraceLine, V1, V2, fNoMonsters, ENT_TO_SKIP);

stock EF_TraceToss(const ENTITY, const ENTITY_TO_IGNORE)
	return engfunc(EngFunc_TraceToss, ENTITY, ENTITY_TO_IGNORE);
stock EF_TraceMonsterHull(const ENTITY, const Float:V1[3], const Float:V2[3], fNoMonsters, const ENTITY_TO_SKIP)
	return engfunc(EngFunc_TraceMonsterHull, ENTITY, V1, V2, fNoMonsters, ENTITY_TO_SKIP);
stock EF_TraceHull(const Float:V1[3], const Float:V2[3], fNoMonsters, hullNumber, const ENTITY_TO_SKIP)
	return engfunc(EngFunc_TraceHull, V1, V2, fNoMonsters, hullNumber, ENTITY_TO_SKIP);
stock EF_TraceModel(const Float:V1[3], const Float:V2[3], hullNumber, const ENTITY)
	return engfunc(EngFunc_TraceModel, V1, V2, hullNumber, ENTITY);
stock EF_TraceTexture(const TEXTURE_ENTITY, const Float:V1[3], const Float:V2[3])
	return engfunc(EngFunc_TraceTexture, TEXTURE_ENTITY, V1, V2);

stock EF_TraceSphere(const Float:V1[3], const Float:V2[3], fNoMonsters, Float:radius, const ENTITY_TO_SKIP)
	return engfunc(EngFunc_TraceSphere, V1, V2, fNoMonsters, radius, ENTITY_TO_SKIP);
stock EF_GetAimVector(const ENTITY, Float:speed, Float:returnVector[3])
	return engfunc(EngFunc_GetAimVector, ENTITY, speed, returnVector);
stock EF_ParticleEffect(const Float:ORIGIN[3], const Float:DIRECTION[3], Float:color, Float:count)
	return engfunc(EngFunc_ParticleEffect, ORIGIN, DIRECTION, color, count);
stock EF_LightStyle(style, val[])
	return engfunc(EngFunc_LightStyle, style, val);
stock EF_DecalIndex(const NAME[])
	return engfunc(EngFunc_DecalIndex, NAME);

stock EF_PointContents(const Float:VECTOR[3])
	return engfunc(EngFunc_PointContents, VECTOR);
stock EF_FreeEntPrivateData(const ENTITY)
	return engfunc(EngFunc_FreeEntPrivateData, ENTITY);
stock EF_SzFromIndex(iString)
	return engfunc(EngFunc_SzFromIndex, iString);
stock EF_AllocString(const STRING[])
	return engfunc(EngFunc_AllocString, STRING);
stock EF_RegUserMsg(const NAME[], iSize)
	return engfunc(EngFunc_RegUserMsg, NAME, iSize);

stock EF_AnimationAutomove(const ENTITY, Float:flTime)
	return engfunc(EngFunc_AnimationAutomove, ENTITY, flTime);
stock EF_GetBonePosition(const ENTITY, iBone, Float:origin[3], Float:angles[3])
	return engfunc(EngFunc_GetBonePosition, ENTITY, iBone, origin, angles);
stock EF_GetAttachment(const ENTITY, iAttachment, Float:origin[3], Float:angles[3])
	return engfunc(EngFunc_GetAttachment, ENTITY, iAttachment, origin, angles);
stock EF_SetView(const CLIENT, const VIEW_ENTITY)
	return engfunc(EngFunc_SetView, CLIENT, VIEW_ENTITY);
stock EF_Time(&Float:returnValue)
	return engfunc(EngFunc_Time, returnValue);

stock EF_CrosshairAngle(const CLIENT, Float:pitch, Float:yaw)
	return engfunc(EngFunc_CrosshairAngle, CLIENT, pitch, yaw);
stock EF_FadeClientVolume(const ENTITY, fadePercent, fadeOutSeconds, holdTime, fadeInSeconds)
	return engfunc(EngFunc_FadeClientVolume, ENTITY, fadePercent, fadeOutSeconds, holdTime, fadeInSeconds);
stock EF_SetClientMaxspeed(const ENTITY, Float:newMaxspeed)
	return engfunc(EngFunc_SetClientMaxspeed, ENTITY, newMaxspeed);
stock EF_CreateFakeClient(const NETNAME[])
	return engfunc(EngFunc_CreateFakeClient, NETNAME);
stock EF_RunPlayerMove(const FAKECLIENT, const Float:VIEWANGLES[3], Float:forwardmove, Float:sidemove, Float:upmove, buttons, impulse, msec)
	return engfunc(EngFunc_RunPlayerMove, FAKECLIENT, VIEWANGLES, forwardmove, sidemove, upmove, buttons, impulse, msec);

stock EF_NumberOfEntities()
	return engfunc(EngFunc_NumberOfEntities);
stock EF_StaticDecal(const Float:ORIGIN[3], decalIndex, entityIndex, modelIndex)
	return engfunc(EngFunc_StaticDecal, ORIGIN, decalIndex, entityIndex, modelIndex);
stock EF_PrecacheGeneric(const STRING[])
	return engfunc(EngFunc_PrecacheGeneric, STRING);
stock EF_BuildSoundMSG(const ENTITY, channel, const SAMPLE[], Float:volume, Float:attenuation, fFlags, pitch, msg_dest, msg_type, const Float:ORIGIN[3], const ED)
	return engfunc(EngFunc_BuildSoundMsg, ENTITY, channel, SAMPLE, volume, attenuation, fFlags, pitch, msg_dest, msg_type, ORIGIN, ED);
stock EF_GetPhysicsKeyValue(const CLIENT, const KEY[])
	return engfunc(EngFunc_GetPhysicsKeyValue, CLIENT, KEY);

stock EF_SetPhysicsKeyValue(const CLIENT, const KEY[], const VALUE[])
	return engfunc(EngFunc_SetPhysicsKeyValue, CLIENT, KEY, VALUE);
stock EF_GetPhysicsInfoString(const CLIENT, returnString[], maxLength)
	return engfunc(EngFunc_GetPhysicsInfoString, CLIENT, returnString, maxLength);
stock EF_PrecacheEvent(type, const STRING[])
	return engfunc(EngFunc_PrecacheEvent, type, STRING);
stock EF_PlaybackEvent(flags, const INVOKER, eventindex, Float:delay, Float:origin[3], Float:angles[3], Float:fparam1, Float:fparam2, iparam1, iparam2, bparam1, bparam2)
	return engfunc(EngFunc_PlaybackEvent, flags, INVOKER, eventindex, delay, origin, angles, fparam1, fparam2, iparam1, iparam2, bparam1, bparam2);
stock EF_CheckVisibility(const ENTITY, set)
	return engfunc(EngFunc_CheckVisibility, ENTITY, set);

stock EF_GetCurrentPlayer()
	return engfunc(EngFunc_GetCurrentPlayer);
stock EF_CanSkipPlayer(const PLAYER)
	return engfunc(EngFunc_CanSkipPlayer, PLAYER);
stock EF_SetGroupMask(mask, op)
	return engfunc(EngFunc_SetGroupMask, mask, op);
stock EF_GetClientListening(receiver, sender)
	return engfunc(EngFunc_GetClientListening, receiver, sender);
stock EF_SetClientListening(receiver, sender, bool:listen)
	return engfunc(EngFunc_SetClientListening, receiver, sender, listen);

stock EF_MessageBegin(msg_dest, msg_type, const Float:ORIGIN[3], const ED)
	return engfunc(EngFunc_MessageBegin, msg_dest, msg_type, ORIGIN, ED);
stock EF_WriteCoord(Float:value)
	return engfunc(EngFunc_WriteCoord, value);
stock EF_WriteAngle(Float:value)
	return engfunc(EngFunc_WriteAngle, value);
stock EF_InfoKeyValue(const INFOBUFFER, const KEY[], returnValue[], maxLength)
	return engfunc(EngFunc_InfoKeyValue, INFOBUFFER, KEY, returnValue, maxLength);
stock EF_SetKeyValue(const INFOBUFFER, const KEY[], const VALUE[])
	return engfunc(EngFunc_SetKeyValue, INFOBUFFER, KEY, VALUE);

stock EF_SetClientKeyValue(const ID, const INFOBUFFER, const KEY[], const VALUE[])
	return engfunc(EngFunc_SetClientKeyValue, ID, INFOBUFFER, KEY, VALUE);

stock EF_CreateInstBaseline(CLASSNAME, baseline)
	return engfunc(EngFunc_CreateInstBaseline, CLASSNAME, baseline);

// Returns pointer to info buffer that can be used with the INFOBUFFER param
// of EF_InfoKeyValue, EF_SetKeyValue, and EF_SetClientKeyValue
stock EF_GetInfoKeyBuffer(const ENTITY)
	return engfunc(EngFunc_GetInfoKeyBuffer, ENTITY);
stock EF_ClientPrintf(const ENTITY, const printType, const MESSAGE[])
	return engfunc(EngFunc_ClientPrintf, ENTITY, printType, MESSAGE);
stock EF_ServerPrint(const MESSAGE[])
	return engfunc(EngFunc_ServerPrint, MESSAGE);

// DLLFuncs
stock DF_GameInit()
	return dllfunc(DLLFunc_GameInit);
stock DF_Spawn(const ENTITY)
	return dllfunc(DLLFunc_Spawn, ENTITY);
stock DF_Think(const ENTITY)
	return dllfunc(DLLFunc_Think, ENTITY);
stock DF_Use(const ENT_Used, const ENT_User)
	return dllfunc(DLLFunc_Use, ENT_Used, ENT_User);
stock DF_Touch(const ENT_Touched, const ENT_Toucher)
	return dllfunc(DLLFunc_Touch, ENT_Touched, ENT_Toucher);

stock DF_Blocked(const ENT_Blocked, const ENT_Other)
	return dllfunc(DLLFunc_Blocked, ENT_Blocked, ENT_Other);
stock DF_SetAbsBox(const ENTITY)
	return dllfunc(DLLFunc_SetAbsBox, ENTITY);
stock DF_ClientConnect(const ENTITY, const NAME[], const ADDRESS[], RejectReason[128])
	return dllfunc(DLLFunc_ClientConnect, ENTITY, NAME, ADDRESS, RejectReason);
stock DF_ClientDisconnect(const ENTITY)
	return dllfunc(DLLFunc_ClientDisconnect, ENTITY);
stock DF_ClientKill(const ENTITY)
	return dllfunc(DLLFunc_ClientKill, ENTITY);

stock DF_ClientPutInServer(const ENTITY)
	return dllfunc(DLLFunc_ClientPutInServer, ENTITY);
stock DF_ClientCommand(const ENTITY)
	return dllfunc(DLLFunc_ClientCommand, ENTITY);
stock DF_ServerDeactivate()
	return dllfunc(DLLFunc_ServerDeactivate);
stock DF_PlayerPreThink(const ENTITY)
	return dllfunc(DLLFunc_PlayerPreThink, ENTITY);
stock DF_PlayerPostThink(const ENTITY)
	return dllfunc(DLLFunc_PlayerPostThink, ENTITY);

stock DF_StartFrame()
	return dllfunc(DLLFunc_StartFrame);
stock DF_ParmsNewLevel()
	return dllfunc(DLLFunc_ParmsNewLevel);
stock DF_ParmsChangeLevel()
	return dllfunc(DLLFunc_ParmsChangeLevel);
stock DF_GetGameDescription()
	return dllfunc(DLLFunc_GetGameDescription);
stock DF_SpectatorConnect(const ENTITY)
	return dllfunc(DLLFunc_SpectatorConnect, ENTITY);

stock DF_SpectatorDisconnect(const ENTITY)
	return dllfunc(DLLFunc_SpectatorDisconnect, ENTITY);
stock DF_SpectatorThink(const ENTITY)
	return dllfunc(DLLFunc_SpectatorThink, ENTITY);
stock DF_Sys_Error(const ERROR_STRING[])
	return dllfunc(DLLFunc_Sys_Error, ERROR_STRING);
stock DF_PM_FindTextureType(name[])
	return dllfunc(DLLFunc_PM_FindTextureType, name);
stock DF_RegisterEncoders()
	return dllfunc(DLLFunc_RegisterEncoders);

stock DF_GetHullBounds(hullnumber, Float:mins[3], Float:maxs[3])
	return dllfunc(DLLFunc_GetHullBounds, hullnumber, mins, maxs);
stock DF_CreateInstBaselines()
	return dllfunc(DLLFunc_CreateInstBaselines);
stock DF_pfnAllowLagCompensation()
	return dllfunc(DLLFunc_pfnAllowLagCompensation);
stock DF_MetaFunc_CallGameEntity(const STRING[], const ENTITY)
	return dllfunc(MetaFunc_CallGameEntity, STRING, ENTITY);
stock DF_ClientUserInfoChanged(const IDPLAYER)
	return dllfunc(DLLFunc_ClientUserInfoChanged, IDPLAYER);
	
stock DF_UpdateClientData(const ENTITY, sendweapons, const cd/* = 0*/)
	return dllfunc(DLLFunc_UpdateClientData, ENTITY, sendweapons, cd);
stock DF_AddToFullPack(const STATE/* = 0*/, e, ENT, HOST, hostflags, player, set)
	return dllfunc(DLLFunc_AddToFullPack, STATE, e, ENT, HOST, hostflags, player, set);
stock DF_CmdStart(const PLAYER, const CMD/* = 0*/, randomSeed)
	return dllfunc(DLLFunc_CmdStart, PLAYER, CMD, randomSeed);
stock DF_CmdEnd(const PLAYER)
	return dllfunc(DLLFunc_CmdEnd, PLAYER);
stock DF_CreateBaseline(PLAYER, eIndex, baseline, playerModelIndex, Float:playerMins[3], Float:playerMaxs[3])
	return dllfunc(DLLFunc_CreateBaseline, PLAYER, eIndex, baseline, playerModelIndex, playerMins, playerMaxs);
/**
 * This file provides various utility functions that use the Fakemeta module.
 * This file is created and maintained by VEN.
 * For support and issues, see:
 * http://forums.alliedmods.net/showthread.php?t=28284
 */
 

/* Fakemeta Utilities
*
* by VEN
*
* This file is provided as is (no warranties).
*/

#if !defined _fakemeta_included
	#include <fakemeta>
#endif

#if defined _fakemeta_util_included
	#endinput
#endif
#define _fakemeta_util_included

#include <xs>


/* Engine functions */

#define fm_precache_generic(%1) engfunc(EngFunc_PrecacheGeneric, %1)
/* stock fm_precache_generic(const file[])
	return engfunc(EngFunc_PrecacheGeneric, file) */

#define fm_precache_event(%1,%2) engfunc(EngFunc_PrecacheEvent, %1, %2)
/* stock fm_precache_event(type, const name[])
	return engfunc(EngFunc_PrecacheEvent, type, name) */

// ported by v3x
#define fm_drop_to_floor(%1) engfunc(EngFunc_DropToFloor, %1)
/* stock fm_drop_to_floor(entity)
	return engfunc(EngFunc_DropToFloor, entity) */

#define fm_force_use(%1,%2) dllfunc(DLLFunc_Use, %2, %1)
/* stock fm_force_use(user, used)
	return dllfunc(DLLFunc_Use, used, user) */

#define fm_entity_set_size(%1,%2,%3) engfunc(EngFunc_SetSize, %1, %2, %3)
/* stock fm_entity_set_size(index, const Float:mins[3], const Float:maxs[3])
	return engfunc(EngFunc_SetSize, index, mins, maxs) */

#define fm_get_decal_index(%1) engfunc(EngFunc_DecalIndex, %1)
/* stock fm_get_decal_index(const decalname[])
	return engfunc(EngFunc_DecalIndex, decalname) */

stock Float:fm_entity_range(ent1, ent2) {
	new Float:origin1[3], Float:origin2[3];
	pev(ent1, pev_origin, origin1);
	pev(ent2, pev_origin, origin2);

	return get_distance_f(origin1, origin2);
}

// based on KoST's port, upgraded version fits into the macros
#define fm_create_entity(%1) engfunc(EngFunc_CreateNamedEntity, engfunc(EngFunc_AllocString, %1))
/* stock fm_create_entity(const classname[])
	return engfunc(EngFunc_CreateNamedEntity, engfunc(EngFunc_AllocString, classname)) */

#define fm_find_ent_by_class(%1,%2) engfunc(EngFunc_FindEntityByString, %1, "classname", %2)
/* stock fm_find_ent_by_class(index, const classname[])
	return engfunc(EngFunc_FindEntityByString, index, "classname", classname) */

stock fm_find_ent_by_owner(index, const classname[], owner, jghgtype = 0) {
	new strtype[11] = "classname", ent = index;
	switch (jghgtype) {
		case 1: strtype = "target";
		case 2: strtype = "targetname";
	}

	while ((ent = engfunc(EngFunc_FindEntityByString, ent, strtype, classname)) && pev(ent, pev_owner) != owner) {}

	return ent;
}

#define fm_find_ent_by_target(%1,%2) engfunc(EngFunc_FindEntityByString, %1, "target", %2)
/* stock fm_find_ent_by_target(index, const target[])
	return engfunc(EngFunc_FindEntityByString, index, "target", target) */

#define fm_find_ent_by_tname(%1,%2) engfunc(EngFunc_FindEntityByString, %1, "targetname", %2)
/* stock fm_find_ent_by_tname(index, const targetname[])
	return engfunc(EngFunc_FindEntityByString, index, "targetname", targetname) */

stock fm_find_ent_by_model(index, const classname[], const model[]) {
	new ent = index, mdl[72];
	while ((ent = fm_find_ent_by_class(ent, classname))) {
		pev(ent, pev_model, mdl, sizeof mdl - 1);
		if (equal(mdl, model))
			return ent;
	}

	return 0;
}

#define fm_find_ent_in_sphere(%1,%2,%3) engfunc(EngFunc_FindEntityInSphere, %1, %2, %3)
/* stock fm_find_ent_in_sphere(index, const Float:origin[3], Float:radius)
	return engfunc(EngFunc_FindEntityInSphere, index, origin, radius) */

#define fm_call_think(%1) dllfunc(DLLFunc_Think, %1)
/* stock fm_call_think(entity)
	return dllfunc(DLLFunc_Think, entity) */

#define fm_is_valid_ent(%1) pev_valid(%1)
/* stock fm_is_valid_ent(index)
	return pev_valid(index) */

stock fm_entity_set_origin(index, const Float:origin[3]) {
	new Float:mins[3], Float:maxs[3];
	pev(index, pev_mins, mins);
	pev(index, pev_maxs, maxs);
	engfunc(EngFunc_SetSize, index, mins, maxs);

	return engfunc(EngFunc_SetOrigin, index, origin);
}

#define fm_entity_set_model(%1,%2) engfunc(EngFunc_SetModel, %1, %2)
/* stock fm_entity_set_model(index, const model[])
	return engfunc(EngFunc_SetModel, index, model) */

// ported by v3x
#define fm_remove_entity(%1) engfunc(EngFunc_RemoveEntity, %1)
/* stock fm_remove_entity(index)
	return engfunc(EngFunc_RemoveEntity, index) */

#define fm_entity_count() engfunc(EngFunc_NumberOfEntities)
/* stock fm_entity_count()
	return engfunc(EngFunc_NumberOfEntities) */

#define fm_fake_touch(%1,%2) dllfunc(DLLFunc_Touch, %1, %2)
/* stock fm_fake_touch(toucher, touched)
	return dllfunc(DLLFunc_Touch, toucher, touched) */

#define fm_DispatchSpawn(%1) dllfunc(DLLFunc_Spawn, %1)
/* stock fm_DispatchSpawn(entity)
	return dllfunc(DLLFunc_Spawn, entity) */

// ported by v3x
#define fm_point_contents(%1) engfunc(EngFunc_PointContents, %1)
/* stock fm_point_contents(const Float:point[3])
	return engfunc(EngFunc_PointContents, point) */

stock fm_trace_line(ignoreent, const Float:start[3], const Float:end[3], Float:ret[3]) {
	engfunc(EngFunc_TraceLine, start, end, ignoreent == -1 ? 1 : 0, ignoreent, 0);

	new ent = get_tr2(0, TR_pHit);
	get_tr2(0, TR_vecEndPos, ret);

	return pev_valid(ent) ? ent : 0;
}

stock fm_trace_hull(const Float:origin[3], hull, ignoredent = 0, ignoremonsters = 0) {
	new result = 0;
	engfunc(EngFunc_TraceHull, origin, origin, ignoremonsters, hull, ignoredent > 0 ? ignoredent : 0, 0);

	if (get_tr2(0, TR_StartSolid))
		result += 1;
	if (get_tr2(0, TR_AllSolid))
		result += 2;
	if (!get_tr2(0, TR_InOpen))
		result += 4;

	return result;
}

stock fm_trace_normal(ignoreent, const Float:start[3], const Float:end[3], Float:ret[3]) {
	engfunc(EngFunc_TraceLine, start, end, 0, ignoreent, 0);
	get_tr2(0, TR_vecPlaneNormal, ret);

	new Float:fraction;
	get_tr2(0, TR_flFraction, fraction);
	if (fraction >= 1.0)
		return 0;

	return 1;
}

// note that for CS planted C4 has a "grenade" classname as well
stock fm_get_grenade_id(id, model[], len, grenadeid = 0) {
	new ent = fm_find_ent_by_owner(grenadeid, "grenade", id);
	if (ent && len > 0)
		pev(ent, pev_model, model, len);

	return ent;
}

#define fm_halflife_time() get_gametime()
/* stock Float:fm_halflife_time()
	return get_gametime() */

#define fm_attach_view(%1,%2) engfunc(EngFunc_SetView, %1, %2)
/* stock fm_attach_view(index, entity)
	return engfunc(EngFunc_SetView, index, entity) */

stock fm_playback_event(flags, invoker, eventindex, Float:delay, const Float:origin[3], const Float:angles[3], Float:fparam1, Float:fparam2, iparam1, iparam2, bparam1, bparam2) {
	return engfunc(EngFunc_PlaybackEvent, flags, invoker, eventindex, delay, origin, angles, fparam1, fparam2, iparam1, iparam2, bparam1, bparam2);
}

#define fm_eng_get_string(%1,%2,%3) engfunc(EngFunc_SzFromIndex, %1, %2, %3)
/* stock fm_eng_get_string(istring, string[], len)
	return engfunc(EngFunc_SzFromIndex, istring, string, len) */


/* HLSDK functions */

// the dot product is performed in 2d, making the view cone infinitely tall
stock bool:fm_is_in_viewcone(index, const Float:point[3]) {
	new Float:angles[3];
	pev(index, pev_angles, angles);
	engfunc(EngFunc_MakeVectors, angles);
	global_get(glb_v_forward, angles);
	angles[2] = 0.0;

	new Float:origin[3], Float:diff[3], Float:norm[3];
	pev(index, pev_origin, origin);
	xs_vec_sub(point, origin, diff);
	diff[2] = 0.0;
	xs_vec_normalize(diff, norm);

	new Float:dot, Float:fov;
	dot = xs_vec_dot(norm, angles);
	pev(index, pev_fov, fov);
	if (dot >= floatcos(fov * M_PI / 360))
		return true;

	return false;
}

stock bool:fm_is_visible(index, const Float:point[3], ignoremonsters = 0) {
	new Float:start[3], Float:view_ofs[3];
	pev(index, pev_origin, start);
	pev(index, pev_view_ofs, view_ofs);
	xs_vec_add(start, view_ofs, start);

	engfunc(EngFunc_TraceLine, start, point, ignoremonsters, index, 0);

	new Float:fraction;
	get_tr2(0, TR_flFraction, fraction);
	if (fraction == 1.0)
		return true;

	return false;
}


/* Engine_stocks functions */

stock fm_fakedamage(victim, const classname[], Float:takedmgdamage, damagetype) {
	new class[] = "trigger_hurt";
	new entity = fm_create_entity(class);
	if (!entity)
		return 0;

	new value[16];
	float_to_str(takedmgdamage * 2, value, sizeof value - 1);
	fm_set_kvd(entity, "dmg", value, class);

	num_to_str(damagetype, value, sizeof value - 1);
	fm_set_kvd(entity, "damagetype", value, class);

	fm_set_kvd(entity, "origin", "8192 8192 8192", class);
	fm_DispatchSpawn(entity);

	set_pev(entity, pev_classname, classname);
	fm_fake_touch(entity, victim);
	fm_remove_entity(entity);

	return 1;
}

#define fm_find_ent(%1,%2) engfunc(EngFunc_FindEntityByString, %1, "classname", %2)
/* stock fm_find_ent(index, const classname[])
	return engfunc(EngFunc_FindEntityByString, index, "classname", classname) */

#define fm_get_user_button(%1) pev(%1, pev_button)
/* stock fm_get_user_button(index)
	return pev(index, pev_button) */

#define fm_get_user_oldbutton(%1) pev(%1, pev_oldbuttons)
/* stock fm_get_user_oldbutton(index)
	return pev(index, pev_oldbuttons) */

#define fm_get_entity_flags(%1) pev(%1, pev_flags)
/* stock fm_get_entity_flags(index)
	return pev(index, pev_flags) */

#define fm_get_entity_distance(%1,%2) floatround(fm_entity_range(%1, %2))
/* stock fm_get_entity_distance(ent1, ent2)
	return floatround(fm_entity_range(ent1, ent2)) */

#define fm_get_grenade(%1) fm_get_grenade_id(%1, "", 0)
/* stock fm_get_grenade(id)
	return fm_get_grenade_id(id, "", 0) */

// optimization idea by Orangutanz
stock fm_get_brush_entity_origin(index, Float:origin[3]) {
	new Float:mins[3], Float:maxs[3];

	pev(index, pev_origin, origin);
	pev(index, pev_mins, mins);
	pev(index, pev_maxs, maxs);

	origin[0] += (mins[0] + maxs[0]) * 0.5;
	origin[1] += (mins[1] + maxs[1]) * 0.5;
	origin[2] += (mins[2] + maxs[2]) * 0.5;

	return 1;
}

// based on v3x's port, upgraded version returns number of removed entities
stock fm_remove_entity_name(const classname[]) {
	new ent = -1, num = 0;
	while ((ent = fm_find_ent_by_class(ent, classname)))
		num += fm_remove_entity(ent);

	return num;
}

stock fm_ViewContents(id) {
	new origin[3], Float:Orig[3];
	get_user_origin(id, origin, 3);
	IVecFVec(origin, Orig);

	return fm_point_contents(Orig);
}

stock fm_get_speed(entity) {
	new Float:Vel[3];
	pev(entity, pev_velocity, Vel);

	return floatround(vector_length(Vel));
}

stock fm_set_rendering(entity, fx = kRenderFxNone, r = 255, g = 255, b = 255, render = kRenderNormal, amount = 16) {
	new Float:RenderColor[3];
	RenderColor[0] = float(r);
	RenderColor[1] = float(g);
	RenderColor[2] = float(b);

	set_pev(entity, pev_renderfx, fx);
	set_pev(entity, pev_rendercolor, RenderColor);
	set_pev(entity, pev_rendermode, render);
	set_pev(entity, pev_renderamt, float(amount));

	return 1;
}

stock fm_set_entity_flags(index, flag, onoff) {
	new flags = pev(index, pev_flags);
	if ((flags & flag) > 0)
		return onoff == 1 ? 2 : 1 + 0 * set_pev(index, pev_flags, flags - flag);
	else
		return onoff == 0 ? 2 : 1 + 0 * set_pev(index, pev_flags, flags + flag);

	return 0;
}

stock fm_set_entity_visibility(index, visible = 1) {
	set_pev(index, pev_effects, visible == 1 ? pev(index, pev_effects) & ~EF_NODRAW : pev(index, pev_effects) | EF_NODRAW);

	return 1;
}

#define fm_get_entity_visibility(%1) (!(pev(%1, pev_effects) & EF_NODRAW))
/* stock fm_get_entity_visibility(index)
	return !(pev(index, pev_effects) & EF_NODRAW) */

stock fm_set_user_velocity(entity, const Float:vector[3]) {
	set_pev(entity, pev_velocity, vector);

	return 1;
}

#define fm_get_user_velocity(%1,%2) pev(%1, pev_velocity, %2)
/* stock fm_get_user_velocity(entity, Float:vector[3])
	return pev(entity, pev_velocity, vector) */


/* Fun functions */

#define fm_get_client_listen(%1,%2) engfunc(EngFunc_GetClientListening, %1, %2)
/* stock fm_get_client_listen(receiver, sender)
	return engfunc(EngFunc_GetClientListening, receiver, sender) */

#define fm_set_client_listen(%1,%2,%3) engfunc(EngFunc_SetClientListening, %1, %2, %3)
/* stock fm_set_client_listen(receiver, sender, listen)
	return engfunc(EngFunc_SetClientListening, receiver, sender, listen) */

stock fm_get_user_godmode(index) {
	new Float:val;
	pev(index, pev_takedamage, val);

	return (val == DAMAGE_NO);
}

stock fm_set_user_godmode(index, godmode = 0) {
	set_pev(index, pev_takedamage, godmode == 1 ? DAMAGE_NO : DAMAGE_AIM);

	return 1;
}

stock fm_set_user_armor(index, armor) {
	set_pev(index, pev_armorvalue, float(armor));

	return 1;
}

stock fm_set_user_health(index, health) {
	health > 0 ? set_pev(index, pev_health, float(health)) : dllfunc(DLLFunc_ClientKill, index);

	return 1;
}

stock fm_set_user_origin(index, /* const */ origin[3]) {
	new Float:orig[3];
	IVecFVec(origin, orig);

	return fm_entity_set_origin(index, orig);
}

stock fm_set_user_rendering(index, fx = kRenderFxNone, r = 255, g = 255, b = 255, render = kRenderNormal, amount = 16) {
	return fm_set_rendering(index, fx, r, g, b, render, amount);
}

stock fm_give_item(index, const item[]) {
	if (!equal(item, "weapon_", 7) && !equal(item, "ammo_", 5) && !equal(item, "item_", 5) && !equal(item, "tf_weapon_", 10))
		return 0;

	new ent = fm_create_entity(item);
	if (!pev_valid(ent))
		return 0;

	new Float:origin[3];
	pev(index, pev_origin, origin);
	set_pev(ent, pev_origin, origin);
	set_pev(ent, pev_spawnflags, pev(ent, pev_spawnflags) | SF_NORESPAWN);
	dllfunc(DLLFunc_Spawn, ent);

	new save = pev(ent, pev_solid);
	dllfunc(DLLFunc_Touch, ent, index);
	if (pev(ent, pev_solid) != save)
		return ent;

	engfunc(EngFunc_RemoveEntity, ent);

	return -1;
}

stock fm_set_user_maxspeed(index, Float:speed = -1.0) {
	engfunc(EngFunc_SetClientMaxspeed, index, speed);
	set_pev(index, pev_maxspeed, speed);

	return 1;
}

stock Float:fm_get_user_maxspeed(index) {
	new Float:speed;
	pev(index, pev_maxspeed, speed);

	return speed;
}

stock fm_set_user_gravity(index, Float:gravity = 1.0) {
	set_pev(index, pev_gravity, gravity);

	return 1;
}

stock Float:fm_get_user_gravity(index) {
	new Float:gravity;
	pev(index, pev_gravity, gravity);

	return gravity;
}

/* interferes with FM_Spawn enum, just use fm_DispatchSpawn
stock fm_spawn(entity) {
	return dllfunc(DLLFunc_Spawn, entity)
}
*/

stock fm_set_user_noclip(index, noclip = 0) {
	set_pev(index, pev_movetype, noclip == 1 ? MOVETYPE_NOCLIP : MOVETYPE_WALK);

	return 1;
}

#define fm_get_user_noclip(%1) (pev(%1, pev_movetype) == MOVETYPE_NOCLIP)
/* stock fm_get_user_noclip(index)
	return (pev(index, pev_movetype) == MOVETYPE_NOCLIP) */

// note: get_user_weapon will still return former weapon index
stock fm_strip_user_weapons(index) {
	new ent = fm_create_entity("player_weaponstrip");
	if (!pev_valid(ent))
		return 0;

	dllfunc(DLLFunc_Spawn, ent);
	dllfunc(DLLFunc_Use, ent, index);
	engfunc(EngFunc_RemoveEntity, ent);

	return 1;
}

stock fm_set_user_frags(index, frags) {
	set_pev(index, pev_frags, float(frags));

	return 1;
}


/* Cstrike functions */

stock fm_cs_user_spawn(index) {
	set_pev(index, pev_deadflag, DEAD_RESPAWNABLE);
	dllfunc(DLLFunc_Spawn, index);
	set_pev(index, pev_iuser1, 0);

	return 1;
}


/* Custom functions */

// based on Basic-Master's set_keyvalue, upgraded version accepts an optional classname (a bit more efficient if it is passed)
stock fm_set_kvd(entity, const key[], const value[], const classname[] = "") {
	if (classname[0])
		set_kvd(0, KV_ClassName, classname);
	else {
		new class[32];
		pev(entity, pev_classname, class, sizeof class - 1);
		set_kvd(0, KV_ClassName, class);
	}

	set_kvd(0, KV_KeyName, key);
	set_kvd(0, KV_Value, value);
	set_kvd(0, KV_fHandled, 0);

	return dllfunc(DLLFunc_KeyValue, entity, 0);
}

stock fm_find_ent_by_integer(index, pev_field, value) {
	static maxents;
	if (!maxents)
		maxents = global_get(glb_maxEntities);

	for (new i = index + 1; i < maxents; ++i) {
		if (pev_valid(i) && pev(i, pev_field) == value)
			return i;
	}

	return 0;
}

stock fm_find_ent_by_flags(index, pev_field, flags) {
	static maxents;
	if (!maxents)
		maxents = global_get(glb_maxEntities);

	for (new i = index + 1; i < maxents; ++i) {
		if (pev_valid(i) && (pev(i, pev_field) & flags) == flags)
			return i;
	}

	return 0;
}

stock Float:fm_distance_to_box(const Float:point[3], const Float:mins[3], const Float:maxs[3]) {
	new Float:dist[3];
	for (new i = 0; i < 3; ++i) {
		if (point[i] > maxs[i])
			dist[i] = point[i] - maxs[i];
		else if (mins[i] > point[i])
			dist[i] = mins[i] - point[i];
	}

	return vector_length(dist);
}

stock Float:fm_boxes_distance(const Float:mins1[3], const Float:maxs1[3], const Float:mins2[3], const Float:maxs2[3]) {
	new Float:dist[3];
	for (new i = 0; i < 3; ++i) {
		if (mins1[i] > maxs2[i])
			dist[i] = mins1[i] - maxs2[i];
		else if (mins2[i] > maxs1[i])
			dist[i] = mins2[i] - maxs1[i];
	}

	return vector_length(dist);
}

stock Float:fm_distance_to_boxent(entity, boxent) {
	new Float:point[3];
	pev(entity, pev_origin, point);

	new Float:mins[3], Float:maxs[3];
	pev(boxent, pev_absmin, mins);
	pev(boxent, pev_absmax, maxs);

	return fm_distance_to_box(point, mins, maxs);
}

stock Float:fm_boxents_distance(boxent1, boxent2) {
	new Float:mins1[3], Float:maxs1[3];
	pev(boxent1, pev_absmin, mins1);
	pev(boxent1, pev_absmax, maxs1);

	new Float:mins2[3], Float:maxs2[3];
	pev(boxent2, pev_absmin, mins2);
	pev(boxent2, pev_absmax, maxs2);

	return fm_boxes_distance(mins1, maxs1, mins2, maxs2);
}

// projects a center of a player's feet base (originally by P34nut, improved)
stock Float:fm_distance_to_floor(index, ignoremonsters = 1) {
	new Float:start[3], Float:dest[3], Float:end[3];
	pev(index, pev_origin, start);
	dest[0] = start[0];
	dest[1] = start[1];
	dest[2] = -8191.0;

	engfunc(EngFunc_TraceLine, start, dest, ignoremonsters, index, 0);
	get_tr2(0, TR_vecEndPos, end);

	pev(index, pev_absmin, start);
	new Float:ret = start[2] - end[2];

	return ret > 0 ? ret : 0.0;
}

// potential to crash (?) if used on weaponbox+weapon_* entity pair (use fm_remove_weaponbox instead)
stock fm_kill_entity(index) {
	set_pev(index, pev_flags, pev(index, pev_flags) | FL_KILLME);

	return 1;
}

// if weapon index isn't passed then assuming that it's the current weapon
stock fm_get_user_weapon_entity(id, wid = 0) {
	new weap = wid, clip, ammo;
	if (!weap && !(weap = get_user_weapon(id, clip, ammo)))
		return 0;
	
	new class[32];
	get_weaponname(weap, class, sizeof class - 1);

	return fm_find_ent_by_owner(-1, class, id);
}

// only weapon index or its name can be passed, if neither is passed then the current gun will be stripped
stock bool:fm_strip_user_gun(index, wid = 0, const wname[] = "") {
	new ent_class[32];
	if (!wid && wname[0])
		copy(ent_class, sizeof ent_class - 1, wname);
	else {
		new weapon = wid, clip, ammo;
		if (!weapon && !(weapon = get_user_weapon(index, clip, ammo)))
			return false;
		
		get_weaponname(weapon, ent_class, sizeof ent_class - 1);
	}

	new ent_weap = fm_find_ent_by_owner(-1, ent_class, index);
	if (!ent_weap)
		return false;

	engclient_cmd(index, "drop", ent_class);

	new ent_box = pev(ent_weap, pev_owner);
	if (!ent_box || ent_box == index)
		return false;

	dllfunc(DLLFunc_Think, ent_box);

	return true;
}

// only weapon index or its name can be passed, if neither is passed then the current gun will be transferred
stock bool:fm_transfer_user_gun(index1, index2, wid = 0, const wname[] = "") {
	new ent_class[32];
	if (!wid && wname[0])
		copy(ent_class, sizeof ent_class - 1, wname);
	else {
		new weapon = wid, clip, ammo;
		if (!weapon && !(weapon = get_user_weapon(index1, clip, ammo)))
			return false;
		
		get_weaponname(weapon, ent_class, sizeof ent_class - 1);
	}

	new ent_weap = fm_find_ent_by_owner(-1, ent_class, index1);
	if (!ent_weap)
		return false;

	engclient_cmd(index1, "drop", ent_class);

	new ent_box = pev(ent_weap, pev_owner);
	if (!ent_box || ent_box == index1)
		return false;

	set_pev(ent_box, pev_flags, pev(ent_box, pev_flags) | FL_ONGROUND);
	dllfunc(DLLFunc_Touch, ent_box, index2);
	if (pev(ent_weap, pev_owner) != index2)
		return false;

	return true;
}

stock bool:fm_is_ent_visible(index, entity, ignoremonsters = 0) {
	new Float:start[3], Float:dest[3];
	pev(index, pev_origin, start);
	pev(index, pev_view_ofs, dest);
	xs_vec_add(start, dest, start);

	pev(entity, pev_origin, dest);
	engfunc(EngFunc_TraceLine, start, dest, ignoremonsters, index, 0);

	new Float:fraction;
	get_tr2(0, TR_flFraction, fraction);
	if (fraction == 1.0 || get_tr2(0, TR_pHit) == entity)
		return true;

	return false;
}

// ported from AMXX's core get_user_origin(..., 3) (suggested by Greenberet)
stock fm_get_aim_origin(index, Float:origin[3]) {
	new Float:start[3], Float:view_ofs[3];
	pev(index, pev_origin, start);
	pev(index, pev_view_ofs, view_ofs);
	xs_vec_add(start, view_ofs, start);

	new Float:dest[3];
	pev(index, pev_v_angle, dest);
	engfunc(EngFunc_MakeVectors, dest);
	global_get(glb_v_forward, dest);
	xs_vec_mul_scalar(dest, 9999.0, dest);
	xs_vec_add(start, dest, dest);

	engfunc(EngFunc_TraceLine, start, dest, 0, index, 0);
	get_tr2(0, TR_vecEndPos, origin);

	return 1;
}

stock bool:fm_get_user_longjump(index) {
	new value[2];
	engfunc(EngFunc_GetPhysicsKeyValue, index, "slj", value, 1);
	switch (value[0]) {
		case '1': return true;
	}

	return false;
}

stock fm_set_user_longjump(index, bool:longjump = true, bool:tempicon = true) {
	if (longjump == fm_get_user_longjump(index))
		return;

	if (longjump) {
		engfunc(EngFunc_SetPhysicsKeyValue, index, "slj", "1");
		if (tempicon) {
			static msgid_itempickup;
			if (!msgid_itempickup)
				msgid_itempickup = get_user_msgid("ItemPickup");

			message_begin(MSG_ONE, msgid_itempickup, _, index);
			write_string("item_longjump");
			message_end();
		}
	}
	else
		engfunc(EngFunc_SetPhysicsKeyValue, index, "slj", "0");
}

#define WEAPON_SUIT 31

stock bool:fm_get_user_suit(index) {
	return bool:(!(!(pev(index, pev_weapons) & (1<<WEAPON_SUIT)))); // i'm not insane, this is a trick!
}

stock fm_set_user_suit(index, bool:suit = true, bool:sound = true) {
	new weapons = pev(index, pev_weapons);
	if (!suit)
		set_pev(index, pev_weapons, weapons & ~(1<<WEAPON_SUIT));
	else if (!(weapons & (1<<WEAPON_SUIT))) {
		set_pev(index, pev_weapons, weapons | (1<<WEAPON_SUIT));
		if (sound)
			emit_sound(index, CHAN_VOICE, "items/tr_kevlar.wav", VOL_NORM, ATTN_NORM, 0, PITCH_NORM);
	}
}

#define FEV_RELIABLE (1<<1)
#define FEV_GLOBAL (1<<2)

// removes all created decals and players' corpses from the world
// set a specific index to remove decals only for the given client
stock fm_cs_remove_decals(index = 0) {
	static eventindex_decal_reset;
	if (!eventindex_decal_reset)
		eventindex_decal_reset = engfunc(EngFunc_PrecacheEvent, 1, "events/decal_reset.sc");

	new flags = FEV_RELIABLE;
	if (!index)
		flags |= FEV_GLOBAL;

	engfunc(EngFunc_PlaybackEvent, flags, index, eventindex_decal_reset, 0.0, Float:{0.0, 0.0, 0.0}, Float:{0.0, 0.0, 0.0}, 0.0, 0.0, 0, 0, 0, 0);
}

// checks whether the entity's classname is equal to the passed classname
stock bool:fm_is_ent_classname(index, const classname[]) {
	if (!pev_valid(index))
		return false;

	new class[32];
	pev(index, pev_classname, class, sizeof class - 1);
	if (equal(class, classname))
		return true;

	return false;
}

// the same as AMXX's core user_kill but fixes the issue when the scoreboard doesn't update immediately if flag is set to 1
stock fm_user_kill(index, flag = 0) {
	if (flag) {
		new Float:frags;
		pev(index, pev_frags, frags);
		set_pev(index, pev_frags, ++frags);
	}

	dllfunc(DLLFunc_ClientKill, index);

	return 1;
}

// returns a degree angle between player-to-point and player's view vectors
stock Float:fm_get_view_angle_diff(index, const Float:point[3]) {
	new Float:vec[3], Float:ofs[3], Float:aim[3];
	pev(index, pev_origin, vec);
	pev(index, pev_view_ofs, ofs);
	xs_vec_add(vec, ofs, vec);
	xs_vec_sub(point, vec, vec);
	xs_vec_normalize(vec, vec);

	pev(index, pev_v_angle, aim);
	engfunc(EngFunc_MakeVectors, aim);
	global_get(glb_v_forward, aim);

	return xs_vec_angle(vec, aim);
}

// gets a weapon type of the linked to weaponbox weapon_* entity
stock fm_get_weaponbox_type(entity) {
	static max_clients, max_entities;
	if (!max_clients)
		max_clients = global_get(glb_maxClients);
	if (!max_entities)
		max_entities = global_get(glb_maxEntities);

	for (new i = max_clients + 1; i < max_entities; ++i) {
		if (pev_valid(i) && entity == pev(i, pev_owner)) {
			new wname[32];
			pev(i, pev_classname, wname, sizeof wname - 1);
			return get_weaponid(wname);
		}
	}

	return 0;
}

// safe removal of weaponbox+weapon_* entity pair (delay =~= 0.03 second)
#define fm_remove_weaponbox(%1) dllfunc(DLLFunc_Think, %1)
/* stock fm_remove_weaponbox(entity)
	return dllfunc(DLLFunc_Think, entity) */
// vim: set ts=4 sw=4 tw=99 noet:
//
// AMX Mod X, based on AMX Mod by Aleksander Naszko ("OLO").
// Copyright (C) The AMX Mod X Development Team.
//
// This software is licensed under the GNU General Public License, version 3 or higher.
// Additional exceptions apply. For full license details, see LICENSE.txt or visit:
//     https://alliedmods.net/amxmodx-license

//
// File Functions
//

#if defined _file_included
  #endinput
#endif
#define _file_included

/* Reads content from directory.
* Returns index of next element or 0 when end of dir. is reached. */
native read_dir(const dirname[],pos,output[],len,&outlen);

/* Reads line from file. Returns index of next line or 0 when end of file is reached. */
native read_file(const file[],line,text[],len,&txtlen);

/* Writes text to file. Function returns 0 on failure.
* When line is set to -1, the text is added at the end of file. */
native write_file(const file[],const text[],line = -1);

/* Deletes file. Function returns 1 on success, 0 on failure. */
native delete_file(const file[]);

/* Checks for file. If file exists function returns 1, in other case 0. */
native file_exists(const file[]);

/* renames a file.  returns 0 on failure, 1 on success.
 * if relative true, rename_file will act like other natives which 
 * use the moddir as a base directory.  otherwise, the current directory is 
 * undefined (but assumed to be hlds).
 */
native rename_file(const oldname[], const newname[], relative=0);

/* Checks if a directory exists */
native dir_exists(const dir[]);

/* Returns a file size in bytes if flag is set to 0.
* When flag is set to 1 returns number of lines in the file,
* and when flags is 2, function returns 1 if the file ends
* with line feed. If file doesn't exist returns -1. */
native file_size(const file[], flag=0);

#define SEEK_SET 0
#define SEEK_CUR 1
#define SEEK_END 2

//Open a file, returns a handle or 0 on failure
native fopen(const filename[],const mode[]);

//Closes a file handle
native fclose(file);

#define BLOCK_INT	4
#define BLOCK_SHORT	2
#define BLOCK_CHAR	1
#define BLOCK_BYTE	1

//The following functions work as such:
// RAW - means the array you pass is a raw bytestream, for experts only
// BLOCK - means you are passing in an array where each element will be written
// NORMAL - means you are writing only one element
// RAW and BLOCK return the number of blocks acted upon successfully
// NORMAL returns 1 on success

native fread(file, &data, mode);
native fread_blocks(file, data[], blocks, mode);
native fread_raw(file, stream[], blocksize, blocks);
native fwrite(file, data, mode);
native fwrite_blocks(file, const data[], blocks, mode);
native fwrite_raw(file, const stream[], blocksize, mode);

//Returns 1 if the file is ended, 0 otherwise
native feof(file);

//Reads a line from a text file -- includes newline!
native fgets(file, buffer[], maxlength);

//Writes a line to a text file.  Returns # of characters written.
native fputs(file, const text[]);

//Writes a line to the file
native fprintf(file, const fmt[], any:...);

//Sets the current position in a file (see SEEK_ values above)
native fseek(file, position, start);

//Returns the current position in a file
native ftell(file);

//These are straight from the C standard.
native fgetc(file);
native fputc(file, data);
native fungetc(file, data);

//Return the size of a file
native filesize(const filename[], any:...);

//Attempts to remove a directory.
//Note that you cannot remove a directory that has files on most
// operating systems.
native rmdir(const path[]);

/* Returns 0 on success, like the POSIX specification */
native mkdir(const dirname[]);


//Delete a file (delete_file macro)
native unlink(const filename[]);

//Returns a handle to a directory
native open_dir(dir[], firstfile[], length);
native next_file(dirh, buffer[], length);
native close_dir(dirh);

/**
 * Loads a file using the LoadFileForMe engine function.
 *
 * The data is truncated if there is not enough space.  No null-terminator 
 * is applied; the data is the raw contents of the file.
 *
 * @param file			File to load (may be a file from the GCF).
 * @param buffer		Buffer to store file contents.
 * @param maxlength		Maximum size of the file buffer.
 * @param length		Variable to store the file length.  This may return 
 *						a number larger than the buffer size.
 * @return				-1 if the file could not be loaded.  Otherwise, 
 *						the number of cells actually written to the buffer 
 *						are returned.
 */
native LoadFileForMe(const file[], buffer[], maxlength, &length=0);

/**
 * Flushes a buffered output stream.
 *
 * @param file			File handle, or 0 for all open streams.
 * @return				0 on success, -1 on failure.
 */
native fflush(file);

enum FileTimeType
{
	FileTime_LastAccess,    /* Last access (not available on FAT) */
	FileTime_Created,       /* Creation (not available on FAT) */
	FileTime_LastChange,    /* Last modification */
};

/**
 * Returns a file timestamp as a unix timestamp.
 *
 * @param file          File name.
 * @param tmode         Time mode. See FileTime_* constants.
 * @return              Returns a file timestamp as a unix timestamp.
 */
native GetFileTime( const file[], FileTimeType:tmode );
/* Float arithmetic
*
* (c) Copyright 1999, Artran, Inc.
*  Written by Greg Garner (gmg@artran.com)
*  Modified in March 2001 to include user defined
*  operators for the floating point functions.
*
* This file is provided as is (no warranties).
*/

#if defined _float_included
  #endinput
#endif
#define _float_included

/* Different methods of rounding */
enum floatround_method {
	floatround_round = 0,
	floatround_floor,
	floatround_ceil,
	floatround_tozero
};

enum anglemode {
	radian = 0,
	degrees,
	grades
};

/* Convert an integer into a floating point value */
native Float:float(value);

/* Convert a string into a floating point value */
native Float:floatstr(const string[]);

/* Multiple two floats together */
native Float:floatmul(Float:oper1, Float:oper2);

/* Divide the dividend float by the divisor float */
native Float:floatdiv(Float:dividend, Float:divisor);

/* Add two floats together */
native Float:floatadd(Float:dividend, Float:divisor);

/* Subtract oper2 float from oper1 float */
native Float:floatsub(Float:oper1, Float:oper2);

/* Return the fractional part of a float */
native Float:floatfract(Float:value);

/* Round a float into a integer value */
native floatround(Float:value, floatround_method:method=floatround_round);

/* Compare two integers. If the two elements are equal, return 0.
* If the first argument is greater than the second argument, return 1,
* If the first argument is less than the second argument, return -1. */
native floatcmp(Float:fOne, Float:fTwo);

/* Return the square root of the input value, same as floatpower(value, 0.5) */
native Float:floatsqroot(Float:value);

/* Return the value raised to the power of the exponent */
native Float:floatpower(Float:value, Float:exponent);

/* Return the logarithm */
native Float:floatlog(Float:value, Float:base=10.0);

/* Return the sine, cosine or tangent.
 * The input angle may be in radians, degrees or grades. */
native Float:floatsin(Float:value, anglemode:mode=radian);
native Float:floatcos(Float:value, anglemode:mode=radian);
native Float:floattan(Float:value, anglemode:mode=radian);

/* Return the hyperbolic sine, cosine or tangent.
 * The input angle may be in radians, degrees or grades. */
native Float:floatsinh(Float:angle, anglemode:mode=radian);
native Float:floatcosh(Float:angle, anglemode:mode=radian);
native Float:floattanh(Float:angle, anglemode:mode=radian);

/* Return the absolute value */
native Float:floatabs(Float:value);

/* Return the angle of a sine, cosine or tangent.
 * The output angle may be in radians, degrees, or grades. */
native Float:floatatan(Float:angle, {anglemode,_}:radix);
native Float:floatacos(Float:angle, {anglemode,_}:radix);
native Float:floatasin(Float:angle, {anglemode,_}:radix);
native Float:floatatan2(Float:x, Float:y, {anglemode,_}:radix);

#pragma rational Float

/* user defined operators */
native Float:operator*(Float:oper1, Float:oper2) = floatmul;
native Float:operator/(Float:oper1, Float:oper2) = floatdiv;
native Float:operator+(Float:oper1, Float:oper2) = floatadd;
native Float:operator-(Float:oper1, Float:oper2) = floatsub;

stock Float:operator++(Float:oper)
	return oper+1.0;

stock Float:operator--(Float:oper)
	return oper-1.0;

stock Float:operator-(Float:oper)
    return oper^Float:cellmin; /* IEEE values are sign/magnitude */

stock Float:operator*(Float:oper1, oper2)
	return floatmul(oper1, float(oper2)); /* "*" is commutative */

stock Float:operator/(Float:oper1, oper2)
	return floatdiv(oper1, float(oper2));

stock Float:operator/(oper1, Float:oper2)
	return floatdiv(float(oper1), oper2);

stock Float:operator+(Float:oper1, oper2)
	return floatadd(oper1, float(oper2)); /* "+" is commutative */

stock Float:operator-(Float:oper1, oper2)
	return floatsub(oper1, float(oper2));

stock Float:operator-(oper1, Float:oper2)
	return floatsub(float(oper1), oper2);

stock bool:operator==(Float:oper1, Float:oper2)
	return floatcmp(oper1, oper2) == 0;

stock bool:operator==(Float:oper1, oper2)
	return floatcmp(oper1, float(oper2)) == 0; /* "==" is commutative */

stock bool:operator!=(Float:oper1, Float:oper2)
	return floatcmp(oper1, oper2) != 0;

stock bool:operator!=(Float:oper1, oper2)
	return floatcmp(oper1, float(oper2)) != 0; /* "==" is commutative */

stock bool:operator>(Float:oper1, Float:oper2)
	return floatcmp(oper1, oper2) > 0;

stock bool:operator>(Float:oper1, oper2)
	return floatcmp(oper1, float(oper2)) > 0;

stock bool:operator>(oper1, Float:oper2)
	return floatcmp(float(oper1), oper2) > 0;

stock bool:operator>=(Float:oper1, Float:oper2)
	return floatcmp(oper1, oper2) >= 0;

stock bool:operator>=(Float:oper1, oper2)
	return floatcmp(oper1, float(oper2)) >= 0;

stock bool:operator>=(oper1, Float:oper2)
	return floatcmp(float(oper1), oper2) >= 0;

stock bool:operator<(Float:oper1, Float:oper2)
	return floatcmp(oper1, oper2) < 0;

stock bool:operator<(Float:oper1, oper2)
	return floatcmp(oper1, float(oper2)) < 0;

stock bool:operator<(oper1, Float:oper2)
	return floatcmp(float(oper1), oper2) < 0;

stock bool:operator<=(Float:oper1, Float:oper2)
	return floatcmp(oper1, oper2) <= 0;

stock bool:operator<=(Float:oper1, oper2)
	return floatcmp(oper1, float(oper2)) <= 0;

stock bool:operator<=(oper1, Float:oper2)
	return floatcmp(float(oper1), oper2) <= 0;

stock bool:operator!(Float:oper)
	return (_:oper & ((-1)/2)) == 0;		/* -1 = all bits to 1; /2 = remove most significant bit (sign)
							works on both 32bit and 64bit systems; no constant required */
/* forbidden operations */
forward operator%(Float:oper1, Float:oper2);
forward operator%(Float:oper1, oper2);
forward operator%(oper1, Float:oper2);


stock Float:floatmin(Float:ValueA, Float:ValueB)
{
	if (ValueA<=ValueB)
	{
		return ValueA;
	}
	
	return ValueB;
}

stock Float:floatmax(Float:ValueA, Float:ValueB)
{
	if (ValueA>=ValueB)
	{
		return ValueA;
	}
	
	return ValueB;
}
stock Float:floatclamp(Float:Value, Float:MinValue, Float:MaxValue)
{
	if (Value<=MinValue)
	{
		return MinValue;
	}
	if (Value>=MaxValue)
	{
		return MaxValue;
	}
	
	return Value;
}
// vim: set ts=4 sw=4 tw=99 noet:
//
// AMX Mod X, based on AMX Mod by Aleksander Naszko ("OLO").
// Copyright (C) The AMX Mod X Development Team.
//
// This software is licensed under the GNU General Public License, version 3 or higher.
// Additional exceptions apply. For full license details, see LICENSE.txt or visit:
//     https://alliedmods.net/amxmodx-license

//
// Fun Functions
//

#if defined _fun_included
  #endinput
#endif
#define _fun_included

#if AMXX_VERSION_NUM >= 175
 #pragma reqlib fun
 #if !defined AMXMODX_NOAUTOLOAD
  #pragma loadlib fun
 #endif
#else
 #pragma library fun
#endif

/* Returns 1 if receiver hears sender via voice communication. */
native get_client_listen(receiver, sender);

/* Sets who can listen who. Function returns 0
* if for some reasons this setting can't be done. */
native set_client_listen(receiver, sender, listen);

/* Sets player godmode. If you want to disable godmode set only first parameter. */
native set_user_godmode(index, godmode = 0);

/* Returns 1 if godmode is set. */
native get_user_godmode(index);

/* Sets player armor. */
native set_user_armor(index, armor);

/* Sets player health. */
native set_user_health(index, health);

/* Move player to origin. */
native set_user_origin(index, const origin[3]);

/* Sets player rendering mode. */
native set_user_rendering(index, fx = kRenderFxNone, r = 0, g = 0, b = 0, render = kRenderNormal, amount = 0);

/* Gives item to player, name of item can start
 * with weapon_, ammo_ and item_. This event
 * is announced with proper message to all players. */
native give_item(index, const item[]);

/* Sets hit zones for player.
 * Parts of body are as bits:
 * 1   - generic
 * 2   - head
 * 4   - chest
 * 8   - stomach
 * 16  - left arm
 * 32  - right arm
 * 64  - left leg
 * 128 - right leg */
native set_user_hitzones(index = 0, target = 0, body = 255);

/* Get user hitzones. */
native get_user_hitzones(index, target);

/* Sets users max. speed. */
native set_user_maxspeed(index, Float:speed = -1.0);

/* Returns users max. speed. */
native Float:get_user_maxspeed(index);

/* Sets users gravity. */
native set_user_gravity(index, Float:gravity = 1.0);

/* Returns users gravity. */
native Float:get_user_gravity(index);

/* Spawns entity. */
native spawn(index);

/* Sets player noclip. If you want to disable noclip set only first parameter. */
native set_user_noclip(index, noclip = 0);

/* Returns 1 if noclip is set. */
native get_user_noclip(index);

/* Returns 1 if player has silent footsteps, 0 if footsteps are set to normal */
native get_user_footsteps(index);

/* Gives player silent footsteps.
* if set = 0 it will return footsteps to normal */
native set_user_footsteps(id, set = 1);

/* Strips all weapons from user. */
native strip_user_weapons(index);

/* Sets player frags. */
native set_user_frags(index, frags);
// vim: set ts=4 sw=4 tw=99 noet:
//
// AMX Mod X, based on AMX Mod by Aleksander Naszko ("OLO").
// Copyright (C) The AMX Mod X Development Team.
//
// This software is licensed under the GNU General Public License, version 3 or higher.
// Additional exceptions apply. For full license details, see LICENSE.txt or visit:
//     https://alliedmods.net/amxmodx-license

//
// GeoIP Module Functions
//

#if defined geoip_included
	#endinput
#endif
#define _geoip_included

#if AMXX_VERSION_NUM >= 175
	#pragma reqlib geoip
	#if !defined AMXMODX_NOAUTOLOAD
		#pragma loadlib geoip
	#endif
#else
	#pragma library geoip
#endif

/**
 * @global  IP addresses passed to these natives can contain ports, the ports will be ignored.
 */

/**
 * Look up the two character country code for a given IP address.
 * e.g: "US", "CA", etc.
 *
 * @param ip        The IP address to lookup.
 * @param result    The result buffer.  If the lookup does not succeed, the buffer is not modified.
 *
 * @return          true on a successful lookup, false on a failed lookup.
 */
native bool:geoip_code2_ex(const ip[], result[3]);

/**
 * Look up the three character country code for a given IP address.
 * e.g: "USA", "cAN", etc.
 *
 * @param ip        The IP address to lookup.
 * @param result    The result buffer.  If the lookup does not succeed, the buffer is not modified.
 *
 * @return          true on a successful lookup, false on a failed lookup.
 */
native bool:geoip_code3_ex(const ip[], result[4]);

/**
 * Lookup the two character country code for a given IP address.
 *
 * @deprecated  This native will overflow the buffer by one cell on an unknown ip lookup!
 *              Use geoip_code2_ex instead.
 *
 * @param ip        The IP address to lookup.
 * @param result    The result buffer.
 *
 * @return          1 on a successful lookup, 0 otherwise.
 */
//#pragma deprecated Use geoip_code2_ex() instead.
native geoip_code2(const ip[], ccode[3]);

/**
 * Lookup the three character country code for a given IP address.
 *
 * @deprecated  This native will overflow the buffer by one cell on an unknown ip lookup!
 *              Use geoip_code3_ex instead.
 *
 * @param ip        The IP address to lookup.
 * @param result    The result buffer.
 *
 * @return          1 on a successful lookup, 0 otherwise.
 */
//#pragma deprecated Use geoip_code3() instead.
native geoip_code3(const ip[], result[4]);

/**
 * Lookup the full country name for the given IP address.  Sets the buffer to "error" on
 * an unsuccessful lookup.
 *
 * @param ip        The IP address to lookup.
 * @param result    The result of the geoip lookup.
 * @param len       The maximum length of the result buffer.
 * @param id        An optional player's index in order to return the result
 *                  in the player's language, if supported.
 *                  -1: the default language, which is english.
 *                   0: the server language. You can use LANG_SERVER define.
 *                 >=1: the player's language.
 *
 * @return          The result length on successful lookup, 0 otherwise.
 */
native geoip_country(const ip[], result[], len = 45, id = -1);


/**
 * Look up the full city name for the given IP address.
 *
 * @note  This native requires GeoIP City database, which can be retrieved from:
 *        http://dev.maxmind.com/geoip/geoip2/geolite2/ (MaxMind DB binary)
 *
 * @param ip        The IP address to look up.
 * @param result    The result of the geoip look up.
 * @param len       The maximum length of the result buffer.
 * @param id        An optional player's index in order to return the result
 *                  in the player's language, if supported.
 *                  -1: the default language, which is english.
 *                   0: the server language. You can use LANG_SERVER define.
 *                 >=1: the player's language.
 *
 * @return          The result length on successful lookup, 0 otherwise.
 */
native geoip_city(const ip[], result[], len, id = -1);

/**
 * Look up the region/state code for the given IP address.
 * e.g. "US-OH", "DE-HH", IT-82, "FR-U", etc.
 *
 * @note  This native requires GeoIP City database, which can be retrieved from:
 *        http://dev.maxmind.com/geoip/geoip2/geolite2/ (MaxMind DB binary)
 *
 * @param ip        The IP address to look up.
 * @param result    The result of the geoip look up.
 * @param len       The maximum length of the result buffer.
 *
 * @return          The result length on successful lookup, 0 otherwise.
 */
native geoip_region_code(const ip[], result[], len);

/**
 * Look up the full region/state name for the given IP address.
 *
 * @note  This native requires GeoIP City database, which can be retrieved from:
 *        http://dev.maxmind.com/geoip/geoip2/geolite2/ (MaxMind DB binary)
 *
 * @param ip        The IP address to look up.
 * @param result    The result of the geoip look up.
 * @param len       The maximum length of the result buffer.
 * @param id        An optional player's index in order to return the result
 *                  in the player's language, if supported.
 *                  -1: the default language, which is english.
 *                   0: the server language. You can use LANG_SERVER define.
 *                 >=1: the player's language.
 *
 * @return          The result length on successful lookup, 0 otherwise.
 */
native geoip_region_name(const ip[], result[], len, id = -1);

/**
 * Look up the full time zone for the given IP address.
 * e.g. America/Los_Angeles, Europe/Paris.
 *
 * @note  This native requires GeoIP City database, which can be retrieved from:
 *        http://dev.maxmind.com/geoip/geoip2/geolite2/ (MaxMind DB binary)
 *
 * @param ip        The IP address to look up.
 * @param result    The result of the geoip look up.
 * @param len       The maximum length of the result buffer.
 *
 * @return          The result length on successful lookup, 0 otherwise.
 */
native geoip_timezone(const ip[], result[], len);

/**
 * Look up the city's latitude for the given IP address.
 *
 * @note  This native requires GeoIP City database, which can be retrieved from:
 *        http://dev.maxmind.com/geoip/geoip2/geolite2/ (MaxMind DB binary)
 *
 * @param ip        The IP address to look up.
 *
 * @return          The result of the geoip look up, 0 if latitude is not found.
 */
native Float:geoip_latitude(const ip[]);

/**
 * Look up the city's longitude for the given IP address.
 *
 * @note  This native requires GeoIP City database, which can be retrieved from:
 *        http://dev.maxmind.com/geoip/geoip2/geolite2/ (MaxMind DB binary)
 *
 * @param ip        The IP address to look up.
 *
 * @return          The result of the geoip look up, 0 if longitude is not found.
 */
native Float:geoip_longitude(const ip[]);

/**
 * Calculate the distance between geographical coordinates, latitude and longitude.
 *
 * @note  This native requires GeoIP City database, which can be retrieved from:
 *        http://dev.maxmind.com/geoip/geoip2/geolite2/ (MaxMind DB binary)
 *
 * @param lat1      The first IP latitude.
 * @param lon1      The first IP longitude.
 * @param lat2      The second IP latitude.
 * @param lon2      The second IP longitude.
 * @param system    The system of measurement, 0 = Metric(kilometers) or 1 = English(miles).
 *
 * @return          The distance as result in specified system of measurement.
 */
#define SYSTEM_METRIC   0 // kilometers
#define SYSTEM_IMPERIAL 1 // statute miles

native Float:geoip_distance(Float:lat1, Float:lon1, Float:lat2, Float:lon2, system = SYSTEM_METRIC);

/**
 * Look up the continent code for a given IP address.
 *
 * @note  This native requires GeoIP City database, which can be retrieved from:
 *        http://dev.maxmind.com/geoip/geoip2/geolite2/ (MaxMind DB binary)
 * @note  The code can be retrieved as integer (See CONTINENT_* constants.) or string (2 characters).
 * @note  Possible continent codes are AF, AN, AS, EU, NA, OC, SA for
 *        Africa(1), Antarctica(2), Asia(3), Europe(4), North America(5), Oceania(6), South America(7).
 *
 * @param ip        The IP address to look up.
 * @param result    The result of the geoip look up.
 *
 * @return          The continent id on successful lookup, 0 otherwise.
 */
enum Continent
{
	CONTINENT_UNKNOWN = 0,
	CONTINENT_AFRICA,
	CONTINENT_ANTARCTICA,
	CONTINENT_ASIA,
	CONTINENT_EUROPE,
	CONTINENT_NORTH_AMERICA,
	CONTINENT_OCEANIA,
	CONTINENT_SOUTH_AMERICA,
};
native Continent:geoip_continent_code(const ip[], result[3]);

/**
 * Look up the full continent name for the given IP address.
 *
 * @note  This native requires GeoIP City database, which can be retrieved from:
 *        http://dev.maxmind.com/geoip/geoip2/geolite2/ (MaxMind DB binary)
 *
 * @param ip        The IP address to look up.
 * @param result    The result of the geoip look up.
 * @param len       The maximum length of the result buffer.
 * @param id        An optional player's index in order to return the result
 *                  in the player's language, if supported.
 *                  -1: the default language, which is english.
 *                   0: the server language. You can use LANG_SERVER define.
 *                 >=1: the player's language.
 *
 * @return          The result length on successful lookup, 0 otherwise.
 */
native geoip_continent_name(const ip[], result[], len, id = -1);
// vim: set ts=4 sw=4 tw=99 noet:
//
// AMX Mod X, based on AMX Mod by Aleksander Naszko ("OLO").
// Copyright (C) The AMX Mod X Development Team.
//
// This software is licensed under the GNU General Public License, version 3 or higher.
// Additional exceptions apply. For full license details, see LICENSE.txt or visit:
//     https://alliedmods.net/amxmodx-license

//
// Ham Sandwich Constants
//

#if defined _ham_const_included
	#endinput
#endif
#define _ham_const_included

/**
 * Ham return types.
 *
 * @note Return these from hooks to disable calling the target function.
 *       Numbers match up with fakemeta's FMRES_* for clarity. They are
 *       interchangable. 0 (or no return) is also interpretted as HAM_IGNORED.
 */
#define HAM_IGNORED		1	/**< Calls target function, returns normal value */
#define HAM_HANDLED		2	/**< Tells the module you did something, still calls target function and returns normal value */
#define HAM_OVERRIDE	3	/**< Still calls the target function, but returns whatever is set with SetHamReturn*() */
#define HAM_SUPERCEDE	4	/**< Block the target call, and use your return value (if applicable) (Set with SetHamReturn*()) */

/**
 * List of virtual functions made available through the hamsandwich module.
 *
 * @note Not all functions will do as you expect on all mods. If a function does
 *       not do what you would believe it should DO NOT file a bug report, you
 *       will be ignored.
 * @note Passing invalid parameters has potential to crash the server, so be
 *       careful, and test carefully and adequately!
 * @note All functions take (and pass) a "this" index as the first param.
 *       This is the entity from which the function is being executed on.
 * @note All functions and forwards (eg: {Register,Execute}Ham[B]) require
 *       the mod to have the pev and base keys in addition to the function
 *       keys for the corresponding mod/operating system in hamdata.ini
 * @note Some functions that return booleans may need to be logically ANDed
 *       to get the desired results because the mod will return the full integer
 *       value. E.g.: (ExecuteHam(Ham_TS_IsObjective, this) & 0x0000FFFF) != 0
 */

enum Ham
{
	/**
	 * Description:		This is typically called whenever an entity is created.
	 *					It is the virtual equivilent of spawn from the engine.
	 *					Some mods call this on player spawns too.
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_Spawn, this);
	 */
	Ham_Spawn = 0,

	/**
	 * Description:		This is typically called on map change.
	 *					This will typically precache all assets required by the entity.
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_Precache, this);
	 */
	Ham_Precache,

	/**
	 * Description:		Typically this is similar to an engine keyvalue call.
	 *					Use the kvd natives from fakemeta to handle the kvd_handle passed.
	 *					NOTE: Do not pass handle 0 to this! Use get_kvd_handle(0) from fakemeta instead!
	 * Forward params:	function(this, kvd_handle);
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_Keyvalue, this, kvd_handle);
	 */
	Ham_Keyvalue,

	/**
	 * Description:		Returns flags for how an entity can be used.
	 * Forward params:	function(this)
	 * Return type:		Integer (FCAP_* constants, see hlsdk_const.inc).
	 * Execute params:	ExecuteHam(Ham_ObjectCaps, this);
	 */
	Ham_ObjectCaps,

	/**
	 * Description:		Usually called to activate some objects.
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_Activate, this);
	 */
	Ham_Activate,

	/**
	 * Description:		Usually called after the engine call with the same name.
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_SetObjectCollisionBox, this);
	 */
	Ham_SetObjectCollisionBox,

	/**
	 * Description:		Returns an integer number that corresponds with what type of entity this is.
	 * Forward params:	function(this)
	 * Return type:		Integer.
	 * Execute params:	ExecuteHam(Ham_Classify, this);
	 */
	Ham_Classify,

	/**
	 * Description:		Typically called when an entity dies to notify any children entities about the death.
	 * Forward params:	function(this, idchild)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_DeathNotice, this, idchild)
	 */
	Ham_DeathNotice,

	/**
	 * Description:		Usually called whenever an entity gets attacked by a hitscan (such as a gun) weapon.
	 *					Use the get/set tr2 natives in fakemeta to handle the traceresult data.
	 *					Do not use a handle of 0 as a traceresult in execution, use create_tr2() from Fakemeta
	 *					to pass a custom handle instead.  (Don't forget to free the handle when you're done.)
	 * Forward params:	function(this, idattacker, Float:damage, Float:direction[3], traceresult, damagebits)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_TraceAttack, this, idattacker, Float:damage, Float:direction[3], tracehandle, damagebits);
	 */
	Ham_TraceAttack,

	/**
	 * Description:		Usually called whenever an entity takes any kind of damage.
	 *					Inflictor is the entity that caused the damage (such as a gun).
	 *					Attacker is the entity that tirggered the damage (such as the gun's owner).
	 * Forward params:	function(this, idinflictor, idattacker, Float:damage, damagebits);
	 * Return type:		Integer.
	 * Execute params:	ExecuteHam(Ham_TakeDamage, this, idinflictor, idattacker, Float:damage, damagebits);
	 */
	Ham_TakeDamage,

	/**
	 * Description:		Usually called whenever an entity gets a form of a heal.
	 * Forward params:	function(this, Float:health, damagebits);
	 * Return type:		Integer.
	 * Execute params:	ExecuteHam(Ham_TakeHealth, this, Float:health, damagebits);
	 */
	Ham_TakeHealth,

	/**
	 * Description:		Normally called whenever an entity dies.
	 *					For Team Fortress Classic mod, see Ham_TFC_Killed.
	 * Forward params:	function(this, idattacker, shouldgib)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_Killed, this, idattacker, shouldgib);
	 */
	Ham_Killed,

	/**
	 * Description:		Normally returns the blood color of the entity.
	 * Forward params:	function(this)
	 * Return type:		Integer.
	 * Execute params:	ExecuteHam(Ham_BloodColor, this)
	 */
	Ham_BloodColor,

	/**
	 * Description:		Traces where blood should appear.
	 * Forward params:	function(this, Float:Damage, Float:Direction[3], trace_handle, damagebits);
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_TraceBleed, this, Float:damage, Float:direction[3], trace_handle, damagebits);
	 */
	Ham_TraceBleed,

	/**
	 * Description:		Returns whether an entity is activated.
	 *					This function is not supported by Day Of Defeat.
	 *					This function has different version for Team Fortress Classic, see Ham_TFC_IsTriggered instead.
	 * Forward params:	function(this, idActivator);
	 * Return type:		Integer.
	 * Execute params:	ExecuteHam(Ham_IsTriggered, this, idActivator);
	 */
	Ham_IsTriggered,

	/**
	 * Description:		Returns the id of the entity if its class is derived off of CBaseMonster, -1 otherwise.
	 * Forward params:	function(this)
	 * Return type:		Entity.
	 * Execute params:	ExecuteHam(Ham_MyMonsterPointer, this);
	 */
	Ham_MyMonsterPointer,

	/**
	 * Description:		Returns the id of the entity if its class is derived off of CBaseSquadMonster, -1 otherwise.
	 * Forward params:	function(this)
	 * Return type:		Entity.
	 * Execute params:	ExecuteHam(Ham_MySquadMonsterPointer, this);
	 */
	Ham_MySquadMonsterPointer,

	/**
	 * Description:		Returns the toggle state of the entity.
	 * Forward params:	function(this)
	 * Return type:		Integer.
	 * Execute params:	ExecuteHam(Ham_GetToggleState, this);
	 */
	Ham_GetToggleState,

	/**
	 * Description:		Typically adds points to the entity.
	 *					This function is not supported by Team Fortress Classic mod.
	 * Forward params:	function(this, points, bool:cangonegative);
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_AddPoints, this, points, bool:cangonegative);
	 */
	Ham_AddPoints,

	/**
	 * Description:		Typically adds points to everybody on the entity's team.
	 *					This function is not supported by Team Fortress Classic mod.
	 * Forward params:	function(this, points, bool:cangonegative);
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_AddPointsToTeam, this, points, bool:cangonegative);
	 */
	Ham_AddPointsToTeam,

	/**
	 * Description:		Adds an item to the player's inventory.
	 * Forward params:	function(this, idother);
	 * Return type:		Integer.
	 * Execute params:	ExecuteHam(Ham_AddPlayerItem, this, idother);
	 */
	Ham_AddPlayerItem,

	/**
	 * Description:		Removes an item to the player's inventory.
	 * Forward params:	function(this, idother);
	 * Return type:		Integer.
	 * Execute params:	ExecuteHam(Ham_RemovePlayerItem, this, idother);
	 */
	Ham_RemovePlayerItem,

	/**
	 * Description:		Gives ammo to the entity.
	 *					This function is not supported for the following mods:
	 *						Earth's Special Forces.
	 *						Sven-Coop 4.8+, see Ham_SC_GiveAmmo instead.
	 *						Team Fortress Classic, see Ham_TFC_GiveAmmo instead.
	 * Forward params:	function(this, Amount, const Name[], Max)
	 * Return type:		Integer.
	 * Execute params:	ExecuteHam(Ham_GiveAmmo, this, amount, "type", max);
	 */
	Ham_GiveAmmo,

	/**
	 * Description:		Unsure, I believe this is the delay between activation for an entity.
	 * Forward params:	function(this)
	 * Return type:		Float.
	 * Execute params:	ExecuteHam(Ham_GetDelay, this, Float:output)
	 */
	Ham_GetDelay,

	/**
	 * Description:		Whether or not the entity is moving.
	 * Forward params:	function(this);
	 * Return type:		Integer.
	 * Execute params:	ExecuteHam(Ham_IsMoving, this);
	 */
	Ham_IsMoving,

	/**
	 * Description:		Unsure.
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_OverrideReset, this)
	 */
	Ham_OverrideReset,

	/**
	 * Description:		Returns the damage decal of the entity for the damage type.
	 * Forward params:	function(this, damagebits)
	 * Return type:		Integer.
	 * Execute params:	ExecuteHam(Ham_DamageDecal, this);
	 */
	Ham_DamageDecal,

	/**
	 * Description:		Sets the toggle state of the entity.
	 * Forward params:	function(this, state)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_SetToggleState, this, state);
	 */
	Ham_SetToggleState,

	/**
	 * Description:		Not entirely sure what this does.
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_StartSneaking, this);
	 */
	Ham_StartSneaking,

	/**
	 * Description:		Not entirely sure what this does.
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_StopSneaking, this);
	 */
	Ham_StopSneaking,

	/**
	 * Description:		Not entirely sure.
	 * Forward params:	function(this, idOn)
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_OnControls, this, idOn);
	 */
	Ham_OnControls,

	/**
	 * Description:		Whether or not the entity is sneaking.
	 * Forward params:	function(this);
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_IsSneaking, this);
	 */
	Ham_IsSneaking,

	/**
	 * Description:		Whether or not the entity is alive.
	 * Forward params:	function(this);
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_IsAlive, this);
	 */
	Ham_IsAlive,

	/**
	 * Description:		Whether or not the entity uses a BSP model.
	 * Forward params:	function(this);
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_IsBSPModel, this);
	 */
	Ham_IsBSPModel,

	/**
	 * Description:		Whether or not the entity can reflect gauss shots..
	 * Forward params:	function(this);
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_ReflectGauss, this);
	 */
	Ham_ReflectGauss,

	/**
	 * Description:		Whether or not the target is the same as the one passed.
	 *					Note the strindex parameter is a string passed that has been allocated by the engine.
	 *					Use fakemeta's EngFunc_SzFromIndex to convert to a normal string, or fakemeta's
	 *					EngFunc_AllocString to create a new string.
	 * Forward params:	function(this, strindex).
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_HasTarget, this, strindex);
	 */
	Ham_HasTarget,

	/**
	 * Description:		Whether or not the entity is in the world.
	 * Forward params:	function(this);
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_IsInWorld, this);
	 */
	Ham_IsInWorld,

	/**
	 * Description:		Whether or not the entity is a player.
	 * Forward params:	function(this);
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_IsPlayer, this);
	 */
	Ham_IsPlayer,

	/**
	 * Description:		Whether or not the entity is a net client.
	 * Forward params:	function(this);
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_IsNetClient, this);
	 */
	Ham_IsNetClient,

	/**
	 * Description:		Get the entity's team id.
	 *					This function is not supported by Team Fortress Classic mod.
	 * Forward params:	function(this);
	 * Return type:		String (string length returned and string byref'd in ExecuteHam).
	 * Execute params:	ExecuteHam(Ham_TeamId, this, buffer[], size);
	 */
	Ham_TeamId,

	/**
	 * Description:		Returns the next target of this.
	 * Forward params:	function(this);
	 * Return type:		Entity.
	 * Execute params:	ExecuteHam(Ham_GetNextTarget, this);
	 */
	Ham_GetNextTarget,

	/**
	 * Description:		Called whenever an entity thinks.
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_Think, this);
	 */
	Ham_Think,

	/**
	 * Description:		Called whenever two entities touch.
	 * Forward params:	function(this, idother);
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_Touch, this, idother);
	 */
	Ham_Touch,

	/**
	 * Description:		Called whenver one entity uses another.
	 * Forward params:	function(this, idcaller, idactivator, use_type, Float:value)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_Use, this, idcaller, idactivator, use_type, Float:value);
	 */
	Ham_Use,

	/**
	 * Description:		Normally called whenever one entity blocks another from moving.
	 * Forward params:	function(this, idother);
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_Blocked, this, idother);
	 */
	Ham_Blocked,

	/**
	 * Description:		Normally called when a map-based item respawns, such as a health kit or something.
	 * Forward params:	function(this);
	 * Return type:		Entity.
	 * Execute params:	ExecuteHam(Ham_Respawn, this);
	 */
	Ham_Respawn,

	/**
	 * Description:		Used in Half-Life to update a monster's owner.
	 * Forward params:	function(this);
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_UpdateOwner, this);
	 */
	Ham_UpdateOwner,

	/**
	 * Description:		Normally called whenever a barnacle grabs the entity.
	 * Forward params:	function(this);
	 * Return type:		Integer.
	 * Execute params:	ExecuteHam(Ham_FBecomeProne, this);
	 */
	Ham_FBecomeProne,

	/**
	 * Description:		Returns the center of the entity.
	 * Forward params:	function(this);
	 * Return type:		Vector (byref'd in ExecuteHam).
	 * Execute params:	ExecuteHam(Ham_Center, this, Float:output[3]);
	 */
	Ham_Center,

	/**
	 * Description:		Returns the eye position of the entity.
	 * Forward params:	function(this);
	 * Return type:		Vector (byref'd in ExecuteHam).
	 * Execute params:	ExecuteHam(Ham_EyePosition, this, Float:output[3]);
	 */
	Ham_EyePosition,

	/**
	 * Description:		Returns the ear position of the entity.
	 * Forward params:	function(this);
	 * Return type:		Vector (byref'd in ExecuteHam).
	 * Execute params:	ExecuteHam(Ham_EarPosition, this, Float:output[3]);
	 */
	Ham_EarPosition,

	/**
	 * Description:		Position to shoot at.
	 * Forward params:	function(this, Float:srcvector[3]);
	 * Return type:		Vector (byref'd in ExecuteHam).
	 * Execute params:	ExecuteHam(Ham_BodyTarget, Float:srcvector[3], Float:returnvector[3])
	 */
	Ham_BodyTarget,

	/**
	 * Description:		Returns the illumination of the entity.
	 * Forward params:	function(this)
	 * Return type:		Integer.
	 * Execute params:	ExecuteHam(Ham_Illumination, this);
	 */
	Ham_Illumination,

	/**
	 * Description:		Returns true if a line can be traced from the caller's eyes to the target.
	 * Forward params:	function(this, idOther);
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_FVisible, this, idOther);
	 */
	Ham_FVisible,

	/**
	 * Description:		Returns true if a line can be traced from the caller's eyes to given vector.
	 * Forward params:	function(this, const Float:origin[3]);
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_FVecVisible, this, const Float:origin[3]);
	 */
	Ham_FVecVisible,


	/**
	 * Players have all the attributes of normal entities, in addition to these.
	 */

	/**
	 * Description:		Typically called every frame when a player has jump held.
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_Player_Jump, this);
	 */
	Ham_Player_Jump,

	/**
	 * Description:		Typically called every frame when a player has duck held.
	 *					This function is not supported in Earth's Special Forces mod.
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_Player_Duck, this);
	 */
	Ham_Player_Duck,

	/**
	 * Description:		Typically called every frame during PlayerPreThink engine call.
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_Player_PreThink, this);
	 */
	Ham_Player_PreThink,

	/**
	 * Description:		Typically called every frame during PlayerPostThink engine call.
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_Player_PostThink, this);
	 */
	Ham_Player_PostThink,

	/**
	 * Description:		Returns a vector that tells the gun position.
	 *					This function is not supported by Team Fortress Classic.
	 * Forward params:	function(this)
	 * Return type:		Vector (byreffed in ExecuteHam);.
	 * Execute params:	ExecuteHam(Ham_Player_GetGunPosition, this, Float:output[3]);
	 */
	Ham_Player_GetGunPosition,

	/**
	 * Description:		Whether or not the player should fade on death.
	 * Forward param:	function(this)
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_Player_ShouldFadeOnDeath, this);
	 */
	Ham_Player_ShouldFadeOnDeath,

	/**
	 * Description:		Called whenever an impulse command is executed.
	 * Forward param:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_Player_ImpulseComands, this);
	 */
	Ham_Player_ImpulseCommands,

	/**
	 * Description:		Updates the client's data for hud changes (such as ammo).  Usually called every frame.
	 *					This function is not supported by Team Fortress Classic mod.
	 * Forward param:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_Player_UpdateClientData, this);
	 */
	Ham_Player_UpdateClientData,


	/**
	 * Items have all the attributes of normal entities in addition to these.
	 */

	/**
	 * Description:		Adds the item to the player.
	 * Forward params:	function(this, idPlayer);
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_Item_AddToPlayer, this, idPlayer);
	 */
	Ham_Item_AddToPlayer,

	/**
	 * Description:		Unsure.
	 * Forward params:	function(this, idOriginal);
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_Item_AddDuplicate, this, idOriginal);
	 */
	Ham_Item_AddDuplicate,

	/**
	 * Description:		Whether or not this entity can be deployed.
	 * Forward params:	function(this);
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_Item_CanDeploy, this);
	 */
	Ham_Item_CanDeploy,

	/**
	 * Description:		Deploys the entity (usually a weapon).
	 * Forward params:	function(this);
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_Item_Deploy, this);
	 */
	Ham_Item_Deploy,

	/**
	 * Description:		Whether or not the entity can be holstered.
	 * Forward params:	function(this);
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_Item_CanHolster, this);
	 */
	Ham_Item_CanHolster,

	/**
	 * Description:		Whether or not the entity (usually weapon) can be holstered.
	 * Forward params:	function(this)
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_Item_Holster, this);
	 */
	Ham_Item_Holster,

	/**
	 * Description:		Updates the HUD info about this item.
	 * Forward params:	function(this);
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_UpdateItemInfo, this);
	 */
	Ham_Item_UpdateItemInfo,

	/**
	 * Description:		Called each frame for an item, normally only on active items.
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_Item_PreFrame, this);
	 */
	Ham_Item_PreFrame,

	/**
	 * Description:		Called each frame for an item, normally only on active items.
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_Item_PostFrame, this);
	 */
	Ham_Item_PostFrame,

	/**
	 * Description:		Called when an item gets dropped, normally on death only.
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_Item_Drop, this);
	 */
	Ham_Item_Drop,

	/**
	 * Description:		Normally called when an item gets deleted.
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_Item_Kill, this);
	 */
	Ham_Item_Kill,

	/**
	 * Description:		Called when an entity starts being attached to (normally invisible and "following") a player.
	 * Forward params:	function(this, idPlayer)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_Item_AttachToPlayer, this, idPlayer)
	 */
	Ham_Item_AttachToPlayer,

	/**
	 * Description:		Returns the ammo index of the item.
	 * Forward params:	function(this)
	 * Return type:		Integer.
	 * Execute params:	ExecuteHam(Ham_Item_PrimaryAmmoIndex, this);
	 */
	Ham_Item_PrimaryAmmoIndex,

	/**
	 * Description:		Returns the secondary ammo index of the item.
	 * Forward params:	function(this)
	 * Return type:		Integer.
	 * Execute params:	ExecuteHam(Ham_Item_SecondaryAmmoIndex, this);
	 */
	Ham_Item_SecondaryAmmoIndex,

	/**
	 * Description:		Updates item data for the client.
	 * Forward params:	function(this, idPlayer)
	 * Return type:		Integer.
	 * Execute params:	ExecuteHam(Ham_Item_UpdateClientData, this, idPlayer);
	 */
	Ham_Item_UpdateClientData,

	/**
	 * Description:		Returns the entity index if the item is a weapon, -1 otherwise.
	 * Forward params:	function(this)
	 * Return type:		Entity.
	 * Execute Params:	ExecuteHam(Ham_Item_GetWeaponPtr, this)
	 */
	Ham_Item_GetWeaponPtr,

	/**
	 * Description:		Returns the item slot for the item.
	 * Forward params:	function(this)
	 * Return type:		Integer.
	 * Execute Params:	ExecuteHam(Ham_Item_ItemSlot, this)
	 */
	Ham_Item_ItemSlot,


	/**
	 * Weapons have all the attributes to Ham_Item_*, in addition to these.
	 */

	/**
	 * Description:		Gets ammo from the target weapon.
	 *					This function is not supported in Earth's Special Forces mod.
	 * Forward params:	function(this, idTarget)
	 * Return type:		Integer.
	 * Execute Params:	ExecuteHam(Ham_Weapon_ExtractAmmo, this, idTarget)
	 */
	Ham_Weapon_ExtractAmmo,

	/**
	 * Description:		Gets clip ammo from the target weapon.
	 *					This function is not supported in Earth's Special Forces mod.
	 * Forward params:	function(this, idTarget)
	 * Return type:		Integer.
	 * Execute Params:	ExecuteHam(Ham_Weapon_ExtractAmmo, this, idTarget)
	 */
	Ham_Weapon_ExtractClipAmmo,

	/**
	 * Description:		Unsure.
	 *					This function is not supported in Earth's Special Forces mod.
	 * Forward params:	function(this)
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_Weapon_AddWeapon, this);
	 */
	Ham_Weapon_AddWeapon,

	/**
	 * Description:		Plays the weapon's empty sound.
	 * Forward params:	function(this)
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_Weapon_PlayEmptySound, this);
	 */
	Ham_Weapon_PlayEmptySound,

	/**
	 * Description:		Sets the weapon so that it can play empty sound again.
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_Weapon_ResetEmptySound, this);
	 */
	Ham_Weapon_ResetEmptySound,

	/**
	 * Description:		Sends an animation event for the weapon.
	 *					This function has different versions for the following mods:
	 *						Counter-Strike: see Ham_CS_Weapon_SendWeaponAnim.
	 *						Team Fortress Classic: see Ham_TFC_Weapon_SendWeaponAnim.
	 *						Day Of Defeat: see Ham_DOD_Weapon_SendWeaponAnim.
	 * Forward params:	function(this, iAnim, skiplocal, body);
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_Weapon_SendWeaponAnim, this, iAnim, skiplocal, body);
	 */
	Ham_Weapon_SendWeaponAnim,

	/**
	 * Description:		Whether or not the weapon is usable (has ammo, etc.)
	 *					This function is not supported in Earth's Special Forces mod.
	 * Forward params:	function(this)
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_Weapon_IsUsable, this)
	 */
	Ham_Weapon_IsUsable,

	/**
	 * Description:		Called when the main attack of a weapon is triggered.
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_Weapon_PrimaryAttack, this);
	 */
	Ham_Weapon_PrimaryAttack,

	/**
	 * Description:		Called when the secondary attack of a weapon is triggered.
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_Weapon_SecondaryAttack, this);
	 */
	Ham_Weapon_SecondaryAttack,

	/**
	 * Description:		Called when the weapon is reloaded.
	 *					This function is not supported in Earth's Special Forces mod.
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_Weapon_Reload, this);
	 */
	Ham_Weapon_Reload,

	/**
	 * Description:		Displays the idle animation for the weapon.
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_Weapon_WeaponIdle, this);
	 */
	Ham_Weapon_WeaponIdle,

	/**
	 * Description:		There is no more ammo for this gun, so switch to the next best one.
	 * Forward params:	function(this)
	 * Return type:		None.
	 * ExecuteParams:	ExecuteHam(Ham_Weapon_RetireWeapon, this)
	 */
	Ham_Weapon_RetireWeapon,

	/**
	 * Description:		Whether or not the weapon should idle.
	 * Forward params:	function(this)
	 * Return type:		Integer (boolean).
	 * Execute Params:	ExecuteHam(Ham_Weapon_ShouldWeaponIdle, this)
	 */
	Ham_Weapon_ShouldWeaponIdle,

	/**
	 * Description:		Unsure.
	 *					This function is not supported by Team Fortress Classic.
	 * Forward params:	function(this)
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_Weapon_UseDecrement, this);
	 */
	Ham_Weapon_UseDecrement,


	/**
	 * The following functions are specific to The Specialists.
	 */

	/**
	 * Description:		-
	 * Forward params:	function(this, someboolvalue)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_TS_BreakableRespawn, this, someboolvalue);
	 */
	Ham_TS_BreakableRespawn,

	/**
	 * Description:		-
	 * Forward params:	function(this)
	 * Return type:		Integer (boolean)
	 * Execute params:	ExecuteHam(Ham_TS_CanUsedThroughWalls, this);
	 */
	Ham_TS_CanUsedThroughWalls,

	/**
	 * Description:		Unsure - this was removed in TS 3.0 (and thus is deprecated).
	 * Forward params:	function(this)
	 * Return type:		Integer (I think...)
	 * Execute params:	ExecuteHam(Ham_TS_RespawnWait, this);
	 */
	Ham_TS_RespawnWait,


	/**
	 * The following functions are specific to Counter-Strike.
	 */

	/**
	 * Description:		This is called on a map reset for most map based entities.
	 * Forward params:	function(this);
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_CS_Restart, this);
	 */
	Ham_CS_Restart,

	/**
	 * Description:		Respawn function for players/bots only! Do not use this on non player/bot entities!
	 * Forward params:	function(this);
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_CS_RoundRespawn, this);
	 */
	Ham_CS_RoundRespawn,

	/**
	 * Description:		Whether or not the player can drop the specified item.
	 * Forward params:	function(this)
	 * Return type:		Integer.
	 * Execute params:	ExecuteHam(Ham_CS_Item_CanDrop, this);
	 */
	Ham_CS_Item_CanDrop,

	/**
	 * Description:		Gets the maximum speed for whenever a player has the item deployed.
	 * Forward params:	function(this);
	 * Return type:		Float (byref'd in ExecuteHam).
	 * Execute params:	ExecuteHam(Ham_CS_Item_GetMaxSpeed, this, Float:output);
	 */
	Ham_CS_Item_GetMaxSpeed,


	/**
	 * The following functions are specific to Day Of Defeat.
	 */

	/**
	 * Description:		I assume this spawns players at the start of a new round.
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute Params:	ExecuteHam(Ham_DOD_RoundRespawn, this);
	 */
	Ham_DOD_RoundRespawn,

	/**
	 * Description:		I assume this spawns entities (like func_breakables) at the start of a new round.
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute Params:	ExecuteHam(Ham_DOD_RoundRespawnEnt, this);
	 */
	Ham_DOD_RoundRespawnEnt,

	/**
	 * Description:		Unsure.
	 * Forward params:	function(this)
	 * Return type:		None, I think...
	 * Execute params:	ExecuteHam(Ham_DOD_RoundStore, this);
	 */
	Ham_DOD_RoundStore,

	/**
	 * Description:		Unsure.
	 * Forward params:	function(this, someintegervalue)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_DOD_AreaSetIndex, this, someintegervalue)
	 */
	Ham_DOD_AreaSetIndex,

	/**
	 * Description:		Unsure.
	 * Forward params:	function(this, idPlayer)
	 * Return type:		None.
	 * Execute Params:	ExecuteHam(Ham_DOD_AreaSendStatus, this, idPlayer);
	 */
	Ham_DOD_AreaSendStatus,

	/**
	 * Description:		Unsure.
	 * Forward params:	function(this)
	 * Return type:		Integer.
	 * Execute Params:	ExecuteHam(Ham_DOD_GetState, this);
	 */
	Ham_DOD_GetState,

	/**
	 * Description:		Unsure.
	 * Forward params:	function(this, idtarget)
	 * Return type:		Integer.
	 * Execute Params:	ExecuteHam(Ham_DOD_GetStateEnt, this, idtarget);
	 */
	Ham_DOD_GetStateEnt,

	/**
	 * Description:		Whether or not a player can drop this item.
	 * Forward params:	function(this)
	 * Return type:		Integer (boolean).
	 * Execute Params:	ExecuteHam(Ham_DOD_Item_CanDrop, this);
	 */
	Ham_DOD_Item_CanDrop,


	/**
	 * The following functions are specific to The Team Fortress Classic.
	 */

	/**
	 * Description:		Unsure.
	 * Forward params:	function(this, playerId)
	 * Return type:		Integer.
	 * Execute params:	ExecuteHam(Ham_TFC_EngineerUse, this, playerId)
	 */
	Ham_TFC_EngineerUse,

	/**
	 * Description:		Unsure.
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_TFC_Finished, this);
	 */
	Ham_TFC_Finished,

	/**
	 * Description:		Unsure.
	 * Forward params:	function(this, grenId, Float:damage, Float:radius)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_TFC_EmpExplode, this, grenId, Float:damage, Float:radius)
	 */
	Ham_TFC_EmpExplode,

	/**
	 * Description:		Unsure.
	 *					'damage' and 'radius' are byref'd in ExecuteHam.
	 * Forward params:	function(this, Float:damage, Float:radius)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_TFC_CalcEmpDmgRad, this, Float:damage, Float:radius)
	 */
	Ham_TFC_CalcEmpDmgRad,

	/**
	 * Description:		Unsure.
	 * Forward params:	function(this, grenId)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_TFC_TakeEmpBlast, this, grenId);
	 */
	Ham_TFC_TakeEmpBlast,

	/**
	 * Description:		Unsure.
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_TFC_EmpRemove, this);
	 */
	Ham_TFC_EmpRemove,

	/**
	 * Description:		Unsure.
	 * Forward params:	function(this, grenId, Float:bounceMax)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_TFC_TakeConcussionBlast, this, grenId, Float:bounceMax);
	 */
	Ham_TFC_TakeConcussionBlast,

	/**
	 * Description:		Unsure.
	 * Forward params:	function(this, grenId)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_TFC_Concuss, this, grenId);
	 */
	Ham_TFC_Concuss,


	/**
	 * The following functions are specific to Earth's Special Forces.
	 */

	/**
	 * Description:		Unsure.
	 *					This is available only in ESF Open Beta.
	 * Forward params:	function(this)
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_ESF_IsEnvModel, this);
	 */
	Ham_ESF_IsEnvModel,

	/**
	 * Description:		Unsure.
	 *					This is available only in ESF Open Beta.
	 * Forward params:	function(this, entityida, entityidb, Float:floata, Float:floatb, dmgbits)
	 * Return type:		Integer.
	 * Execute params:	ExecuteHam(Ham_ESF_TakeDamage2, this, entityida, entityidb, Float:floata, Float:floatb, dmgbits);
	 */
	Ham_ESF_TakeDamage2,


	/**
	 * The following functions are specific to Natural Selection.
	 */

	/**
	 * Description:		Returns how many points each entity is worth.
	 * Forward params:	function(this)
	 * Return type:		Integer.
	 * Execute params:	ExecuteHam(Ham_NS_GetPointValue, this);
	 */
	Ham_NS_GetPointValue,

	/**
	 * Description:		Unsure.  Probably awards this with the killing of idvictim.
	 * Forward params:	function(this, idvictim)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_NS_AwardKill, this, idvictim);
	 */
	Ham_NS_AwardKill,

	/**
	 * Description:		Unsure, probably whenever an entity resets after a new round.
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_NS_ResetEntity, this);
	 */
	Ham_NS_ResetEntity,

	/**
	 * Description:		Unsure.
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_NS_UpdateOnRemove, this)
	 */
	Ham_NS_UpdateOnRemove,


	/**
	 * The following functions are specific to The Specialists.
	 */

	/**
	 * Description:		Unsure.
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_TS_GiveSlowMul, this)
	 */
	Ham_TS_GiveSlowMul,

	/**
	 * Description:		Unsure.  The second paramater is actually a char.
	 * Forward params:	function(this, Float:someval, someotherval)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_TS_GoSlow, this, Float:someval, someotherval)
	 */
	Ham_TS_GoSlow,

	/**
	 * Description:		Probably returns true if the user is in slow mo.
	 * Forward params:	function(this)
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_TS_InSlow, this)
	 */
	Ham_TS_InSlow,

	/**
	 * Description:		Returns true if the entity is an objective.
	 * Forward params:	function(this)
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_TS_IsObjective, this)
	 */
	Ham_TS_IsObjective,

	/**
	 * Description:		Unsure.
	 * Forward params:	function(this, bool:someval)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_TS_EnableObjective, this, bool:someval)
	 */
	Ham_TS_EnableObjective,

	/**
	 * Description:		Probably called when the engine call to OnEntFreePrivateData is called (the entity destructor.)
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_TS_OnEntFreePrivateData, this)
	 */
	Ham_TS_OnFreeEntPrivateData,

	/**
	 * Description:		Probably called when the engine call to ShouldCollide is called.
	 * Forward params:	function(this, otherEntity)
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_TS_ShouldCollide, this, otherEntity)
	 */
	Ham_TS_ShouldCollide,


	/**
	 * LATE ADDITIONS (2011)
	 */

	/**
	 * Description:		Turns a monster towards its ideal_yaw.
	 * Forward params:	function(this, speed);
	 * Return type:		Integer.
	 * Execute params:	ExecuteHam(Ham_ChangeYaw, this, speed);
	 */
	Ham_ChangeYaw,

	/**
	 * Description:		Returns if monster has human gibs.
	 * Forward params:	function(this);
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_HasHumanGibs, this);
	 */
	Ham_HasHumanGibs,

	/**
	 * Description:		Returns if monster has alien gibs.
	 * Forward params:	function(this);
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_HasAlienGibs, this);
	 */
	Ham_HasAlienGibs,

	/**
	 * Description:		Slowly fades a entity out, then removes it.
	 *					Using this on player will crash your server.
	 * Forward params:	function(this);
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_FadeMonster, this);
	 */
	Ham_FadeMonster,

	/**
	 * Description:		Create some gore and get rid of a monster's model.
	 * Forward params:	function(this);
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_GibMonster, this);
	 */
	Ham_GibMonster,

	/**
	 * Description:		Called when monster dies and prepares its entity to become a corpse.
	 * Forward params:	function(this);
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_BecomeDead, this);
	 */
	Ham_BecomeDead,

	/**
	 * Description:		Checks relation ship between two monsters.
	 * Forward params:	function(this, idother);
	 * Return type:		Integer (R_* constants, see HLDSK).
	 * Execute params:	ExecuteHam(Ham_IRelationship, this, idother);
	 */
	Ham_IRelationship,

	/**
	 * Description:		Called when monster is about to emit pain sound.
	 *					Not guaranteed to actually emit sound. (random, time, etc..)
	 * Forward params:	function(this);
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_PainSound, this);
	 */
	Ham_PainSound,

	/**
	 * Description:		Prints debug information about monster to console. (state, activity, and other)
	 *					This function is called by impulse 103.
	 * Forward params:	function(this);
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_ReportAIState, this);
	 */
	Ham_ReportAIState,

	/**
	 * Description:		Called when monster has died.
	 * Forward params:	function(this);
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_MonsterInitDead, this);
	 */
	Ham_MonsterInitDead,

	/**
	 * Description:		Function to find enemies or food by sight.
	 *					distance is maximum distance (in units) monster can see.
	 * Forward params:	function(this, distance);
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_Look, this, distance);
	 */
	Ham_Look,

	/**
	 * Description:		This functions searches the link list whose head is the caller's m_pLink field.
	 * Forward params:	function(this);
	 * Return type:		Integer (entity).
	 * Execute params:	ExecuteHam(Ham_BestVisibleEnemy, this);
	 */
	Ham_BestVisibleEnemy,

	/**
	 * Description:		Returns true if the passed ent is in the caller's forward view cone.
	 *					The dot product is performed in 2d, making the view cone infinitely tall.
	 * Forward params:	function(this, idOther);
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_FInViewCone, this, idOther);
	 */
	Ham_FInViewCone,

	/**
	 * Description:		Returns true if the passed ent is in the caller's forward view cone.
	 *					The dot product is performed in 2d, making the view cone infinitely tall.
	 * Forward params:	function(this, const Float:origin[3]);
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_FVecInViewCone, this, const Float:origin[3]);
	 */
	Ham_FVecInViewCone,

	/**
	 * Description:		Determines the best type of death animation to play.
	 * Forward params:	function(this);
	 * Return type:		Integer (ACT_* constants, see HLDSK. It might different depending the mod).
	 * Execute params:	ExecuteHam(Ham_GetDeathActivity, this);
	 */
	Ham_GetDeathActivity,


	/**
	 * The following functions are not supported by Counter-Strike, The Specialists and Natural Selection mods
	 */

	/**
	 * Description:		Runs core AI functions.
	 *					This function is not supported by Counter-Strike, The Specialists and Natural Selection mods.
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_RunAI, this);
	 */
	Ham_RunAI,

	/**
	 * Description:		Calls out to core AI functions and handles this monster's specific animation events.
	 *					This function is not supported by Counter-Strike, The Specialists and Natural Selection mods.
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_MonsterThink, this);
	 */
	Ham_MonsterThink,

	/**
	 * Description:		After a monster is spawned, it needs to be dropped into the world, checked for mobility problems
	 *					and put on the proper path, if any. This function does all of those things after the monster spawns.
	 *					Any initialization that should take place for all monsters goes here.
	 *					This function is not supported by Counter-Strike, The Specialists and Natural Selection mods.
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_MonsterInit, this);
	 */
	Ham_MonsterInit,

	/**
	 * Description:		Check validity of a straight move through space.
	 *					This function is not supported by Counter-Strike, The Specialists and Natural Selection mods.
	 * Forward params:	function(this, const Float:start[3], const Float:end[3], target, Float:dist)
	 * Return type:		Integer (See LOCALMOVE_* constants).
	 * Execute params:	ExecuteHam(Ham_CheckLocalMove, this, const Float:start[3], const Float:end[3], target, Float:dist);
	 */
	Ham_CheckLocalMove,

	/**
	 * Description:		Takes a single step towards the next ROUTE location.
	 *					This function is not supported by Counter-Strike, The Specialists and Natural Selection mods.
	 * Forward params:	function(this, Float:interval)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_Move, this, Float:interval);
	 */
	Ham_Move,

	/**
	 * Description:		-
	 *					This function is not supported by Counter-Strike, The Specialists and Natural Selection mods.
	 * Forward params:	function(this, targetEnt, const Float:dir[3], Float:interval)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_MoveExecute, this, targetEnt, const Float:dir[3], Float:interval);
	 */
	Ham_MoveExecute,

	/**
	 * Description:		-
	 *					This function is not supported by Counter-Strike, The Specialists and Natural Selection mods.
	 * Forward params:	function(this, Float:waypointDist)
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_ShouldAdvanceRoute, this, Float:waypointDist);
	 */
	Ham_ShouldAdvanceRoute,

	/**
	 * Description:		-
	 *					This function is not supported by Counter-Strike, The Specialists and Natural Selection mods.
	 * Forward params:	function(this)
	 * Return type:		Integer (ACT_* constants, see HLDSK. It might different depending the mod).
	 * Execute params:	ExecuteHam(Ham_GetStoppedActivity, this);
	 */
	Ham_GetStoppedActivity,

	/**
	 * Description:		-
	 *					This function is not supported by Counter-Strike, The Specialists and Natural Selection mods.
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_Stop, this);
	 */
	Ham_Stop,

	/**
	 * Description:		Surveys conditions and set appropriate conditions bits for attack types.
	 *					This function is not supported by Counter-Strike, The Specialists and Natural Selection mods.
	 * Forward params:	function(this, Float:dot, Float:dist)
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_CheckRangeAttack1, this, Float:dot, Float:dist);
	 */
	Ham_CheckRangeAttack1,

	/**
	 * Description:		Surveys conditions and set appropriate conditions bits for attack types.
	 *					This function is not supported by Counter-Strike, The Specialists and Natural Selection mods.
	 * Forward params:	function(this, Float:dot, Float:dist)
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_CheckRangeAttack2, this, Float:dot, Float:dist);
	 */
	Ham_CheckRangeAttack2,

	/**
	 * Description:		Surveys conditions and set appropriate conditions bits for attack types.
	 *					This function is not supported by Counter-Strike, The Specialists and Natural Selection mods.
	 * Forward params:	function(this, Float:dot, Float:dist)
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_CheckMeleeAttack1, this, Float:dot, Float:dist);
	 */
	Ham_CheckMeleeAttack1,

	/**
	 * Description:		Surveys conditions and set appropriate conditions bits for attack types.
	 *					This function is not supported by Counter-Strike, The Specialists and Natural Selection mods.
	 * Forward params:	function(this, Float:dot, Float:dist)
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_CheckMeleeAttack2, this, Float:dot, Float:dist);
	 */
	Ham_CheckMeleeAttack2,

	/**
	 * Description:		-
	 *					This function is not supported by Counter-Strike, The Specialists and Natural Selection mods.
	 * Forward params:	function(this, Float:dot, Float:dist)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_ScheduleChange, this, Float:dot, Float:dist);
	 */
	Ham_ScheduleChange,

	/**
	 * Description:		Determines whether or not the monster can play the scripted sequence or AI sequence that is
	 *					trying to possess it. If DisregardState is set, the monster will be sucked into the script
	 *					no matter what state it is in. ONLY Scripted AI ents should allow this.
	 *					This function is not supported by Counter-Strike, The Specialists and Natural Selection mods.
	 * Forward params:	function(this, bool:disregardState, interruptLevel);
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_CanPlaySequence, this, bool:disregardState, interruptLevel);
	 */
	Ham_CanPlaySequence,

	/**
	 * Description:		-
	 *					This function is not supported by Counter-Strike, The Specialists and Natural Selection mods.
	 * Forward params:	function(this, bool:disregardState);
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_CanPlaySentence, this, bool:disregardState);
	 */
	Ham_CanPlaySentence,

	/**
	 * Description:		-
	 *					This function is not supported by Counter-Strike, The Specialists and Natural Selection mods.
	 * Forward params:	function(this, const sentence[], Float:duration, Float:volume, Float:attenuation);
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_PlaySentence, this, const sentence[], Float:duration, Float:volume, Float:attenuation);
	 */
	Ham_PlaySentence,

	/**
	 * Description:		-
	 *					This function is not supported by Counter-Strike, The Specialists and Natural Selection mods.
	 * Forward params:	function(this, const sentence[], Float:duration, Float:volume, Float:attenuation, bool:concurrent, idListener);
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_PlayScriptedSentence, this, const sentence[], Float:duration, Float:volume, Float:attenuation, bool:concurrent, idListener);
	 */
	Ham_PlayScriptedSentence,

	/**
	 * Description:		-
	 *					This function is not supported by Counter-Strike, The Specialists and Natural Selection mods.
	 * Forward params:	function(this);
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_SentenceStop, this);
	 */
	Ham_SentenceStop,

	/**
	 * Description:		Surveys the Conditions information available and finds the best new state for a monster.
	 *					This function is not supported by Counter-Strike, The Specialists and Natural Selection mods.
	 * Forward params:	function(this);
	 * Return type:		Integer (MONSTERSTATE_* constants, see HLDSK).
	 * Execute params:	ExecuteHam(Ham_GetIdealState, this);
	 */
	Ham_GetIdealState,

	/**
	 * Description:		-
	 *					This function is not supported by Counter-Strike, The Specialists and Natural Selection mods.
	 * Forward params:	function(this, newActivity);
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_SetActivity, this, newActivity);
	 */
	Ham_SetActivity,

	/**
	 * Description:		Part of the condition collection process gets and stores data and conditions
	 *					pertaining to a monster's enemy. Returns TRUE if Enemy LKP was updated.
	 *					This function is not supported by Counter-Strike, The Specialists and Natural Selection mods.
	 * Forward params:	function(this, idEnemy);
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_CheckEnemy, this, idEnemy);
	 */
	Ham_CheckEnemy,

	/**
	 * Description:		Tries to overcome local obstacles by triangulating a path around them.
	 *					'dist' is how far the obstruction that we are trying to triangulate around is from the monster.
	 *					This function is not supported by Counter-Strike, The Specialists and Natural Selection mods.
	 * Forward params:	function(this, const Float:start[3], const Float:end[3], Float:dist, targetEnt, Float:apex[3]);
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_FTriangulate, this, const Float:start[3], const Float:end[3], Float:dist, targetEnt, Float:apex[3]);
	 */
	Ham_FTriangulate,

	/**
	 * Description:		Allows each sequence to have a different turn rate associated with it.
	 *					This function is not supported by Counter-Strike, The Specialists and Natural Selection mods.
	 * Forward params:	function(this);
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_SetYawSpeed, this);
	 */
	Ham_SetYawSpeed,

	/**
	 * Description:		Tries to build a route as close to the target as possible, even if there isn't a path to the final point.
	 *					If supplied, search will return a node at least as far away as MinDist from vecThreat, but no farther than minDist.
	 *					If maxDist isn't supplied, it defaults to a reasonable value.
	 *					This function is not supported by Counter-Strike, The Specialists and Natural Selection mods.
	 * Forward params:	function(this, Float:threat[3], const Float:viewOffset[3], Float:minDist, Float:maxDist);
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_BuildNearestRoute, this, const Float:threat[3], const Float:viewOffset[3], Float:minDist, Float:maxDist);
	 */
	Ham_BuildNearestRoute,

	/**
	 * Description:		Tries to find a nearby node that will hide the caller from its enemy.
	 *					If supplied, search will return a node at least as far away as MinDist from vecThreat, but no farther than minDist.
	 *					If maxDist isn't supplied, it defaults to a reasonable value.
	 *					This function is not supported by Counter-Strike, The Specialists and Natural Selection mods.
	 * Forward params:	function(this, Float:threat[3], const Float:viewOffset[3], Float:minDist, Float:maxDist);
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_FindCover, this, const Float:threat[3], const Float:viewOffset[3], Float:minDist, Float:maxDist);
	 */
	Ham_FindCover,

	/**
	 * Description:		Default cover radius.
	 *					This function is not supported by Counter-Strike, The Specialists and Natural Selection mods.
	 * Forward params:	function(this);
	 * Return type:		Float.
	 * Execute params:	ExecuteHam(Ham_CoverRadius, this);
	 */
	Ham_CoverRadius,

	/**
	 * Description:		Prequalifies a monster to do more fine checking of potential attacks.
	 *					This function is not supported by Counter-Strike, The Specialists and Natural Selection mods.
	 * Forward params:	function(this);
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_FCanCheckAttacks, this);
	 */
	Ham_FCanCheckAttacks,

	/**
	 * Description:		-
	 *					This function is not supported by Counter-Strike, The Specialists and Natural Selection mods.
	 * Forward params:	function(this);
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_CheckAmmo, this);
	 */
	Ham_CheckAmmo,

	/**
	 * Description:		Before a set of conditions is allowed to interrupt a monster's schedule, this function removes
	 *					conditions that we have flagged to interrupt the current schedule, but may not want to interrupt
	 *					the schedule every time. (Pain, for instance)
	 *					This function is not supported by Counter-Strike, The Specialists and Natural Selection mods.
	 * Forward params:	function(this);
	 * Return type:		Integer.
	 * Execute params:	ExecuteHam(Ham_IgnoreConditions, this);
	 */
	Ham_IgnoreConditions,

	/**
	 * Description:		Tells use whether or not the monster cares about the type of Hint Node given.
	 *					This function is not supported by Counter-Strike, The Specialists and Natural Selection mods.
	 * Forward params:	function(this, hint);
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_FValidateHintType, this, hint);
	 */
	Ham_FValidateHintType,

	/**
	 * Description:		-
	 *					This function is not supported by Counter-Strike, The Specialists and Natural Selection mods.
	 * Forward params:	function(this);
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_FValidateHintType, this);
	 */
	Ham_FCanActiveIdle,

	/**
	 * Description:		Returns a bit mask indicating which types of sounds this monster regards.
	 *					In the base class implementation, monsters care about all sounds, but no scents.
	 *					This function is not supported by Counter-Strike, The Specialists and Natural Selection mods.
	 * Forward params:	function(this);
	 * Return type:		Integer.
	 * Execute params:	ExecuteHam(Ham_ISoundMask, this);
	 */
	Ham_ISoundMask,

	/**
	 * Description:		-
	 *					This function is not supported by Counter-Strike, The Specialists and Natural Selection mods.
	 * Forward params:	function(this);
	 * Return type:		Float.
	 * Execute params:	ExecuteHam(Ham_HearingSensitivity, this);
	 */
	Ham_HearingSensitivity,

	/**
	 * Description:		Called by Barnacle victims when the barnacle pulls their head into its mouth.
	 *					This function is not supported by Counter-Strike, The Specialists and Natural Selection mods.
	 * Forward params:	function(this, idBarnacle);
	 * Return type:		Float.
	 * Execute params:	ExecuteHam(Ham_BarnacleVictimBitten, this, idBarnacle);
	 */
	Ham_BarnacleVictimBitten,

	/**
	 * Description:		Called by barnacle victims when the host barnacle is killed.
	 *					This function is not supported by Counter-Strike, The Specialists and Natural Selection mods.
	 * Forward params:	function(this);
	 * Return type:		Float.
	 * Execute params:	ExecuteHam(Ham_BarnacleVictimReleased, this);
	 */
	Ham_BarnacleVictimReleased,

	/**
	 * Description:		Runs after conditions are collected and before scheduling code is run.
	 *					This function is not supported by Counter-Strike, The Specialists and Natural Selection mods.
	 * Forward params:	function(this);
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_PrescheduleThink, this);
	 */
	Ham_PrescheduleThink,

	/**
	 * Description:		Plays death sounds.
	 *					This function is not supported by Counter-Strike, The Specialists and Natural Selection mods.
	 * Forward params:	function(this);
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_DeathSound, this);
	 */
	Ham_DeathSound,

	/**
	 * Description:		Plays alert sounds.
	 *					This function is not supported by Counter-Strike, The Specialists and Natural Selection mods.
	 * Forward params:	function(this);
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_AlertSound, this);
	 */
	Ham_AlertSound,

	/**
	 * Description:		Plays idle sounds.
	 *					This function is not supported by Counter-Strike, The Specialists and Natural Selection mods.
	 * Forward params:	function(this);
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_IdleSound, this);
	 */
	Ham_IdleSound,

	/**
	 * Description:		This should stop a monster following a target.
	 * Forward params:	function(this, bool:clearSchedule)
	 * Return type:		None.
	 * Execute Params:	ExecuteHam(Ham_StopFollowing, this, bool:clearSchedule);
	 */
	Ham_StopFollowing,


	/**
	 * The following functions are specific to Counter-Strike.
	 */

	/**
	 * Description:		Sends an animation event for the weapon. skiplocal is 1 if client is predicting weapon animations.
	 * Forward params:	function(this, anim, skiplocal);
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_CS_Weapon_SendWeaponAnim, this, anim, skiplocal);
	 */
	Ham_CS_Weapon_SendWeaponAnim,

	/**
	 * Description:		Resets the player's max speed.
	 * Forward params:	function(this);
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_CS_Player_ResetMaxSpeed, this);
	 */
	Ham_CS_Player_ResetMaxSpeed,

	/**
	 * Description:		Whether or not the player is a bot.
	 * Forward params:	function(this);
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_CS_Player_IsBot, this);
	 */
	Ham_CS_Player_IsBot,

	/**
	 * Description:		Returns a vector that tells the autoaim direction.
	 *					Set crosshair position to point to enemey if sv_aim is 1.
	 * Forward params:	function(this, Float:delta)
	 * Return type:		Vector, byreffed in execute.
	 * Execute params:	ExecuteHam(Ham_CS_Player_GetAutoaimVector, this, Float:delta, Float:output[3]);
	 */
	Ham_CS_Player_GetAutoaimVector,

	/**
	 * Description:		Whether or not the player is being flashing. (flashbang grenade explosion)
	 *					blindTime is the time you are considered as being blind. (holdTime * 0.33).
	 * Forward params:	function(this, Float:blindTime, Float:duration, Float:holdTime, alpha);
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_CS_Player_Blind, this, Float:blindTime, Float:duration, Float:holdTime, alpha);
	 */
	Ham_CS_Player_Blind,

	/**
	 * Description:		Whether or not the player is touching a weapon on the ground.
	 * Forward params:	function(this, entityid);
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_CS_Player_OnTouchingWeapon, this, entityid);
	 */
	Ham_CS_Player_OnTouchingWeapon,


	/**
	 * The following functions are specific to Day Of Defeat.
	 */

	/**
	 * Description:		-
	 * Forward params:	function(this)
	 * Return type:		Integer.
	 * Execute Params:	ExecuteHam(Ham_DOD_SetScriptReset, this);
	 */
	Ham_DOD_SetScriptReset,

	/**
	 * Description:		-
	 * Forward params:	function(this)
	 * Return type:		Integer.
	 * Execute Params:	ExecuteHam(Ham_DOD_Item_SpawnDeploy, this);
	 */
	Ham_DOD_Item_SpawnDeploy,

	/**
	 * Description:		-
	 * Forward params:	function(this, Float:someValue)
	 * Return type:		None.
	 * Execute Params:	ExecuteHam(Ham_DOD_Item_SetDmgTime, this, Float:someValue);
	 */
	Ham_DOD_Item_SetDmgTime,

	/**
	 * Description:		-
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute Params:	ExecuteHam(Ham_DOD_Item_DropGren, this);
	 */
	Ham_DOD_Item_DropGren,

	/**
	 * Description:		-
	 * Forward params:	function(this)
	 * Return type:		Integer (boolean).
	 * Execute Params:	ExecuteHam(Ham_DOD_Weapon_IsUseable, this);
	 */
	Ham_DOD_Weapon_IsUseable,

	/**
	 * Description:		-
	 * Forward params:	function(this, Float:accuracyFactor, idother, shared_rand)
	 * Return type:		Vector, byreffed in execute.
	 * Execute Params:	ExecuteHam(Ham_DOD_Weapon_Aim, this, Float:accuracyFactor, idother, shared_rand, Float:output[3]);
	 */
	Ham_DOD_Weapon_Aim,

	/**
	 * Description:		-
	 * Forward params:	function(this, Float:accuracyFactor, idother)
	 * Return type:		Float.
	 * Execute Params:	ExecuteHam(Ham_DOD_Weapon_flAim, this, Float:accuracyFactor, idother);
	 */
	Ham_DOD_Weapon_flAim,

	/**
	 * Description:		-
	 * Forward params:	function(this, Float:amount, targetEnt)
	 * Return type:		None.
	 * Execute Params:	ExecuteHam(Ham_DOD_Weapon_RemoveStamina, this, Float:amount, targetEnt);
	 */
	Ham_DOD_Weapon_RemoveStamina,

	/**
	 * Description:		-
	 * Forward params:	function(this, fov)
	 * Return type:		Integer.
	 * Execute Params:	ExecuteHam(Ham_DOD_Weapon_ChangeFOV, this, fov);
	 */
	Ham_DOD_Weapon_ChangeFOV,

	/**
	 * Description:		-
	 * Forward params:	function(this)
	 * Return type:		Integer.
	 * Execute Params:	ExecuteHam(Ham_DOD_Weapon_ZoomOut, this);
	 */
	Ham_DOD_Weapon_ZoomOut,

	/**
	 * Description:		-
	 * Forward params:	function(this)
	 * Return type:		Integer.
	 * Execute Params:	ExecuteHam(Ham_DOD_Weapon_ZoomIn, this);
	 */
	Ham_DOD_Weapon_ZoomIn,

	/**
	 * Description:		-
	 * Forward params:	function(this)
	 * Return type:		Integer.
	 * Execute Params:	ExecuteHam(Ham_DOD_Weapon_GetFOV, this);
	 */
	Ham_DOD_Weapon_GetFOV,

	/**
	 * Description:		-
	 * Forward params:	function(this)
	 * Return type:		Integer (boolean).
	 * Execute Params:	ExecuteHam(Ham_DOD_Weapon_IsWaterSniping, this);
	 */
	Ham_DOD_Weapon_PlayerIsWaterSniping,

	/**
	 * Description:		-
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute Params:	ExecuteHam(Ham_DOD_Weapon_UpdateZoomSpeed, this);
	 */
	Ham_DOD_Weapon_UpdateZoomSpeed,

	/**
	 * Description:		-
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute Params:	ExecuteHam(Ham_DOD_Weapon_Special, this);
	 */
	Ham_DOD_Weapon_Special,


	/**
	 * The following functions are specific to Team Fortress Classic.
	 */

	/**
	 * Description:		Get the item name.
	 * Forward params:	function(this, const buffer[]);
	 * Return type:		String (string length returned and string byref'd in ExecuteHam).
	 * Execute params:	ExecuteHam(Ham_TFC_DB_GetItemName, this, buffer[], size);
	 */
	Ham_TFC_DB_GetItemName,

	/**
	 * Description:		This entity is exploding, or otherwise needs to inflict damage upon entities within a certain range.
	 * Forward params:	function(this, inflictorId, attackerId, Float:damage, classIgnore, bitsDamageType)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_TFC_RadiusDamage, this, inflictorId, attackerId, Float:damage, classIgnore, bitsDamageType);
	 */
	Ham_TFC_RadiusDamage,

	/**
	 * Description:		This entity is exploding, or otherwise needs to inflict damage upon entities within a certain range.
	 * Forward params:	function(this, const Float:source[3], inflictorId, attackerId, Float:damage, classIgnore, bitsDamageType)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_TFC_RadiusDamage2, this, const Float:source[3], inflictorId, attackerId, Float:damage, classIgnore, bitsDamageType);
	 */
	Ham_TFC_RadiusDamage2,


	/**
	 * The following functions are specific to Earth's Special Forces.
	 */

	/**
	 * Description:		-
	 *					This is available only in ESF Open Beta.
	 * Forward params:	function(this)
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_ESF_IsFighter, this);
	 */
	Ham_ESF_IsFighter,

	/**
	 * Description:		-
	 *					This is available only in ESF Open Beta.
	 * Forward params:	function(this)
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_ESF_IsBuddy, this);
	 */
	Ham_ESF_IsBuddy,

	/**
	 * Description:		-
	 *					This is available only in ESF Open Beta.
	 * Forward params:	function(this, const char sample[], somevalue)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_ESF_EmitSound, this, const sample[], somevalue);
	 */
	Ham_ESF_EmitSound,

	/**
	 * Description:		-
	 *					This is available only in ESF Open Beta.
	 * Forward params:	function(this somevalue)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_ESF_EmitNullSound, this, somevalue);
	 */
	Ham_ESF_EmitNullSound,

	/**
	 * Description:		-
	 *					This is available only in ESF Open Beta.
	 * Forward params:	function(this, someentid, somevalue)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_ESF_IncreaseStrength, this, someentid, somevalue);
	 */
	Ham_ESF_IncreaseStrength,

	/**
	 * Description:		-
	 *					This is available only in ESF Open Beta.
	 * Forward params:	function(this somevalue)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_ESF_IncreasePL, this, somevalue);
	 */
	Ham_ESF_IncreasePL,

	/**
	 * Description:		-
	 *					This is available only in ESF Open Beta.
	 * Forward params:	function(this somevalue)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_ESF_SetPowerLevel, this, somevalue);
	 */
	Ham_ESF_SetPowerLevel,

	/**
	 * Description:		-
	 *					This is available only in ESF Open Beta.
	 * Forward params:	function(this, somevalue)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_ESF_SetMaxPowerLevel, this, somevalue);
	 */
	Ham_ESF_SetMaxPowerLevel,

	/**
	 * Description:		-
	 *					This is available only in ESF Open Beta.
	 * Forward params:	function(this, anim)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_ESF_StopAniTrigger, this, anim);
	 */
	Ham_ESF_StopAniTrigger,

	/**
	 * Description:		-
	 *					This is available only in ESF Open Beta.
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_ESF_StopFly, this);
	 */
	Ham_ESF_StopFly,

	/**
	 * Description:		-
	 *					This is available only in ESF Open Beta.
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_ESF_HideWeapon, this);
	 */
	Ham_ESF_HideWeapon,

	/**
	 * Description:		-
	 *					This is available only in ESF Open Beta.
	 * Forward params:	function(this, somevalue)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_ESF_HideWeapon, this, somevalue);
	 */
	Ham_ESF_ClientRemoveWeapon,

	/**
	 * Description:		-
	 *					This is available only in ESF Open Beta.
	 * Forward params:	function(this, const model[])
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_ESF_SendClientsCustomModel, this, const model[]);
	 */
	Ham_ESF_SendClientsCustomModel,

	/**
	 * Description:		-
	 *					This is available only in ESF Open Beta.
	 * Forward params:	function(this)
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_ESF_CanTurbo, this);
	 */
	Ham_ESF_CanTurbo,

	/**
	 * Description:		-
	 *					This is available only in ESF Open Beta.
	 * Forward params:	function(this)
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_ESF_CanPrimaryFire, this);
	 */
	Ham_ESF_CanPrimaryFire,

	/**
	 * Description:		-
	 *					This is available only in ESF Open Beta.
	 * Forward params:	function(this)
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_ESF_CanSecondaryFire, this);
	 */
	Ham_ESF_CanSecondaryFire,

	/**
	 * Description:		-
	 *					This is available only in ESF Open Beta.
	 * Forward params:	function(this)
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_ESF_CanStopFly, this);
	 */
	Ham_ESF_CanStopFly,

	/**
	 * Description:		-
	 *					This is available only in ESF Open Beta.
	 * Forward params:	function(this)
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_ESF_CanBlock, this);
	 */
	Ham_ESF_CanBlock,

	/**
	 * Description:		-
	 *					This is available only in ESF Open Beta.
	 * Forward params:	function(this)
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_ESF_CanRaiseKi, this);
	 */
	Ham_ESF_CanRaiseKi,

	/**
	 * Description:		-
	 *					This is available only in ESF Open Beta.
	 * Forward params:	function(this)
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_ESF_CanRaiseStamina, this);
	 */
	Ham_ESF_CanRaiseStamina,

	/**
	 * Description:		-
	 *					This is available only in ESF Open Beta.
	 * Forward params:	function(this)
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_ESF_CanTeleport, this);
	 */
	Ham_ESF_CanTeleport,

	/**
	 * Description:		-
	 *					This is available only in ESF Open Beta.
	 * Forward params:	function(this)
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_ESF_CanStartFly, this);
	 */
	Ham_ESF_CanStartFly,

	/**
	 * Description:		-
	 *					This is available only in ESF Open Beta.
	 * Forward params:	function(this)
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_ESF_CanStartPowerup, this);
	 */
	Ham_ESF_CanStartPowerup,

	/**
	 * Description:		-
	 *					This is available only in ESF Open Beta.
	 * Forward params:	function(this)
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_ESF_CanJump, this);
	 */
	Ham_ESF_CanJump,

	/**
	 * Description:		-
	 *					This is available only in ESF Open Beta.
	 * Forward params:	function(this)
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_ESF_CanWallJump, this);
	 */
	Ham_ESF_CanWallJump,

	/**
	 * Description:		-
	 *					This is available only in ESF Open Beta.
	 * Forward params:	function(this)
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_ESF_IsSuperJump, this);
	 */
	Ham_ESF_IsSuperJump,

	/**
	 * Description:		-
	 *					This is available only in ESF Open Beta.
	 * Forward params:	function(this)
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_ESF_IsMoveBack, this);
	 */
	Ham_ESF_IsMoveBack,

	/**
	 * Description:		-
	 *					This is available only in ESF Open Beta.
	 * Forward params:	function(this)
	 * Return type:		Integer.
	 * Execute params:	ExecuteHam(Ham_ESF_CheckWallJump, this);
	 */
	Ham_ESF_CheckWallJump,

	/**
	 * Description:		-
	 *					This is available only in ESF Open Beta.
	 * Forward params:	function(this, const Float:somevalue[3])
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_ESF_EnableWallJump, this, const Float:somevalue[3]);
	 */
	Ham_ESF_EnableWallJump,

	/**
	 * Description:		-
	 *					This is available only in ESF Open Beta.
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_ESF_DisableWallJump, this);
	 */
	Ham_ESF_DisableWallJump,

	/**
	 * Description:		-
	 *					This is available only in ESF Open Beta.
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_ESF_ResetWallJumpVars, this);
	 */
	Ham_ESF_ResetWallJumpVars,

	/**
	 * Description:		-
	 *					This is available only in ESF Open Beta.
	 * Forward params:	function(this, const value[], const Float:somevalue[3], const someothervalue[])
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_ESF_GetWallJumpAnim, const value[], const Float:somevalue[3], const someothervalue[]);
	 */
	Ham_ESF_GetWallJumpAnim,

	/**
	 * Description:		-
	 *					This is available only in ESF Open Beta.
	 * Forward params:	function(this, const somevalue[], const someothervalue[])
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_ESF_GetWallJumpAnim2, this, const somevalue[], const someothervalue[]);
	 */
	Ham_ESF_GetWallJumpAnim2,

	/**
	 * Description:		-
	 *					This is available only in ESF Open Beta.
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_ESF_SetFlyMoveType, this);
	 */
	Ham_ESF_SetWallJumpAnimation,

	/**
	 * Description:		-
	 *					This is available only in ESF Open Beta.
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_ESF_SetFlyMoveType, this);
	 */
	Ham_ESF_SetFlyMoveType,

	/**
	 * Description:		-
	 *					This is available only in ESF Open Beta.
	 * Forward params:	function(this)
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_ESF_IsFlyMoveType, this);
	 */
	Ham_ESF_IsFlyMoveType,

	/**
	 * Description:		-
	 *					This is available only in ESF Open Beta.
	 * Forward params:	function(this)
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_ESF_IsWalkMoveType, this);
	 */
	Ham_ESF_IsWalkMoveType,

	/**
	 * Description:		-
	 *					This is available only in ESF Open Beta.
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_ESF_SetWalkMoveType, this);
	 */
	Ham_ESF_SetWalkMoveType,

	/**
	 * Description:		-
	 *					This is available only in ESF Open Beta.
	 * Forward params:	function(this, somevalue)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_ESF_DrawChargeBar, this, somevalue);
	 */
	Ham_ESF_DrawChargeBar,

	/**
	 * Description:		-
	 *					This is available only in ESF Open Beta.
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_ESF_StartBlock, this);
	 */
	Ham_ESF_StartBlock,

	/**
	 * Description:		-
	 *					This is available only in ESF Open Beta.
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_ESF_StopBlock, this);
	 */
	Ham_ESF_StopBlock,

	/**
	 * Description:		-
	 *					This is available only in ESF Open Beta.
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_ESF_StartFly, this);
	 */
	Ham_ESF_StartFly,

	/**
	 * Description:		-
	 *					This is available only in ESF Open Beta.
	 * Forward params:	function(this, Float:value)
	 * Return type:		Float.
	 * Execute params:	ExecuteHam(Ham_ESF_GetMaxSpeed, this, Float:value);
	 */
	Ham_ESF_GetMaxSpeed,

	/**
	 * Description:		-
	 *					This is available only in ESF Open Beta.
	 * Forward params:	function(this, anim)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_ESF_SetAnimation, this, anim);
	 */
	Ham_ESF_SetAnimation,

	/**
	 * Description:		-
	 *					This is available only in ESF Open Beta.
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_ESF_PlayAnimation, this);
	 */
	Ham_ESF_PlayAnimation,

	/**
	 * Description:		-
	 *					This is available only in ESF Open Beta.
	 * Forward params:	function(this)
	 * Return type:		Integer.
	 * Execute params:	ExecuteHam(Ham_ESF_GetMoveForward, this);
	 */
	Ham_ESF_GetMoveForward,

	/**
	 * Description:		-
	 *					This is available only in ESF Open Beta.
	 * Forward params:	function(this)
	 * Return type:		Integer.
	 * Execute params:	ExecuteHam(Ham_ESF_GetMoveRight, this);
	 */
	Ham_ESF_GetMoveRight,

	/**
	 * Description:		-
	 *					This is available only in ESF Open Beta.
	 * Forward params:	function(this)
	 * Return type:		Integer.
	 * Execute params:	ExecuteHam(Ham_ESF_GetMoveUp, this);
	 */
	Ham_ESF_GetMoveUp,

	/**
	 * Description:		-
	 *					This is available only in ESF Open Beta.
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_ESF_AddBlindFX, this);
	 */
	Ham_ESF_AddBlindFX,

	/**
	 * Description:		-
	 *					This is available only in ESF Open Beta.
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_ESF_RemoveBlindFX, this);
	 */
	Ham_ESF_RemoveBlindFX,

	/**
	 * Description:		-
	 *					This is available only in ESF Open Beta.
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_ESF_DisablePSBar, this);
	 */
	Ham_ESF_DisablePSBar,

	/**
	 * Description:		-
	 *					This is available only in ESF Open Beta.
	 * Forward params:	function(this, somevalue)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_ESF_AddBeamBoxCrosshair, this, somevalue);
	 */
	Ham_ESF_AddBeamBoxCrosshair,

	/**
	 * Description:		-
	 *					This is available only in ESF Open Beta.
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_ESF_RemoveBeamBoxCrosshair, this);
	 */
	Ham_ESF_RemoveBeamBoxCrosshair,

	/**
	 * Description:		-
	 *					This is available only in ESF Open Beta.
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_ESF_DrawPSWinBonus, this);
	 */
	Ham_ESF_DrawPSWinBonus,

	/**
	 * Description:		-
	 *					This is available only in ESF Open Beta.
	 * Forward params:	function(this, Float:value, Float:othervalue)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_ESF_DrawPSBar, this, Float:value, Float:othervalue);
	 */
	Ham_ESF_DrawPSBar,

	/**
	 * Description:		-
	 *					This is available only in ESF Open Beta.
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_ESF_LockCrosshair, this);
	 */
	Ham_ESF_LockCrosshair,

	/**
	 * Description:		-
	 *					This is available only in ESF Open Beta.
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_ESF_UnLockCrosshair, this);
	 */
	Ham_ESF_UnLockCrosshair,

	/**
	 * Description:		-
	 *					This is available only in ESF Open Beta.
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_ESF_RotateCrosshair, this);
	 */
	Ham_ESF_RotateCrosshair,

	/**
	 * Description:		-
	 *					This is available only in ESF Open Beta.
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_ESF_UnRotateCrosshair, this);
	 */
	Ham_ESF_UnRotateCrosshair,

	/**
	 * Description:		-
	 *					This is available only in ESF Open Beta.
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_ESF_WaterMove, this);
	 */
	Ham_ESF_WaterMove,

	/**
	 * Description:		-
	 *					This is available only in ESF Open Beta.
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_ESF_CheckTimeBasedDamage, this);
	 */
	Ham_ESF_CheckTimeBasedDamage,

	/**
	 * Description:		-
	 *					This is available only in ESF Open Beta.
	 * Forward params:	function(this)
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_ESF_DoesSecondaryAttack, this);
	 */
	Ham_ESF_DoesSecondaryAttack,

	/**
	 * Description:		-
	 *					This is available only in ESF Open Beta.
	 * Forward params:	function(this)
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_ESF_DoesPrimaryAttack, this);
	 */
	Ham_ESF_DoesPrimaryAttack,

	/**
	 * Description:		-
	 *					This is available only in ESF Open Beta.
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_ESF_RemoveSpecialModes, this);
	 */
	Ham_ESF_RemoveSpecialModes,

	/**
	 * Description:		-
	 *					This is available only in ESF Open Beta.
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_ESF_StopTurbo, this);
	 */
	Ham_ESF_StopTurbo,

	/**
	 * Description:		-
	 *					This is available only in ESF Open Beta.
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_ESF_TakeBean, this);
	 */
	Ham_ESF_TakeBean,

	/**
	 * Description:		-
	 *					This is available only in ESF Open Beta.
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_ESF_GetPowerLevel, this);
	 */
	Ham_ESF_GetPowerLevel,

	/**
	 * Description:		-
	 *					This is available only in ESF Open Beta.
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_ESF_RemoveAllOtherWeapons, this);
	 */
	Ham_ESF_RemoveAllOtherWeapons,

	/**
	 * Description:		-
	 *					This is available only in ESF Open Beta.
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_ESF_StopSwoop, this);
	 */
	Ham_ESF_StopSwoop,

	/**
	 * Description:		-
	 *					This is available only in ESF Open Beta.
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_ESF_SetDeathAnimation, this);
	 */
	Ham_ESF_SetDeathAnimation,

	/**
	 * Description:		-
	 *					This is available only in ESF Open Beta.
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_ESF_SetModel, this);
	 */
	Ham_ESF_SetModel,

	/**
	 * Description:		-
	 *					This is available only in ESF Open Beta.
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_ESF_AddAttacks, this);
	 */
	Ham_ESF_AddAttacks,

	/**
	 * Description:		-
	 *					This is available only in ESF Open Beta.
	 * Forward params:	function(this, const value[], const othervalue[], somevalue)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_ESF_EmitClassSound, this, const value[], const othervalue[], somevalue);
	 */
	Ham_ESF_EmitClassSound,

	/**
	 * Description:		-
	 *					This is available only in ESF Open Beta.
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_ESF_CheckLightning, this);
	 */
	Ham_ESF_CheckLightning,

	/**
	 * Description:		-
	 *					This is available only in ESF Open Beta.
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_ESF_FreezeControls, this);
	 */
	Ham_ESF_FreezeControls,

	/**
	 * Description:		-
	 *					This is available only in ESF Open Beta.
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_ESF_UnFreezeControls, this);
	 */
	Ham_ESF_UnFreezeControls,

	/**
	 * Description:		-
	 *					This is available only in ESF Open Beta.
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_ESF_UpdateKi, this);
	 */
	Ham_ESF_UpdateKi,

	/**
	 * Description:		-
	 *					This is available only in ESF Open Beta.
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_ESF_UpdateHealth, this);
	 */
	Ham_ESF_UpdateHealth,

	/**
	 * Description:		-
	 *					This is available only in ESF Open Beta.
	 * Forward params:	function(this)
	 * Return type:		Vector.
	 * Execute params:	ExecuteHam(Ham_ESF_GetTeleportDir, this, output[3]);
	 */
	Ham_ESF_GetTeleportDir,

	/**
	 * Description:		Unsure.
	 * Forward params:	function(this)
	 * Return type:		Integer.
	 * Execute params:	ExecuteHam(Ham_ESF_Weapon_HolsterMeleed, this);
	 */
	Ham_ESF_Weapon_HolsterWhenMeleed,


	/**
	 * The following functions are specific to Natural Selection.
	 */

	/**
	 * Description:		-
	 * Forward params:	function(this, controller, Float:value)
	 * Return type:		Float.
	 * Execute params:	ExecuteHam(Ham_SetBoneController, this, controller, Float:value)
	 */
	Ham_NS_SetBoneController,

	/**
	 * Description:		-
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_NS_SaveDataForReset, this)
	 */
	Ham_NS_SaveDataForReset,

	/**
	 * Description:		-
	 * Forward params:	function(this)
	 * Return type:		Integer.
	 * Execute params:	ExecuteHam(Ham_NS_GetHull, this)
	 */
	Ham_NS_GetHull,

	/**
	 * Description:		-
	 * Forward params:	function(this)
	 * Return type:		Float.
	 * Execute params:	ExecuteHam(Ham_NS_GetMaxWalkSpeed, this)
	 */
	Ham_NS_GetMaxWalkSpeed,

	/**
	 * Description:		-
	 * Forward params:	function(this, const teamID[])
	 * Return type:		String (string length returned and string byref'd in ExecuteHam).
	 * Execute params:	ExecuteHam(Ham_NS_SetTeamID, this, const teamID[])
	 */
	Ham_NS_SetTeamID,

	/**
	 * Description:		-
	 * Forward params:	function(this)
	 * Return type:		Integer.
	 * Execute params:	ExecuteHam(Ham_NS_GetPlayerClass, this)
	 */
	Ham_NS_GetEffectivePlayerClass,

	/**
	 * Description:		-
	 * Forward params:	function(this)
	 * Return type:		Integer.
	 * Execute params:	ExecuteHam(Ham_NS_GetAuthenticationMask, this)
	 */
	Ham_NS_GetAuthenticationMask,

	/**
	 * Description:		-
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_NS_EffectivePlayerClassChanged, this)
	 */
	Ham_NS_EffectivePlayerClassChanged,

	/**
	 * Description:		-
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_NS_NeedsTeamUpdate, this)
	 */
	Ham_NS_NeedsTeamUpdate,

	/**
	 * Description:		-
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_NS_SendTeamUpdate, this)
	 */
	Ham_NS_SendTeamUpdate,

	/**
	 * Description:		-
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_NS_SendWeaponUpdate, this)
	 */
	Ham_NS_SendWeaponUpdate,

	/**
	 * Description:		-
	 * Forward params:	function(this, idOther)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_NS_InitPlayerFromSpawn, this, idOther)
	 */
	Ham_NS_InitPlayerFromSpawn,

	/**
	 * Description:		-
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_NS_PackDeadPlayerItems, this)
	 */
	Ham_NS_PackDeadPlayerItems,

	/**
	 * Description:		Gets sequence name based on index.
	 *					animationName are passed by reference in ExecuteHam. outputLength is the max output length.
	 * Forward params:	function(this, activity, const animationName[], bool:somevalue)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_NS_GetAnimationForActivity, this, activity, output[], bool:somevalue, outputLength)
	 */
	Ham_NS_GetAnimationForActivity,

	/**
	 * Description:		-
	 * Forward params:	function(this, const Float:position[3], const Float:viewAngles[3])
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_NS_StartObserver, this, const Float:position[3], const Float:viewAngles[3])
	 */
	Ham_NS_StartObserver,

	/**
	 * Description:		-
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_NS_StopObserver, this)
	 */
	Ham_NS_StopObserver,

	/**
	 * Description:		-
	 * Forward params:	function(this)
	 * Return type:		Float.
	 * Execute params:	ExecuteHam(Ham_NS_GetAdrenalineFactor, this)
	 */
	Ham_NS_GetAdrenalineFactor,

	/**
	 * Description:		-
	 * Forward params:	function(this, const name[], bool:showpickup))
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_NS_GiveNamedItem, this, const name[], bool:showpickup)
	 */
	Ham_NS_GiveNamedItem,

	/**
	 * Description:		-
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_NS_Suicide, this)
	 */
	Ham_NS_Suicide,

	/**
	 * Description:		-
	 * Forward params:	function(this)
	 * Return type:		Integer.
	 * Execute params:	ExecuteHam(Ham_NS_GetCanUseWeapon, this)
	 */
	Ham_NS_GetCanUseWeapon,

	/**
	 * Description:		-
	 * Forward params:	function(this)
	 * Return type:		Float.
	 * Execute params:	ExecuteHam(Ham_NS_Weapon_GetWeapPrimeTime, this)
	 */
	Ham_NS_Weapon_GetWeaponPrimeTime,

	/**
	 * Description:		-
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_NS_Weapon_PrimeWeapon, this)
	 */
	Ham_NS_Weapon_PrimeWeapon,

	/**
	 * Description:		-
	 * Forward params:	function(this)
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_NS_Weapon_GetIsWeaponPrimed, this)
	 */
	Ham_NS_Weapon_GetIsWeaponPrimed,

	/**
	 * Description:		-
	 * Forward params:	function(this)
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_NS_Weapon_GetIsWeapPriming, this)
	 */
	Ham_NS_Weapon_GetIsWeaponPriming,

	/**
	 * Description:		-
	 * Forward params:	function(this, const viewModel[], const weaponModel[], anim, const animExt[], skiplocal, body)
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_NS_Weapon_DefaultDeploy, this, const viewModel[], const weaponModel[], anim, const animExt[], skiplocal, body)
	 */
	Ham_NS_Weapon_DefaultDeploy,

	/**
	 * Description:		-
	 * Forward params:	function(this, clipsize, anim, Float:delay, body)
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_NS_Weapon_DefaultReload, this, clipsize, anim, Float:delay, body)
	 */
	Ham_NS_Weapon_DefaultReload,

	/**
	 * Description:		-
	 * Forward params:	function(this)
	 * Return type:		Float.
	 * Execute params:	ExecuteHam(Ham_NS_Weapon_GetDeployTime, this)
	 */
	Ham_NS_Weapon_GetDeployTime,


	/**
	 * The following functions are specific to Sven Co-op.
	 */

	/**
	 * Description:		Returns the type of group (i.e, "houndeye", or "human military"
	 *					so that monsters with different classnames still realize that they are teammates.
	 *					(overridden for monsters that form groups)
	 *					Classes list:
	 *						CLASS_NONE				0
	 *						CLASS_MACHINE			1
	 *						CLASS_PLAYER			2
	 * 						CLASS_HUMAN_PASSIVE		3
	 *						CLASS_HUMAN_MILITARY	4
	 *						CLASS_ALIEN_MILITARY	5
	 *						CLASS_ALIEN_PASSIVE		6
	 *						CLASS_ALIEN_MONSTER		7
	 *						CLASS_ALIEN_PREY		8
	 *						CLASS_ALIEN_PREDATOR	9
	 *						CLASS_INSECT			10
	 *						CLASS_PLAYER_ALLY		11
	 *						CLASS_PLAYER_BIOWEAPON	12
	 *						CLASS_ALIEN_BIOWEAPON	13
	 *						CLASS_XRACE_PITDRONE	14
	 *						CLASS_XRACE_SHOCK		15
	 *						CLASS_BARNACLE			99
	 * Forward params:	function(this, class)
	 * Return type:		Integer.
	 * Execute params:	ExecuteHam(Ham_SC_GetClassification, this, class)
	 */
	Ham_SC_GetClassification,

	/**
	 * Description:		Whether entity is a monter.
	 * Forward params:	function(this)
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_SC_IsMonster, this)
	 */
	Ham_SC_IsMonster,

	/**
	 * Description:		Whether entity uses PhysX feature.
	 * Forward params:	function(this)
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_SC_IsPhysX, this)
	 */
	Ham_SC_IsPhysX,

	/**
	 * Description:		Whether this is a point entity.
	 * Forward params:	function(this)
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_SC_IsPointEntity, this)
	 */
	Ham_SC_IsPointEntity,

	/**
	 * Description:		Whether entity is a machine.
	 * Forward params:	function(this)
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_SC_IsMachine, this)
	 */
	Ham_SC_IsMachine,

	/**
	 * Description:		Removes the entity and all its content in critical situation.
	 * Forward params:	function(this)
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_SC_CriticalRemove, this)
	 */
	Ham_SC_CriticalRemove,

	/**
	 * Description:		Updates global tables that need to know about entities being removed.
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(UpdateOnRemove, this)
	 */
	Ham_SC_UpdateOnRemove,

	/**
	 * Description:		Returns true if a line can be traced from the caller's eyes to the target vector.
	 * Forward params:	function(this, entity, bool:ignoreGlass)
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_SC_FVisible, this, entity, bool:ignoreGlass)
	 */
	Ham_SC_FVisible,

	/**
	 * Description:		Returns true if a line can be traced from the given point to the target point.
	 * Forward params:	function(this, const Float:target[3], const Float:start[3])
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_SC_FVisibleFromPos, this, const Float:target[3], const Float:start[3])
	 */
	Ham_SC_FVisibleFromPos,

	/**
	 * Description:		Returns true if passed in entity is facing current entity.
	 *					Some examples of dotProduct value :
	 *					VIEW_FIELD_FULL -1.0
	 *					VIEW_FIELD_WIDE -0.7
	 *					VIEW_FIELD_NARROW 0.7
	 *					VIEW_FIELD_ULTRA_NARROW 0.9
	 * Forward params:	function(this, entTest, Float:dotProduct)
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_SC_IsFacing, this, entTest, Float:dotProduct)
	 */
	Ham_SC_IsFacing,

	/**
	 * Description:		Gets points without killing an entity.
	 * Forward params:	function(this, Float:damage)
	 * Return type:		Float.
	 * Execute params:	ExecuteHam(Ham_SC_GetPointsForDamage, this, Float:damage)
	 */
	Ham_SC_GetPointsForDamage,

	/**
	 * Description:		Gets points for making some damage.
	 * Forward params:	function(this, attacker, inflictor, Float:damage)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_SC_GetDamagePoints, this, attacker, inflictor, Float:damage)
	 */
	Ham_SC_GetDamagePoints,

	/**
	 * Description:		Constructor.
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_SC_OnCreate, this)
	 */
	Ham_SC_OnCreate,

	/**
	 * Description:		Desctructor.
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_SC_OnDestroy, this)
	 */
	Ham_SC_OnDestroy,

	/**
	 * Description:		Returns false if the entity is somehow invalid.
	 * Forward params:	function(this)
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_SC_IsValidEntity, this)
	 */
	Ham_SC_IsValidEntity,

	/**
	 * Description:		Checks if this monster should fade out.
	 * Forward params:	function(this)
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_SC_ShouldFadeOnDeath, this)
	 */
	Ham_SC_ShouldFadeOnDeath,

	/**
	 * Description:		Sets up a friendly monster.
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_SC_SetupFriendly, this)
	 */
	Ham_SC_SetupFriendly,

	/**
	 * Description:		Tries to revive a monster.
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_SC_ReviveThink, this)
	 */
	Ham_SC_ReviveThink,

	/**
	 * Description:		Revives a monster.
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_SC_Revive, this)
	 */
	Ham_SC_Revive,

	/**
	 * Description:		Final bit of initization before a monster is turned over to the AI.
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_SC_StartMonster, this)
	 */
	Ham_SC_StartMonster,

	/**
	 * Description:		Surveys conditions and set appropriate conditions bits for attack types.
	 * Forward params:	function(this, Float:dot, Float:dist)
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_SC_CheckRangeAttack1_Move, this, Float:dot, Float:dist)
	 */
	Ham_SC_CheckRangeAttack1_Move,

	/**
	 * Description:		Surveys conditions and set appropriate conditions bits for attack types.
	 * Forward params:	function(this, Float:dot, Float:dist)
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_SC_CheckRangeAttack2_Move, this, Float:dot, Float:dist)
	 */
	Ham_SC_CheckRangeAttack2_Move,

	/**
	 * Description:		Surveys conditions and set appropriate conditions bits for attack types.
	 * Forward params:	function(this, Float:dot, Float:dist)
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_SC_CheckMeleeAttack1_Move, this, Float:dot, Float:dist)
	 */
	Ham_SC_CheckMeleeAttack1_Move,

	/**
	 * Description:		Surveys conditions and set appropriate conditions bits for attack types.
	 * Forward params:	function(this, Float:dot, Float:dist)
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_SC_CheckMeleeAttack2_Move, this, Float:dot, Float:dist)
	 */
	Ham_SC_CheckMeleeAttack2_Move,

	/**
	 * Description:		Checks tank usage.
	 * Forward params:	function(this)
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_SC_CheckTankUsage, this)
	 */
	Ham_SC_CheckTankUsage,

	/**
	 * Description:		Sets a monster's gait activity.
	 * Forward params:	function(this)
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_SC_SetGaitActivity, this)
	 */
	Ham_SC_SetGaitActivity,

	/**
	 * Description:		Tries to overcome local obstacles by triangulating a path around them.
	 * Forward params:	function(this, const Float:start[3], const Float:end[3], Float:dist, targetEnt, Float:apex[3], Float:apex2[3], bool:coverPath)
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_SC_FTriangulate, this, const Float:start[3], const Float:end[3], Float:dist, targetEnt, Float:apex[3], Float:apex2[3], bool:coverPath )
	 */
	Ham_SC_FTriangulate,

	/**
	 * Description:		Tries to overcome local obstacles by triangulating a path around them.
	 * Forward params:	function(this, const Float:start[3], const Float:end[3], Float:dist, targetEnt, Float:apex[3])
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_SC_FTriangulateExtension, this, const Float:start[3], const Float:end[3], Float:dist, targetEnt, Float:apex[3])
	 */
	Ham_SC_FTriangulateExtension,

	/**
	 * Description:		Tries to find a nearby node that will hide the caller from its enemy.
	 *					If supplied, search will return a node at least as far away as minDist, but no farther than maxDist.
	 *					If maxDist isn't supplied, it defaults to a reasonable value.
	 * Forward params:	function(this, const Float:threat[3], const Float:viewOffset[3], Float:minDist, Float:maxDist)
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_SC_FindCoverGrenade, this, const Float:threat[3], const Float:viewOffset[3], Float:minDist, Float:maxDist)
	 */
	Ham_SC_FindCoverGrenade,

	/**
	 * Description:		Tries to find a nearby node that will hide the caller from its enemy.
	 *					If supplied, search will return a node at least as far away as minDist, but no farther than maxDist.
	 *					If maxDist isn't supplied, it defaults to a reasonable value.
	 * Forward params:	function(this, const Float:threat[3], const Float:viewOffset[3], Float:minDist, Float:maxDist)
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_SC_FindCoverDistance, this, const Float:threat[3], const Float:viewOffset[3], Float:minDist, Float:maxDist)
	 */
	Ham_SC_FindCoverDistance,

	/**
	 * Description:		Tries to find a nearby node that will hide the caller from its enemy.
	 *					If supplied, search will return a node at least as far away as minDist, but no farther than maxDist.
	 *					If maxDist isn't supplied, it defaults to a reasonable value.
	 * Forward params:	function(this, const Float:threat[3], const Float:viewOffset[3], Float:minDist, Float:maxDist)
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_SC_FindAttackPoint, this, const Float:threat[3], const Float:viewOffset[3], Float:minDist, Float:maxDist)
	 */
	Ham_SC_FindAttackPoint,

	/**
	 * Description:		Determines whether or not the chosen cover location is a good one to move to.
	 *					Currently based on proximity to others in the squad.
	 * Forward params:	function(this, const Float:coverLocation[3])
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_SC_FValidateCover, this, const Float:coverLocation[3])
	 */
	Ham_SC_FValidateCover,

	/**
	 * Description:		Checks for possibility of friendly fire.
	 * Forward params:	function(this)
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_SC_NoFriendlyFire, this)
	 */
	Ham_SC_NoFriendlyFire1,

	/**
	 * Description:		Checks for possibility of friendly fire.
	 * Forward params:	function(this, const Float:pos[3])
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_SC_NoFriendlyFire2, this, const Float:pos[3])
	 */
	Ham_SC_NoFriendlyFire2,

	/**
	 * Description:		Checks for possibility of friendly fire.
	 * Forward params:	function(this, const Float:pos[3], targetEnt)
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_SC_NoFriendlyFire3, this, const Float:pos[3], targetEnt)
	 */
	Ham_SC_NoFriendlyFire3,

	/**
	 * Description:		Checks for possibility of friendly fire from the calling monster's origin to toPos.
	 * Forward params:	function(this, const Float:toPos[3])
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_SC_NoFriendlyFireToPos, this, const Float:toPos[3])
	 */
	Ham_SC_NoFriendlyFireToPos,

	/**
	 * Description:		Same as FVisible but from gun position.
	 * Forward params:	function(this, entity, Float:pos[3])
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_SC_FVisibleGunPos, this, entity, Float:pos[3])
	 */
	Ham_SC_FVisibleGunPos,

	/**
	 * Description:		Checks for monsters in this generic cone.
	 * Forward params:	function(this, entity, const Float:pos[3])
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_SC_FInBulletCone, this, entity, const Float:pos[3])
	 */
	Ham_SC_FInBulletCone,

	/**
	 * Description:		-
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_SC_CallGibMonster, this)
	 */
	Ham_SC_CallGibMonster,

	/**
	 * Description:		-
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_SC_CheckTimeBasedDamage, this)
	 */
	Ham_SC_CheckTimeBasedDamage,

	/**
	 * Description:		-
	 * Forward params:	function(this)
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_SC_IsMoving, this)
	 */
	Ham_SC_IsMoving,

	/**
	 * Description:		-
	 * Forward params:	function(this)
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_SC_IsPlayerFollowing, this)
	 */
	Ham_SC_IsPlayerFollowing,

	/**
	 * Description:		-
	 * Forward params:	function(this, idleader)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_SC_StartPlayerFollowing, this, idleader)
	 */
	Ham_SC_StartPlayerFollowing,

	/**
	 * Description:		-
	 * Forward params:	function(this, bool:clearSchedule)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_SC_StopPlayerFollowing, this, bool:clearSchedule)
	 */
	Ham_SC_StopPlayerFollowing,

	/**
	 * Description:		-
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_SC_UseSound, this)
	 */
	Ham_SC_UseSound,

	/**
	 * Description:		-
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_SC_UnUseSound, this)
	 */
	Ham_SC_UnUseSound,

	/**
	 * Description:		-
	 * Forward params:	function(this, idOther)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_SC_RideMonster, this, idOther)
	 */
	Ham_SC_RideMonster,

	/**
	 * Description:		-
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_SC_CheckAndApplyGenericAttacks, this)
	 */
	Ham_SC_CheckAndApplyGenericAttacks,

	/**
	 * Description:		-
	 * Forward params:	function(this)
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_SC_CheckScared, this)
	 */
	Ham_SC_CheckScared,

	/**
	 * Description:		-
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_SC_CheckCreatureDanger, this)
	 */
	Ham_SC_CheckCreatureDanger,

	/**
	 * Description:		-
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_SC_CheckFallDamage, this)
	 */
	Ham_SC_CheckFallDamage,

	/**
	 * Description:		-
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_SC_CheckRevival, this)
	 */
	Ham_SC_CheckRevival,

	/**
	 * Description:		-
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_SC_MedicCallSound, this)
	 */
	Ham_SC_MedicCallSound,


	/**
	 * Description:		-
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_SC_MedicCallSound, this)
	 */
	Ham_SC_Player_MenuInputPerformed,

	/**
	 * Description:		-
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_SC_Player_IsMenuInputDone, this)
	 */
	Ham_SC_Player_IsMenuInputDone,

	/**
	 * Description:		-
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_SC_Player_SpecialSpawn, this)
	 */
	Ham_SC_Player_SpecialSpawn,

	/**
	 * Description:		-
	 * Forward params:	function(this)
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_SC_Player_IsValidInfoEntity, this)
	 */
	Ham_SC_Player_IsValidInfoEntity,

	/**
	 * Description:		-
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_SC_Player_LevelEnd, this)
	 */
	Ham_SC_Player_LevelEnd,

	/**
	 * Description:		-
	 * Forward params:	function(this, voteType)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_SC_Player_VoteStarted, this, voteType)
	 */
	Ham_SC_Player_VoteStarted,

	/**
	 * Description:		-
	 * Forward params:	function(this, voteType)
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_SC_Player_CanStartNextVote, this, voteType)
	 */
	Ham_SC_Player_CanStartNextVote,

	/**
	 * Description:		-
	 * Forward params:	function(this, voteInput)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_SC_Player_Vote, this, voteInput)
	 */
	Ham_SC_Player_Vote,

	/**
	 * Description:		-
	 * Forward params:	function(this)
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_SC_Player_HasVoted, this)
	 */
	Ham_SC_Player_HasVoted,

	/**
	 * Description:		-
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_SC_Player_ResetVote, this)
	 */
	Ham_SC_Player_ResetVote,

	/**
	 * Description:		-
	 * Forward params:	function(this)
	 * Return type:		Integer.
	 * Execute params:	ExecuteHam(Ham_SC_Player_LastVoteInput, this)
	 */
	Ham_SC_Player_LastVoteInput,

	/**
	 * Description:		-
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_SC_Player_InitVote, this)
	 */
	Ham_SC_Player_InitVote,

	/**
	 * Description:		-
	 * Forward params:	function(this)
	 * Return type:		Float.
	 * Execute params:	ExecuteHam(Ham_SC_Player_StartNextVote, this)
	 */
	Ham_SC_Player_TimeToStartNextVote,

	/**
	 * Description:		-
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_SC_Player_ResetView, this)
	 */
	Ham_SC_Player_ResetView,

	/**
	 * Description:		-
	 * Forward params:	function(this)
	 * Return type:		Float.
	 * Execute params:	ExecuteHam(Ham_SC_Player_GetLogFrequency, this)
	 */
	Ham_SC_Player_GetLogFrequency,

	/**
	 * Description:		-
	 * Forward params:	function(this)
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_SC_Player_LogPlayerStats, this)
	 */
	Ham_SC_Player_LogPlayerStats,

	/**
	 * Description:		-
	 * Forward params:	function(this, idPlayer, Float:time)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_SC_Player_DisableCollision, this, idPlayer, Float:time)
	 */
	Ham_SC_Player_DisableCollisionWithPlayer,

	/**
	 * Description:		-
	 * Forward params:	function(this, idPlayer, bool:testIntersection)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_SC_Player_EnableCollision, this, idPlayer, bool:testIntersection)
	 */
	Ham_SC_Player_EnableCollisionWithPlayer,

	/**
	 * Description:		-
	 * Forward params:	function(this, idPlayer)
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_SC_Player_CanTouchPlayer, this, idPlayer)
	 */
	Ham_SC_Player_CanTouchPlayer,


	/**
	 * Description:		-
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_SC_Item_Materialize, this)
	 */
	Ham_SC_Item_Materialize,


	/**
	 * Description:		-
	 * Forward params:	function(this, const Float:moving[3], const Float:standing[3], const Float:crouched[3])
	 * Return type:		Vector, byreffed in execute.
	 * Execute params:	ExecuteHam(Ham_SC_Weapon_BulletAccuracy, this, const Float:moving[3], const Float:standing[3], const Float:crouched[3], Float:output[3])
	 */
	Ham_SC_Weapon_BulletAccuracy,

	/**
	 * Description:		-
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_SC_Weapon_TertiaryAttack, this)
	 */
	Ham_SC_Weapon_TertiaryAttack,

	/**
	 * Description:		-
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_SC_Weapon_BurstSupplement, this)
	 */
	Ham_SC_Weapon_BurstSupplement,

	/**
	 * Description:		-
	 * Forward params:	function(this, const alternative[] = "")
	 * Return type:		String (string length returned and string byref'd in ExecuteHam).
	 * Execute params:	ExecuteHam(Ham_SC_Weapon_GetP_Model, this, const alternative[] = "", buffer[], size)
	 */
	Ham_SC_Weapon_GetP_Model,

	/**
	 * Description:		-
	 * Forward params:	function(this, const alternative[] = "")
	 * Return type:		String (string length returned and string byref'd in ExecuteHam).
	 * Execute params:	ExecuteHam(Ham_SC_Weapon_GetW_Model, this, const alternative[] = "", buffer[], size)
	 */
	Ham_SC_Weapon_GetW_Model,

	/**
	 * Description:		-
	 * Forward params:	function(this, const alternative[] = "")
	 * Return type:		String (string length returned and string byref'd in ExecuteHam).
	 * Execute params:	ExecuteHam(Ham_SC_Weapon_GetV_Model, this, const alternative[] = "", buffer[], size)
	 */
	Ham_SC_Weapon_GetV_Model,

	/**
	 * Description:		-
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_SC_Weapon_PrecacheCustomMdl, this)
	 */
	Ham_SC_Weapon_PrecacheCustomModels,

	/**
	 * Description:		-
	 * Forward params:	function(this)
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_SC_Weapon_IsMultiplayer, this)
	 */
	Ham_SC_Weapon_IsMultiplayer,

	/**
	 * Description:		-
	 * Forward params:	function(this)
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_SC_Weapon_FRunfuncs, this)
	 */
	Ham_SC_Weapon_FRunfuncs,

	/**
	 * Description:		-
	 * Forward params:	function(this, fov)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_SC_Weapon_SetFOV, this, fov)
	 */
	Ham_SC_Weapon_SetFOV,

	/**
	 * Description:		-
	 * Forward params:	function(this)
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_SC_Weapon_FCanRun, this)
	 */
	Ham_SC_Weapon_FCanRun,

	/**
	 * Description:		-
	 * Forward params:	function(this, Float:frametime)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_SC_Weapon_CustomDecrement, this, Float:frametime)
	 */
	Ham_SC_Weapon_CustomDecrement,

	/**
	 * Description:		-
	 * Forward params:	function(this, const model[])
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_SC_Weapon_SetV_Model, this, const model[])
	 */
	Ham_SC_Weapon_SetV_Model,

	/**
	 * Description:		-
	 * Forward params:	function(this, const model[])
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_SC_Weapon_SetP_Model, this, const model[])
	 */
	Ham_SC_Weapon_SetP_Model,

	/**
	 * Description:		-
	 * Forward params:	function(this, skin)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_SC_Weapon_ChangeWeaponSkin, this, skin)
	 */
	Ham_SC_Weapon_ChangeWeaponSkin,


	/**
	 * LATE ADDITIONS (2013)
	 */

	/**
	 * Description:		Normally called whenever an entity dies.
	 * Forward params:	function(this, idinflictor, idattacker, shouldgib)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_TFC_Killed, this, idinflictor, idattacker, shouldgib);
	 */
	Ham_TFC_Killed,

	/**
	 * Description:		Returns whether an entity is activated.
	 * Forward params:	function(this, idActivator);
	 * Return type:		Integer.
	 * Execute params:	ExecuteHam(Ham_IsTriggered, this, idActivator);
	 */
	Ham_TFC_IsTriggered,

	/**
	 * Description:		Sends an animation event for the weapon. skiplocal is 1 if client is predicting weapon animations.
	 * Forward params:	function(this, anim, skiplocal);
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_TFC_Weapon_SendWeaponAnim, this, anim, skiplocal);
	 */
	Ham_TFC_Weapon_SendWeaponAnim,

	/**
	 * Description:		Gets next attack delay.
	 * Forward params:	function(this, Float:delay)
	 * Return type:		Float (byref'd in ExecuteHam).
	 * Execute params:	ExecuteHam(Ham_TFC_Weapon_GetNextAttackDelay, this, Float:delay, Float:output);
	 */
	Ham_TFC_Weapon_GetNextAttackDelay,


	/**
	 * Description:		Usually called whenever an entity gets a form of a heal.
	 * Forward params:	function(this, Float:health, damagebits, health_cap);
	 * Return type:		Integer.
	 * Execute params:	ExecuteHam(Ham_SC_TakeHealth, this, Float:health, damagebits, health_cap);
	 */
	Ham_SC_TakeHealth,

	/**
	 * Description:		Usually called whenever an entity gets a form of armor.
	 * Forward params:	function(this, Float:armor, damagebits, armor_cap);
	 * Return type:		Integer.
	 * Execute params:	ExecuteHam(Ham_SC_TakeArmor, this, Float:armor, damagebits, armor_cap);
	 */
	Ham_SC_TakeArmor,

	/**
	 * Description:		Gives ammo to the entity.
	 * Forward params:	function(this, amount, const name[], max, const bool:fromPlayer)
	 * Return type:		Integer.
	 * Execute params:	ExecuteHam(Ham_SC_GiveAmmo, this, amount, "type", max, fromPlayer);
	 */
	Ham_SC_GiveAmmo,

	/**
	 * Description:		Determines if we should ignore damage.
	 * Forward params:	function(this, idattacker);
	 * Return type:		Integer.
	 * Execute params:	ExecuteHam(Ham_SC_CheckAttacker, this, idattacker);
	 */
	Ham_SC_CheckAttacker,

	/**
	 * Description:		Determines if a player is connected.
	 * Forward params:	function(this);
	 * Return type:		Integer.
	 * Execute params:	ExecuteHam(Ham_SC_Player_IsConnected, this);
	 */
	Ham_SC_Player_IsConnected,


	/**
	 * Description:		Sends an animation event for the weapon. skiplocal is 1 if client is predicting weapon animations.
	 * Forward params:	function(this, anim, skiplocal);
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_DOD_Weapon_SendWeaponAnim, this, anim, skiplocal);
	 */
	Ham_DOD_Weapon_SendWeaponAnim,


	/**
	 * Description:		-
	 * Forward params:	function(this);
	 * Return type:		Integer (boolean).
	 * Execute params:	ExecuteHam(Ham_CS_Item_IsWeapon, this);
	 */
	Ham_CS_Item_IsWeapon,


	/**
	 * Description:		Returns the id of the entity if its class is derived off of CBaseSquadTalkMonster, -1 otherwise.
	 * Forward params:	function(this)
	 * Return type:		Entity.
	 * Execute params:	ExecuteHam(Ham_OPF_MySquadTalkMonsterPointer, this);
	 */
	Ham_OPF_MySquadTalkMonsterPointer,

	/**
	 * Description:		-
	 * Forward params:	function(this)
	 * Return type:		Float (byref'd in ExecuteHam).
	 * Execute params:	ExecuteHam(Ham_OPF_WeaponTimeBase, this);
	 */
	Ham_OPF_WeaponTimeBase,


	/**
	 * Description:		Called when the alternate attack of a weapon is triggered.
	 * Forward params:	function(this)
	 * Return type:		None.
	 * Execute params:	ExecuteHam(Ham_TS_Weapon_AlternateAttack, this);
	 */
	Ham_TS_Weapon_AlternateAttack,


	/**
	 * Description:		Gets item infos.
	 * Forward params:	function(this, iteminfo_handle);
	 * Return type:		Integer.
	 * Execute params:	ExecuteHam(Ham_Item_GetItemInfo, this, iteminfo_handle);
	 *					Use CreateHamItemInfo() to pass a new ItemInfo handle.
	 */
	Ham_Item_GetItemInfo,


	/**
	 * DONT USE ME LOL
	 */
	HAM_LAST_ENTRY_DONT_USE_ME_LOL
};

/**
 * Ham error types.
 */
enum HamError
{
	HAM_OK = 0,

	HAM_INVALID_FUNC,			// The function is not valid
	HAM_FUNC_NOT_CONFIGURED,	// This function is not configured in hamdata.ini

	HAM_ERR_END
};

/**
 * Constants for usage with [Get|Set]HamItemInfo
 */
enum HamItemInfo
{
	Ham_ItemInfo_iSlot,
	Ham_ItemInfo_iPosition,
	Ham_ItemInfo_pszAmmo1,
	Ham_ItemInfo_iMaxAmmo1,
	Ham_ItemInfo_pszAmmo2,
	Ham_ItemInfo_iMaxAmmo2,
	Ham_ItemInfo_pszName,
	Ham_ItemInfo_iMaxClip,
	Ham_ItemInfo_iId,
	Ham_ItemInfo_iFlags,
	Ham_ItemInfo_iWeight
};

// vim: set ts=4 sw=4 tw=99 noet:
//
// AMX Mod X, based on AMX Mod by Aleksander Naszko ("OLO").
// Copyright (C) The AMX Mod X Development Team.
//
// This software is licensed under the GNU General Public License, version 3 or higher.
// Additional exceptions apply. For full license details, see LICENSE.txt or visit:
//     https://alliedmods.net/amxmodx-license

//
// Ham Sandwich Functions
//

/**
 * Ham Sandwich is a module that is used to hook and call virtual functions of 
 *  entities.
 * Virtual functions are mod-specific functions.  This means that in order
 *  for this to work on a mod, it needs to be configured with the hamdata.ini
 *  file.
 * Be very careful with parameter passing to these functions.
 */

#if defined _hamsandwich_included
	#endinput
#endif
#define _hamsandwich_included

#include <ham_const>

#if AMXX_VERSION_NUM >= 175
	#pragma reqlib hamsandwich
	#if !defined AMXMODX_NOAUTOLOAD
		#pragma loadlib hamsandwich
	#endif
#else
	#pragma library hamsandwich
#endif

/**
 * Hooks the virtual table for the specified entity class.
 * An example would be: RegisterHam(Ham_TakeDamage, "player", "player_hurt");
 * Look at the Ham enum for parameter lists.
 *
 * @param function		The function to hook.
 * @param EntityClass	The entity classname to hook.
 * @param callback		The forward to call.
 * @param post			Whether or not to forward this in post.
 * @param specialbot	Whether or not to enable support for bot without "player" classname.
 * @return 				Returns a handle to the forward.  Use EnableHamForward/DisableHamForward to toggle the forward on or off.
 */
native HamHook:RegisterHam(Ham:function, const EntityClass[], const Callback[], Post=0, bool:specialbot = false);

/**
 * Hooks the virtual table for the player class.
 * An example would be: RegisterHam(Ham_TakeDamage, "player_hurt");
 * Look at the Ham enum for parameter lists.
 *
 * @param function		The function to hook.
 * @param callback		The forward to call.
 * @param post			Whether or not to forward this in post.
 * @return 				Returns a handle to the forward.  Use EnableHamForward/DisableHamForward to toggle the forward on or off.
 */
stock HamHook:RegisterHamPlayer(Ham:function, const Callback[], Post=0)
{
	return RegisterHam(function, "player", Callback, Post, .specialbot = true);
}

/**
 * Hooks the virtual table for the specified entity's class.
 * An example would be: RegisterHam(Ham_TakeDamage, id, "player_hurt");
 * Look at the Ham enum for parameter lists.
 * Note: This will cause hooks for the entire internal class that the entity is
 *       not exclusively for the provided entity.
 *
 * @param function		The function to hook.
 * @param EntityId		The entity classname to hook.
 * @param callback		The forward to call.
 * @param post			Whether or not to forward this in post.
 * @return 				Returns a handle to the forward.  Use EnableHamForward/DisableHamForward to toggle the forward on or off.
 */
native HamHook:RegisterHamFromEntity(Ham:function, EntityId, const Callback[], Post=0);


/**
 * Stops a ham forward from triggering.
 * Use the return value from RegisterHam as the parameter here!
 *
 * @param fwd			The forward to stop.
 */
native DisableHamForward(HamHook:fwd);

/**
 * Starts a ham forward back up.
 * Use the return value from RegisterHam as the parameter here!
 *
 * @param fwd			The forward to re-enable.
 */
native EnableHamForward(HamHook:fwd);

/**
 * Executes the virtual function on the entity.
 * Look at the Ham enum for parameter lists.
 *
 * @param function		The function to call.
 * @param id			The id of the entity to execute it on.
 */
native ExecuteHam(Ham:function, this, any:...);

/**
 * Executes the virtual function on the entity, this will trigger all hooks on that function.
 * Be very careful about recursion!
 * Look at the Ham enum for parameter lists.
 *
 * @param function		The function to call.
 * @param id			The id of the entity to execute it on.
 */
native ExecuteHamB(Ham:function, this, any:...);

/**
 * Gets the return status of the current hook.
 * This is useful to determine what return natives to use.
 *
 * @return				The current status of the hook (such as HAM_SUPERCEDE).
 */
native GetHamReturnStatus();

/**
 * Gets the return value of a hook for hooks that return integers or booleans.
 *
 * @param output		The variable to store the value in.
 */
native GetHamReturnInteger(&output);

/**
 * Gets the return value of a hook for hooks that return float.
 *
 * @param output		The variable to store the value in.
 */
native GetHamReturnFloat(&Float:output);

/**
 * Gets the return value of a hook for hooks that return Vectors.
 *
 * @param output		The variable to store the value in.
 */
native GetHamReturnVector(Float:output[3]);

/**
 * Gets the return value of a hook for hooks that return entities.
 *
 * @param output		The variable to store the value in. Will be -1 on null.
 */
native GetHamReturnEntity(&output);

/**
 * Gets the return value of a hook for hooks that return strings.
 *
 * @param output		The buffer to store the string in.
 * @param size			The string size of the buffer.
 */
native GetHamReturnString(output[], size);

/**
 * Gets the original return value of a hook for hooks that return integers or booleans.
 *
 * @param output		The variable to store the value in.
 */
native GetOrigHamReturnInteger(&output);

/**
 * Gets the original return value of a hook for hooks that return floats.
 *
 * @param output		The variable to store the value in.
 */
native GetOrigHamReturnFloat(&Float:output);

/**
 * Gets the original return value of a hook for hooks that return Vectors.
 *
 * @param output		The variable to store the value in.
 */
native GetOrigHamReturnVector(Float:output[3]);

/**
 * Gets the original return value of a hook for hooks that return entities.
 *
 * @param output		The variable to store the value in. -1 on null.
 */
native GetOrigHamReturnEntity(&output);

/**
 * Gets the original return value of a hook for hooks that return strings.
 *
 * @param output		The buffer to store the string in.
 * @param size			The size of the buffer.
 */
native GetOrigHamReturnString(output[], size);


/**
 * Sets the return value of a hook that returns an integer or boolean.
 * This needs to be used in conjunction with HAM_OVERRIDE or HAM_SUPERCEDE.
 *
 * @param value				The value to set the return to.
 */
native SetHamReturnInteger(value);

/**
 * Sets the return value of a hook that returns a float.
 * This needs to be used in conjunction with HAM_OVERRIDE or HAM_SUPERCEDE.
 *
 * @param value				The value to set the return to.
 */
native SetHamReturnFloat(Float:value);

/**
 * Sets the return value of a hook that returns a Vector.
 * This needs to be used in conjunction with HAM_OVERRIDE or HAM_SUPERCEDE.
 *
 * @param value				The value to set the return to.
 */
native SetHamReturnVector(const Float:value[3]);

/**
 * Sets the return value of a hook that returns an entity.  Set to -1 for null.
 * This needs to be used in conjunction with HAM_OVERRIDE or HAM_SUPERCEDE.
 *
 * @param value				The value to set the return to.
 */
native SetHamReturnEntity(value);

/**
 * Sets the return value of a hook that returns a string.
 * This needs to be used in conjunction with HAM_OVERRIDE or HAM_SUPERCEDE.
 *
 * @param value				The value to set the return to.
 */
native SetHamReturnString(const value[]);


/**
 * Sets a parameter on the fly of the current hook.  This has no effect in post hooks.
 * Use this on parameters that are integers.
 *
 * @param which				Which parameter to change.  Starts at 1, and works up from the left to right.  1 is always "this".
 * @param value				The value to change it to.
 */
native SetHamParamInteger(which, value);

/**
 * Sets a parameter on the fly of the current hook.  This has no effect in post hooks.
 * Use this on parameters that are floats.
 *
 * @param which				Which parameter to change.  Starts at 1, and works up from the left to right.  1 is always "this".
 * @param value				The value to change it to.
 */
native SetHamParamFloat(which, Float:value);

/**
 * Sets a parameter on the fly of the current hook.  This has no effect in post hooks.
 * Use this on parameters that are Vectors.
 *
 * @param which				Which parameter to change.  Starts at 1, and works up from the left to right.  1 is always "this".
 * @param value				The value to change it to.
 */
native SetHamParamVector(which, const Float:value[3]);

/**
 * Sets a parameter on the fly of the current hook.  This has no effect in post hooks.
 * Use this on parameters that are entities.
 *
 * @param which				Which parameter to change.  Starts at 1, and works up from the left to right.  1 is always "this".
 * @param value				The value to change it to.
 */
native SetHamParamEntity(which, value);

/**
 * Sets a parameter on the fly of the current hook.  This has no effect in post hooks.
 * Use this on parameters that are strings.
 *
 * @param which				Which parameter to change.  Starts at 1, and works up from the left to right.  1 is always "this".
 * @param ouput				The value to change it to.
 */
native SetHamParamString(which, const output[]);

/**
 * Sets a parameter on the fly of the current hook.  This has no effect in post hooks.
 * Use this on parameters that are trace result handles.
 *
 * @param which				Which parameter to change.  Starts at 1, and works up from the left to right.  1 is always "this".
 * @param tr_handle			The value to change it to.
 */
native SetHamParamTraceResult(which, tr_handle);

/**
 * Sets a parameter on the fly of the current hook.  This has no effect in post hooks.
 * Use this on parameters that are trace result handles.
 *
 * @param which				Which parameter to change.  Starts at 1, and works up from the left to right.  1 is always "this".
 * @param iteminfo_handle	The value to change it to.
 */
native SetHamParamItemInfo(which, iteminfo_handle);


/**
 * Gets a parameter on the fly of the current hook.
 * Use this on parameters that are iteminfo result handles.
 *
 * @param iteminfo_handle	Item info handle.
 * @param type				Item info type. See HamItemInfo constants.
 */
native GetHamItemInfo(iteminfo_handle, HamItemInfo:type, any:...);

/**
 * Sets a parameter on the fly of the current hook.
 * Use this on parameters that are iteminfo result handles.
 *
 * @param iteminfo_handle	Item info handle.
 * @param type				Item info type. See HamItemInfo_ constants.
 */
native SetHamItemInfo(iteminfo_handle, HamItemInfo:type, any:...);

/**
 * Creates an ItemInfo handle.  This value should never be altered.
 * The handle can be used in Get/SetHamItemInfo.
 *
 * NOTE: You must call FreeHamItemInfo() on every handle made with CreateHamItemInfo().
 *
 * @return			A new ItemInfo handle.
 */
native CreateHamItemInfo();

/** 
 * Frees an ItemIndo handle created with CreateHamItemInfo().  Do not call
 * this more than once per handle, or on handles not created through
 * CreateHamItemInfo().
 *
 * @param itemInfo_handle	ItemInfo handle created via CreateHamItemInfo().
 * @noreturn
 */
native FreeHamItemInfo(itemInfo_handle);


/**
 * Returns whether or not the function for the specified Ham is valid.
 * Things that would make it invalid would be bounds (an older module version
 *  may not have all of the functions), and the function not being found in
 *  the mod's hamdata.ini file.
 *
 * @param function		The function to look up.
 * @return				true if the function is valid, false otherwise.
 */
native bool:IsHamValid(Ham:function);

/**
 * This is used to compliment fakemeta's {get,set}_pdata_{int,float,string}.
 * This requires the mod to have the pev and base fields set in hamdata.ini.
 * Note this dereferences memory! Improper use of this will crash the server.
 * This will return an index of the corresponding cbase field in private data.
 * Returns -1 on a null entry.
 *
 * @param id			The entity to examine the private data.
 * @param offset		The windows offset of the data.
 * @param linuxdiff		The linux difference of the data.
 * @param macdiff		The mac os x difference of the data.
 * @return				The index of the corresponding pdata field. -1 for none set.
 */
native get_pdata_cbase(id, offset, linuxdiff=5, macdiff=5);

/**
 * This is used to compliment fakemeta's {get,set}_pdata_{int,float,string}.
 * This requires the mod to have the pev and base fields set in hamdata.ini.
 * This will set the corresponding cbase field in private data with the index.
 * Pass -1 to null the entry.
 *
 * @param id			The entity to examine the private data.
 * @param offset		The windows offset of the data.
 * @param value			The index to store, -1 for invalid
 * @param linuxdiff		The linux difference of the data.
 * @param macdiff		The mac os x difference of the data.
 */
native set_pdata_cbase(id, offset, value, linuxdiff=5, macdiff=5);

/**
 * This is similar to the get_pdata_cbase, however it does not dereference memory.
 * This is many times slower than get_pdata_cbase, and this should only be used 
 * for testing and finding of offsets, not actual release quality plugins.
 * This will return an index of the corresponding cbase field in private data.
 * Returns -1 on a null entry. -2 on an invalid entry.
 *
 * @param id			Entry to examine the private data.
 * @param offset		The windows offset of the data.
 * @param linuxdiff		The linux difference of the data.
 * @param macdiff		The mac os x difference of the data.
 * @return				The index of the corresponding pdata field, -1 for null, -2 for invalid.
 */
native get_pdata_cbase_safe(id, offset, linuxdiff=5, macdiff=5);




// This is the callback from the module, this handles any fatal errors.
// This will in turn call the "HamFilter(Ham:id, HamError:err, const reason[])" public, if it exists.
// Return PLUGIN_HANDLED from within the HamFilter to stop the plugin from failing.
// Any other return value will fail the plugin.
// You do not need to have a HamFilter, if there is none, all fatal errors will fail the plugin.
// Do not modify this!
public __fatal_ham_error(Ham:id, HamError:err, const reason[])
{
	
	new func=get_func_id("HamFilter", -1);
	new bool:fail=true;
	
	if (func != -1 && callfunc_begin_i(func, -1)==1)
	{
		callfunc_push_int(_:id);
		callfunc_push_int(_:err);
		callfunc_push_str(reason, false);
		if (callfunc_end()==PLUGIN_HANDLED)
		{
			fail=false;
		}
	}
	if (fail)
	{
		set_fail_state(reason);
	}
	
}
// vim: set ts=4 sw=4 tw=99 noet:
//
// AMX Mod X, based on AMX Mod by Aleksander Naszko ("OLO").
// Copyright (C) The AMX Mod X Development Team.
//
// This software is licensed under the GNU General Public License, version 3 or higher.
// Additional exceptions apply. For full license details, see LICENSE.txt or visit:
//     https://alliedmods.net/amxmodx-license

//
// Half-Life SDK Constants
//

#if defined _hlsdk_const_included
    #endinput
#endif
#define _hlsdk_const_included

/**
 * pev(entity, pev_button) or pev(entity, pev_oldbuttons) values
 */
#define IN_ATTACK                       (1<<0)
#define IN_JUMP                         (1<<1)
#define IN_DUCK                         (1<<2)
#define IN_FORWARD                      (1<<3)
#define IN_BACK                         (1<<4)
#define IN_USE                          (1<<5)
#define IN_CANCEL                       (1<<6)
#define IN_LEFT                         (1<<7)
#define IN_RIGHT                        (1<<8)
#define IN_MOVELEFT                     (1<<9)
#define IN_MOVERIGHT                    (1<<10)
#define IN_ATTACK2                      (1<<11)
#define IN_RUN                          (1<<12)
#define IN_RELOAD                       (1<<13)
#define IN_ALT1                         (1<<14)
#define IN_SCORE                        (1<<15)     // Used by client.dll for when scoreboard is held down

/**
 * pev(entity, pev_flags) values
 */
#define FL_FLY                          (1<<0)      // Changes the SV_Movestep() behavior to not need to be on ground
#define FL_SWIM                         (1<<1)      // Changes the SV_Movestep() behavior to not need to be on ground (but stay in water)
#define FL_CONVEYOR                     (1<<2)
#define FL_CLIENT                       (1<<3)
#define FL_INWATER                      (1<<4)
#define FL_MONSTER                      (1<<5)
#define FL_GODMODE                      (1<<6)
#define FL_NOTARGET                     (1<<7)
#define FL_SKIPLOCALHOST                (1<<8)      // Don't send entity to local host, it's predicting this entity itself
#define FL_ONGROUND                     (1<<9)      // At rest / on the ground
#define FL_PARTIALGROUND                (1<<10)     // Not all corners are valid
#define FL_WATERJUMP                    (1<<11)     // Player jumping out of water
#define FL_FROZEN                       (1<<12)     // Player is frozen for 3rd person camera
#define FL_FAKECLIENT                   (1<<13)     // JAC: fake client, simulated server side; don't send network messages to them
#define FL_DUCKING                      (1<<14)     // Player flag -- Player is fully crouched
#define FL_FLOAT                        (1<<15)     // Apply floating force to this entity when in water
#define FL_GRAPHED                      (1<<16)     // Worldgraph has this ent listed as something that blocks a connection
#define FL_IMMUNE_WATER                 (1<<17)
#define FL_IMMUNE_SLIME                 (1<<18)
#define FL_IMMUNE_LAVA                  (1<<19)
#define FL_PROXY                        (1<<20)     // This is a spectator proxy
#define FL_ALWAYSTHINK                  (1<<21)     // Brush model flag -- call think every frame regardless of nextthink - ltime (for constantly changing velocity/path)
#define FL_BASEVELOCITY                 (1<<22)     // Base velocity has been applied this frame (used to convert base velocity into momentum)
#define FL_MONSTERCLIP                  (1<<23)     // Only collide in with monsters who have FL_MONSTERCLIP set
#define FL_ONTRAIN                      (1<<24)     // Player is _controlling_ a train, so movement commands should be ignored on client during prediction.
#define FL_WORLDBRUSH                   (1<<25)     // Not moveable/removeable brush entity (really part of the world, but represented as an entity for transparency or something)
#define FL_SPECTATOR                    (1<<26)     // This client is a spectator, don't run touch functions, etc.
#define FL_CUSTOMENTITY                 (1<<29)     // This is a custom entity
#define FL_KILLME                       (1<<30)     // This entity is marked for death -- This allows the engine to kill ents at the appropriate time
#define FL_DORMANT                      (1<<31)     // Entity is dormant, no updates to client

/**
 * engfunc(EngFunc_WalkMove, entity, Float:yaw, Float:dist, iMode) iMode values
 */
#define WALKMOVE_NORMAL                 0           // Normal walkmove
#define WALKMOVE_WORLDONLY              1           // Doesn't hit ANY entities, no matter what the solid type
#define WALKMOVE_CHECKONLY              2           // Move, but don't touch triggers

/**
 * pev(entity, pev_movetype) values
 */
#define MOVETYPE_NONE                   0           // Never moves
#define MOVETYPE_WALK                   3           // Player only - moving on the ground
#define MOVETYPE_STEP                   4           // Gravity, special edge handling -- monsters use this
#define MOVETYPE_FLY                    5           // No gravity, but still collides with stuff
#define MOVETYPE_TOSS                   6           // Gravity/Collisions
#define MOVETYPE_PUSH                   7           // No clip to world, push and crush
#define MOVETYPE_NOCLIP                 8           // No gravity, no collisions, still do velocity/avelocity
#define MOVETYPE_FLYMISSILE             9           // Extra size to monsters
#define MOVETYPE_BOUNCE                 10          // Just like Toss, but reflect velocity when contacting surfaces
#define MOVETYPE_BOUNCEMISSILE          11          // Bounce w/o gravity
#define MOVETYPE_FOLLOW                 12          // Track movement of aiment
#define MOVETYPE_PUSHSTEP               13          // BSP model that needs physics/world collisions (uses nearest hull for world collision)

/**
 * pev(entity, pev_solid) values
 *
 * @note Some movetypes will cause collisions independent of SOLID_NOT and
 *       SOLID_TRIGGER when the entity moves. SOLID only effects OTHER entities
 *       colliding with this one when they move - UGH!
 */
#define SOLID_NOT                       0           // No interaction with other objects
#define SOLID_TRIGGER                   1           // Touch on edge, but not blocking
#define SOLID_BBOX                      2           // Touch on edge, block
#define SOLID_SLIDEBOX                  3           // Touch on edge, but not an onground
#define SOLID_BSP                       4           // BSP clip, touch on edge, block

/**
 * pev(entity, pev_deadflag) values
 */
#define DEAD_NO                         0           // Alive
#define DEAD_DYING                      1           // Playing death animation or still falling off of a ledge waiting to hit ground
#define DEAD_DEAD                       2           // Dead, lying still
#define DEAD_RESPAWNABLE                3
#define DEAD_DISCARDBODY                4

/**
 * new Float:takedamage, pev(entity, pev_takedamage, takedamage) values
 */
#define DAMAGE_NO                       0.0
#define DAMAGE_YES                      1.0
#define DAMAGE_AIM                      2.0

/**
 * pev(entity, pev_effects) values
 */
#define EF_BRIGHTFIELD                  1           // Swirling cloud of particles
#define EF_MUZZLEFLASH                  2           // Single frame ELIGHT on entity attachment 0
#define EF_BRIGHTLIGHT                  4           // DLIGHT centered at entity origin
#define EF_DIMLIGHT                     8           // Player flashlight
#define EF_INVLIGHT                     16          // Get lighting from ceiling
#define EF_NOINTERP                     32          // Don't interpolate the next frame
#define EF_LIGHT                        64          // Rocket flare glow sprite
#define EF_NODRAW                       128         // Don't draw entity

/**
 * Spectating camera mode constants
 *
 * @note These constants are linked to different camera modes available when you
 *       are spectating (either dead or when in spectator team). Usually this is
 *       stored in the pev_iuser1 field in Counter-Strike and Half-Life games.
 */
#define OBS_NONE                        0
#define OBS_CHASE_LOCKED                1           // Locked Chase Cam
#define OBS_CHASE_FREE                  2           // Free Chase Cam
#define OBS_ROAMING                     3           // Free Look
#define OBS_IN_EYE                      4           // First Person
#define OBS_MAP_FREE                    5           // Free Overview
#define OBS_MAP_CHASE                   6           // Chase Overview

/**
 * engfunc(EngFunc_PointContents, Float:origin) return values
 */
#define CONTENTS_EMPTY                  -1
#define CONTENTS_SOLID                  -2
#define CONTENTS_WATER                  -3
#define CONTENTS_SLIME                  -4
#define CONTENTS_LAVA                   -5
#define CONTENTS_SKY                    -6
#define CONTENTS_ORIGIN                 -7          // Removed at csg time
#define CONTENTS_CLIP                   -8          // Changed to contents_solid
#define CONTENTS_CURRENT_0              -9
#define CONTENTS_CURRENT_90             -10
#define CONTENTS_CURRENT_180            -11
#define CONTENTS_CURRENT_270            -12
#define CONTENTS_CURRENT_UP             -13
#define CONTENTS_CURRENT_DOWN           -14
#define CONTENTS_TRANSLUCENT            -15
#define CONTENTS_LADDER                 -16
#define CONTENT_FLYFIELD                -17
#define CONTENT_GRAVITY_FLYFIELD        -18
#define CONTENT_FOG                     -19

/**
 * Instant damage values for use with the 3rd parameter of the "Damage" client
 * message.
 */
#define DMG_GENERIC                     0           // Generic damage was done
#define DMG_CRUSH                       (1<<0)      // Crushed by falling or moving object
#define DMG_BULLET                      (1<<1)      // Shot
#define DMG_SLASH                       (1<<2)      // Cut, clawed, stabbed
#define DMG_BURN                        (1<<3)      // Heat burned
#define DMG_FREEZE                      (1<<4)      // Frozen
#define DMG_FALL                        (1<<5)      // Fell too far
#define DMG_BLAST                       (1<<6)      // Explosive blast damage
#define DMG_CLUB                        (1<<7)      // Crowbar, punch, headbutt
#define DMG_SHOCK                       (1<<8)      // Electric shock
#define DMG_SONIC                       (1<<9)      // Sound pulse shockwave
#define DMG_ENERGYBEAM                  (1<<10)     // Laser or other high energy beam
#define DMG_NEVERGIB                    (1<<12)     // With this bit OR'd in, no damage type will be able to gib victims upon death
#define DMG_ALWAYSGIB                   (1<<13)     // With this bit OR'd in, any damage type can be made to gib victims upon death.
#define DMG_DROWN                       (1<<14)     // Drowning
#define DMG_PARALYZE                    (1<<15)     // Slows affected creature down
#define DMG_NERVEGAS                    (1<<16)     // Nerve toxins, very bad
#define DMG_POISON                      (1<<17)     // Blood poisioning
#define DMG_RADIATION                   (1<<18)     // Radiation exposure
#define DMG_DROWNRECOVER                (1<<19)     // Drowning recovery
#define DMG_ACID                        (1<<20)     // Toxic chemicals or acid burns
#define DMG_SLOWBURN                    (1<<21)     // In an oven
#define DMG_SLOWFREEZE                  (1<<22)     // In a subzero freezer
#define DMG_MORTAR                      (1<<23)     // Hit by air raid (done to distinguish grenade from mortar)
#define DMG_GRENADE                     (1<<24)     // Counter-Strike only - Hit by HE grenade
#define DMG_TIMEBASED                   (~(0x3fff)) // Mask for time-based damage

/**
 * Valid constants for fNoMonsters parameter of EngFunc_TraceLine,
 * EngFunc_TraceMonsterHull, EngFunc_TraceHull and EngFunc_TraceSphere.
 */
#define DONT_IGNORE_MONSTERS            0
#define IGNORE_MONSTERS                 1
#define IGNORE_MISSILE                  2
#define IGNORE_GLASS                    0x100

/**
 * The hullnumber paramater of EngFunc_TraceHull, EngFunc_TraceModel and
 * DLLFunc_GetHullBounds
 */
#define HULL_POINT                      0
#define HULL_HUMAN                      1
#define HULL_LARGE                      2
#define HULL_HEAD                       3

/**
 * global_get(glb_trace_flags)
 */
#define FTRACE_SIMPLEBOX                (1<<0)      // Traceline with a simple box

/**
 * Used with get/set_es(es_handle, ES_eFlags, ...) (entity_state data structure)
 */
#define EFLAG_SLERP                     1           // Do studio interpolation of this entity

/**
 * @section pev(entity, pev_spawnflags) values
 */
/**
 * func_train
 */
#define SF_TRAIN_WAIT_RETRIGGER         1
#define SF_TRAIN_START_ON               4           // Train is initially moving
#define SF_TRAIN_PASSABLE               8           // Train is not solid -- used to make water trains

/**
 * func_wall_toggle
 */
#define SF_WALL_START_OFF               0x0001

/**
 * func_converyor
 */
#define SF_CONVEYOR_VISUAL              0x0001
#define SF_CONVEYOR_NOTSOLID            0x0002

/**
 * func_button
 */
#define SF_BUTTON_DONTMOVE              1
#define SF_BUTTON_TOGGLE                32          // Button stays pushed until reactivated
#define SF_BUTTON_SPARK_IF_OFF          64          // Button sparks in OFF state
#define SF_BUTTON_TOUCH_ONLY            256         // Button only fires as a result of USE key.

/**
 * func_rot_button
 */
#define SF_ROTBUTTON_NOTSOLID           1

/**
 * env_global
 */
#define SF_GLOBAL_SET                   1           // Set global state to initial state on spawn

/**
 * multisource
 */
#define SF_MULTI_INIT                   1

/**
 * momentary_rot_button
 */
#define SF_MOMENTARY_DOOR               0x0001

/**
 * button_target
 */
#define SF_BTARGET_USE                  0x0001
#define SF_BTARGET_ON                   0x0002

/**
 * func_door, func_water, func_door_rotating, momementary_door
 */
#define SF_DOOR_ROTATE_Y                0
#define SF_DOOR_START_OPEN              1
#define SF_DOOR_ROTATE_BACKWARDS        2
#define SF_DOOR_PASSABLE                8
#define SF_DOOR_ONEWAY                  16
#define SF_DOOR_NO_AUTO_RETURN          32
#define SF_DOOR_ROTATE_Z                64
#define SF_DOOR_ROTATE_X                128
#define SF_DOOR_USE_ONLY                256         // Door must be opened by player's use button
#define SF_DOOR_NOMONSTERS              512         // Monster can't open
#define SF_DOOR_SILENT                  0x80000000

/**
 * gibshooter
 */
#define SF_GIBSHOOTER_REPEATABLE        1           // Allows a gibshooter to be refired

/**
 * env_funnel
 */
#define SF_FUNNEL_REVERSE               1           // Funnel effect repels particles instead of attracting them

/**
 * env_bubbles
 */
#define SF_BUBBLES_STARTOFF             0x0001

/**
 * env_blood
 */
#define SF_BLOOD_RANDOM                 0x0001
#define SF_BLOOD_STREAM                 0x0002
#define SF_BLOOD_PLAYER                 0x0004
#define SF_BLOOD_DECAL                  0x0008

/**
 * env_shake
 */
#define SF_SHAKE_EVERYONE               0x0001      // Don't check radius
#define SF_SHAKE_DISRUPT                0x0002      // Disrupt controls
#define SF_SHAKE_INAIR                  0x0004      // Shake players in air

/**
 * env_fade
 */
#define SF_FADE_IN                      0x0001      // Fade in, not out
#define SF_FADE_MODULATE                0x0002      // Modulate, don't blend
#define SF_FADE_ONLYONE                 0x0004

/**
 * env_beam, env_lightning
 */
#define SF_BEAM_STARTON                 0x0001
#define SF_BEAM_TOGGLE                  0x0002
#define SF_BEAM_RANDOM                  0x0004
#define SF_BEAM_RING                    0x0008
#define SF_BEAM_SPARKSTART              0x0010
#define SF_BEAM_SPARKEND                0x0020
#define SF_BEAM_DECALS                  0x0040
#define SF_BEAM_SHADEIN                 0x0080
#define SF_BEAM_SHADEOUT                0x0100
#define SF_BEAM_TEMPORARY               0x8000

/**
 * env_sprite
 */
#define SF_SPRITE_STARTON               0x0001
#define SF_SPRITE_ONCE                  0x0002
#define SF_SPRITE_TEMPORARY             0x8000

/**
 * env_message
 */
#define SF_MESSAGE_ONCE                 0x0001      // Fade in, not out
#define SF_MESSAGE_ALL                  0x0002      // Send to all clients

/**
 * env_explosion
 */
#define SF_ENVEXPLOSION_NODAMAGE        (1<<0)      // When set, ENV_EXPLOSION will not actually inflict damage
#define SF_ENVEXPLOSION_REPEATABLE      (1<<1)      // Can this entity be refired?
#define SF_ENVEXPLOSION_NOFIREBALL      (1<<2)      // Don't draw the fireball
#define SF_ENVEXPLOSION_NOSMOKE         (1<<3)      // Don't draw the smoke
#define SF_ENVEXPLOSION_NODECAL         (1<<4)      // Don't make a scorch mark
#define SF_ENVEXPLOSION_NOSPARKS        (1<<5)      // Don't make a scorch mark

/**
 * func_tank
 */
#define SF_TANK_ACTIVE                  0x0001
#define SF_TANK_PLAYER                  0x0002
#define SF_TANK_HUMANS                  0x0004
#define SF_TANK_ALIENS                  0x0008
#define SF_TANK_LINEOFSIGHT             0x0010
#define SF_TANK_CANCONTROL              0x0020
#define SF_TANK_SOUNDON                 0x8000

/**
 * grenade
 */
#define SF_DETONATE                     0x0001

/**
 * item_suit
 */
#define SF_SUIT_SHORTLOGON              0x0001

/**
 * game_score
 */
#define SF_SCORE_NEGATIVE               0x0001
#define SF_SCORE_TEAM                   0x0002

/**
 * game_text
 */
#define SF_ENVTEXT_ALLPLAYERS           0x0001

/**
 * game_team_master
 */
#define SF_TEAMMASTER_FIREONCE          0x0001
#define SF_TEAMMASTER_ANYTEAM           0x0002

/**
 * game_team_set
 */
#define SF_TEAMSET_FIREONCE             0x0001
#define SF_TEAMSET_CLEARTEAM            0x0002

/**
 * game_player_hurt
 */
#define SF_PKILL_FIREONCE               0x0001

/**
 * game_counter
 */
#define SF_GAMECOUNT_FIREONCE           0x0001
#define SF_GAMECOUNT_RESET              0x0002

/**
 * game_player_equip
 */
#define SF_PLAYEREQUIP_USEONLY          0x0001

/**
 * game_player_team
 */
#define SF_PTEAM_FIREONCE               0x0001
#define SF_PTEAM_KILL                   0x0002
#define SF_PTEAM_GIB                    0x0004

/**
 * func_trackchange
 */
#define SF_PLAT_TOGGLE                  0x0001
#define SF_TRACK_ACTIVATETRAIN          0x00000001
#define SF_TRACK_RELINK                 0x00000002
#define SF_TRACK_ROTMOVE                0x00000004
#define SF_TRACK_STARTBOTTOM            0x00000008
#define SF_TRACK_DONT_MOVE              0x00000010

/**
 * func_tracktrain
 */
#define SF_TRACKTRAIN_NOPITCH           0x0001
#define SF_TRACKTRAIN_NOCONTROL         0x0002
#define SF_TRACKTRAIN_FORWARDONLY       0x0004
#define SF_TRACKTRAIN_PASSABLE          0x0008
#define SF_PATH_DISABLED                0x00000001
#define SF_PATH_FIREONCE                0x00000002
#define SF_PATH_ALTREVERSE              0x00000004
#define SF_PATH_DISABLE_TRAIN           0x00000008
#define SF_PATH_ALTERNATE               0x00008000
#define SF_CORNER_WAITFORTRIG           0x001
#define SF_CORNER_TELEPORT              0x002
#define SF_CORNER_FIREONCE              0x004

/**
 * trigger_push
 */
#define SF_TRIGGER_PUSH_START_OFF       2           // Spawnflag that makes trigger_push spawn turned OFF

/**
 * trigger_hurt
 */
#define SF_TRIGGER_HURT_TARGETONCE      1           // Only fire hurt target once
#define SF_TRIGGER_HURT_START_OFF       2           // Spawnflag that makes trigger_push spawn turned OFF
#define SF_TRIGGER_HURT_NO_CLIENTS      8           // Spawnflag that makes trigger_push spawn turned OFF
#define SF_TRIGGER_HURT_CLIENTONLYFIRE  16          // Trigger hurt will only fire its target if it is hurting a client
#define SF_TRIGGER_HURT_CLIENTONLYTOUCH 32          // Only clients may touch this trigger

/**
 * trigger_auto
 */
#define SF_AUTO_FIREONCE                0x0001

/**
 * trigger_relay
 */
#define SF_RELAY_FIREONCE               0x0001

/**
 * multi_manager
 */
#define SF_MULTIMAN_CLONE               0x80000000
#define SF_MULTIMAN_THREAD              0x00000001

/**
 * env_render
 * @note These are flags to indicate masking off various render parameters that
 *       are usually copied to the targets
 */
#define SF_RENDER_MASKFX                (1<<0)
#define SF_RENDER_MASKAMT               (1<<1)
#define SF_RENDER_MASKMODE              (1<<2)
#define SF_RENDER_MASKCOLOR             (1<<3)

/**
 * trigger_changelevel
 */
#define SF_CHANGELEVEL_USEONLY          0x0002

/**
 * trigger_endsection
 */
#define SF_ENDSECTION_USEONLY           0x0001

/**
 * trigger_camera
 */
#define SF_CAMERA_PLAYER_POSITION       1
#define SF_CAMERA_PLAYER_TARGET         2
#define SF_CAMERA_PLAYER_TAKECONTROL    4

/**
 * func_rotating
 */
#define SF_BRUSH_ROTATE_Y_AXIS          0
#define SF_BRUSH_ROTATE_INSTANT         1
#define SF_BRUSH_ROTATE_BACKWARDS       2
#define SF_BRUSH_ROTATE_Z_AXIS          4
#define SF_BRUSH_ROTATE_X_AXIS          8
#define SF_PENDULUM_AUTO_RETURN         16
#define SF_PENDULUM_PASSABLE            32
#define SF_BRUSH_ROTATE_SMALLRADIUS     128
#define SF_BRUSH_ROTATE_MEDIUMRADIUS    256
#define SF_BRUSH_ROTATE_LARGERADIUS     512

/**
 * triggers
 */
#define SF_TRIGGER_ALLOWMONSTERS        1           // Monsters allowed to fire this trigger
#define SF_TRIGGER_NOCLIENTS            2           // Players not allowed to fire this trigger
#define SF_TRIGGER_PUSHABLES            4           // Only pushables can fire this trigger

#define SF_TRIG_PUSH_ONCE               1

/**
 * func_breakable
 */
#define SF_BREAK_TRIGGER_ONLY           1           // May only be broken by trigger
#define SF_BREAK_TOUCH                  2           // Can be 'crashed through' by running player (plate glass)
#define SF_BREAK_PRESSURE               4           // Can be broken by a player standing on it
#define SF_BREAK_CROWBAR                256         // Instant break if hit with crowbar

/**
 * func_pushable (also func_breakable, so don't collide with those flags)
 */
#define SF_PUSH_BREAKABLE               128

/**
 * light_spawn
 */
#define SF_LIGHT_START_OFF              1
#define SPAWNFLAG_NOMESSAGE             1
#define SPAWNFLAG_NOTOUCH               1
#define SPAWNFLAG_DROIDONLY             4
#define SPAWNFLAG_USEONLY               1           // Can't be touched, must be used (buttons)

/**
 * Monster Spawnflags
 */
#define SF_MONSTER_WAIT_TILL_SEEN       1           // Spawnflag that makes monsters wait until player can see them before attacking
#define SF_MONSTER_GAG                  2           // No idle noises from this monster
#define SF_MONSTER_HITMONSTERCLIP       4
#define SF_MONSTER_PRISONER             16          // Monster won't attack anyone, no one will attacke him
#define SF_MONSTER_WAIT_FOR_SCRIPT      128         // Spawnflag that makes monsters wait to check for attacking until the script is done or they've been attacked
#define SF_MONSTER_PREDISASTER          256         // This is a predisaster scientist or barney; influences how they speak
#define SF_MONSTER_FADECORPSE           512         // Fade out corpse after death
#define SF_MONSTER_FALL_TO_GROUND       0x80000000
#define SF_MONSTER_TURRET_AUTOACTIVATE  32
#define SF_MONSTER_TURRET_STARTINACTIVE 64
#define SF_MONSTER_WAIT_UNTIL_PROVOKED  64          // Don't attack the player unless provoked

/**
 * info_decal
 */
#define SF_DECAL_NOTINDEATHMATCH        2048

/**
 * worldspawn
 */
#define SF_WORLD_DARK                   0x0001      // Fade from black at startup
#define SF_WORLD_TITLE                  0x0002      // Display game title at startup
#define SF_WORLD_FORCETEAM              0x0004      // Force teams

/**
 * Set this bit on guns and stuff that should never respawn
 */
#define SF_NORESPAWN                    (1<<30)

/**
 * @endsection
 */

/**
 * Valve Mod Weapon Constants
 */
#define HLI_HEALTHKIT       1
#define HLI_ANTIDOTE        2
#define HLI_SECURITY        3
#define HLI_BATTERY         4

#define HLW_NONE            0
#define HLW_CROWBAR         1
#define HLW_GLOCK           2
#define HLW_PYTHON          3
#define HLW_MP5             4
#define HLW_CHAINGUN        5
#define HLW_CROSSBOW        6
#define HLW_SHOTGUN         7
#define HLW_RPG             8
#define HLW_GAUSS           9
#define HLW_EGON            10
#define HLW_HORNETGUN       11
#define HLW_HANDGRENADE     12
#define HLW_TRIPMINE        13
#define HLW_SATCHEL         14
#define HLW_SNARK           15
#define HLW_SUIT            31
#define HLW_ALLWEAPONS      (~(1<<HLW_SUIT))


#define FEV_NOTHOST     (1<<0)  // Skip local host for event send.
#define FEV_RELIABLE    (1<<1)  // Send the event reliably.  You must specify the origin and angles
                                // for this to work correctly on the server for anything
                                // that depends on the event origin/angles.  I.e., the origin/angles are not
                                // taken from the invoking edict for reliable events.
#define FEV_GLOBAL      (1<<2)  // Don't restrict to PAS/PVS, send this event to _everybody_ on the server ( useful for stopping CHAN_STATIC
                                //  sounds started by client event when client is not in PVS anymore ( hwguy in TFC e.g. ).
#define FEV_UPDATE      (1<<3)  // If this client already has one of these events in its queue, just update the event instead of sending it as a duplicate
#define FEV_HOSTONLY    (1<<4)  // Only send to entity specified as the invoker
#define FEV_SERVER      (1<<5)  // Only send if the event was created on the server.
#define FEV_CLIENT      (1<<6)  // Only issue event client side ( from shared code )

/**
 * Cap bits to indicate what an object's capabilities are, currently used for
 * save/restore and level transitions.
 */
#define FCAP_CUSTOMSAVE                 0x00000001
#define FCAP_ACROSS_TRANSITION          0x00000002      // should transfer between transitions
#define FCAP_MUST_SPAWN                 0x00000004      // Spawn after restore
#define FCAP_DONT_SAVE                  0x80000000      // Don't save this
#define FCAP_IMPULSE_USE                0x00000008      // can be used by the player
#define FCAP_CONTINUOUS_USE             0x00000010      // can be used by the player
#define FCAP_ONOFF_USE                  0x00000020      // can be used by the player
#define FCAP_DIRECTIONAL_USE            0x00000040      // Player sends +/- 1 when using (currently only tracktrains)
#define FCAP_MASTER                     0x00000080      // Can be used to "master" other entities (like multisource)
// vim: set ts=4 sw=4 tw=99 noet:
//
// AMX Mod X, based on AMX Mod by Aleksander Naszko ("OLO").
// Copyright (C) The AMX Mod X Development Team.
//
// This software is licensed under the GNU General Public License, version 3 or higher.
// Additional exceptions apply. For full license details, see LICENSE.txt or visit:
//     https://alliedmods.net/amxmodx-license

//
// Language Functions
//

#if defined _lang_included
  #endinput
#endif
#define _lang_included

//return the number of languages loaded
native get_langsnum();

//sets name to the two-letter name of a language returned by get_langsnum
//index starts at 0
native get_lang(id, name[3]);

//registers a dictionary file, making sure the words are in the dictionary
// the file should be in "addons/amxx/data/lang/", but only the name needs to be
// given.  (e.g. register_dictionary("file.txt") will be addons/amxx/data/file.txt).
native register_dictionary(const filename[]);

//returns 1 if the language is loaded, 0 otherwise.
native lang_exists(const name[]);

enum TransKey
{
	TransKey_Bad = -1,
};

/**
 * Adds or finds a translation key.
 */
native TransKey:CreateLangKey(const key[]);

/**
 * Finds a translation key id without adding on failure.
 * Returns -1 on not found.
 */
native TransKey:GetLangTransKey(const key[]);

/**
 * Adds a translation.
 */
native AddTranslation(const lang[3], TransKey:key, const phrase[]);

/**
 * Looks up the translation of the key for the given type
 * This does NOT format the output text.
 * eg: If the key includes %s, the outputted text will also contain %s.
 * NOTE: LANG_PLAYER is invalid in this, use a player index
 *       or LANG_SERVER
 */
native LookupLangKey(Output[], OutputSize, const Key[], const &id);
// vim: set ts=4 sw=4 tw=99 noet:
//
// AMX Mod X, based on AMX Mod by Aleksander Naszko ("OLO").
// Copyright (C) The AMX Mod X Development Team.
//
// This software is licensed under the GNU General Public License, version 3 or higher.
// Additional exceptions apply. For full license details, see LICENSE.txt or visit:
//     https://alliedmods.net/amxmodx-license

//
// Message Constants
//

#if defined _message_const_included
	#endinput
#endif
#define _message_const_included

/**
 * Destination types for message_begin()
 */
#define	MSG_BROADCAST               0        // Unreliable to all
#define	MSG_ONE                     1        // Reliable to one (msg_entity)
#define	MSG_ALL                     2        // Reliable to all
#define	MSG_INIT                    3        // Write to the init string
#define MSG_PVS                     4        // Ents in PVS of org
#define MSG_PAS                     5        // Ents in PAS of org
#define MSG_PVS_R                   6        // Reliable to PVS
#define MSG_PAS_R                   7        // Reliable to PAS
#define MSG_ONE_UNRELIABLE          8        // Send to one client, but don't put in reliable stream, put in unreliable datagram (could be dropped)
#define	MSG_SPEC                    9        // Sends to all spectator proxies

/**
 * Hardcoded message types for message_begin()
 *
 * @note Look at the actual HLSDK for details
 */
#define SVC_NOP						1
#define SVC_DISCONNECT				2
#define SVC_EVENT					3
#define SVC_VERSION					4
#define SVC_SETVIEW					5
#define SVC_SOUND					6
#define SVC_TIME					7
#define SVC_PRINT					8
#define SVC_STUFFTEXT				9
#define SVC_SETANGLE				10
#define SVC_SERVERINFO				11
#define SVC_LIGHTSTYLE				12
#define SVC_UPDATEUSERINFO			13
#define SVC_DELTADESCRIPTION		14
#define SVC_CLIENTDATA				15
#define SVC_STOPSOUND				16
#define SVC_PINGS					17
#define SVC_PARTICLE				18
#define SVC_DAMAGE					19
#define SVC_SPAWNSTATIC				20
#define SVC_EVENT_RELIABLE			21
#define SVC_SPAWNBASELINE			22
#define SVC_TEMPENTITY				23
#define SVC_SETPAUSE				24
#define SVC_SIGNONNUM				25
#define SVC_CENTERPRINT				26
#define SVC_KILLEDMONSTER			27
#define SVC_FOUNDSECRET				28
#define SVC_SPAWNSTATICSOUND		29
#define SVC_INTERMISSION			30
#define SVC_FINALE					31
#define SVC_CDTRACK					32
#define SVC_RESTORE					33
#define SVC_CUTSCENE				34
#define SVC_WEAPONANIM				35
#define SVC_DECALNAME				36
#define SVC_ROOMTYPE				37
#define SVC_ADDANGLE				38
#define SVC_NEWUSERMSG				39
#define SVC_PACKETENTITIES			40
#define SVC_DELTAPACKETENTITIES		41
#define SVC_CHOKE					42
#define SVC_RESOURCELIST			43
#define SVC_NEWMOVEVARS				44
#define SVC_RESOURCEREQUEST			45
#define SVC_CUSTOMIZATION			46
#define SVC_CROSSHAIRANGLE			47
#define SVC_SOUNDFADE				48
#define SVC_FILETXFERFAILED			49
#define SVC_HLTV					50
#define SVC_DIRECTOR				51
#define SVC_VOICEINIT				52
#define SVC_VOICEDATA				53
#define SVC_SENDEXTRAINFO			54
#define SVC_TIMESCALE				55

/**
 * Flags for set_msg_block()
 */
#define BLOCK_NOT                   0
#define BLOCK_ONCE                  1
#define BLOCK_SET                   2

/**
 * Message argument types used with get_msg_argtype() and set_msg_arg_*
 */
enum
{
	ARG_BYTE = 1,       /* int */
	ARG_CHAR,           /* int */
	ARG_SHORT,          /* int */
	ARG_LONG,           /* int */
	ARG_ANGLE,          /* float */
	ARG_COORD,          /* float */
	ARG_STRING,         /* string */
	ARG_ENTITY,         /* int */
};

/**
 * @section TempEntity messages for message_begin()
 */

/**
 * Beam effect between two points
 *
 * @note
 * write_byte(TE_BEAMPOINTS)
 * write_coord(startposition.x)
 * write_coord(startposition.y)
 * write_coord(startposition.z)
 * write_coord(endposition.x)
 * write_coord(endposition.y)
 * write_coord(endposition.z)
 * write_short(sprite index)
 * write_byte(starting frame)
 * write_byte(frame rate in 0.1's)
 * write_byte(life in 0.1's)
 * write_byte(line width in 0.1's)
 * write_byte(noise amplitude in 0.01's)
 * write_byte(red)
 * write_byte(green)
 * write_byte(blue)
 * write_byte(brightness)
 * write_byte(scroll speed in 0.1's)
 */
#define	TE_BEAMPOINTS               0

/**
 * Beam effect between a point and an entity
 *
 * @note
 * write_byte(TE_BEAMENTPOINT)
 * write_short(start entity)
 * write_coord(endposition.x)
 * write_coord(endposition.y)
 * write_coord(endposition.z)
 * write_short(sprite index)
 * write_byte(starting frame)
 * write_byte(frame rate in 0.1's)
 * write_byte(life in 0.1's)
 * write_byte(line width in 0.1's)
 * write_byte(noise amplitude in 0.01's)
 * write_byte(red)
 * write_byte(green)
 * write_byte(blue)
 * write_byte(brightness)
 * write_byte(scroll speed in 0.1's)
 */

/**
 * Particle effect plus ricochet sound
 *
 * @note
 * write_byte(TE_GUNSHOT)
 * write_coord(position.x)
 * write_coord(position.y)
 * write_coord(position.z)
 */
#define	TE_GUNSHOT                  2

/**
 * Additive sprite, 2 dynamic lights, flickering particles, explosion sound,
 * move vertically 8 pps
 *
 * @note
 * write_byte(TE_EXPLOSION)
 * write_coord(position.x)
 * write_coord(position.y)
 * write_coord(position.z)
 * write_short(sprite index)
 * write_byte(scale in 0.1's)
 * write_byte(framerate)
 * write_byte(flags)
 */
#define	TE_EXPLOSION                3

/**
 * Flags for the TE_EXPLOSION effect, controlling its performance and aesthetic
 * features
 */
#define TE_EXPLFLAG_NONE            0        // All flags clear makes default Half-Life explosion
#define TE_EXPLFLAG_NOADDITIVE      1        // Sprite will be drawn opaque (ensure that the sprite you send is a non-additive sprite)
#define TE_EXPLFLAG_NODLIGHTS       2        // Do not render dynamic lights
#define TE_EXPLFLAG_NOSOUND         4        // Do not play client explosion sound
#define TE_EXPLFLAG_NOPARTICLES     8        // Do not draw particles

/**
 * Quake1 "tarbaby" explosion with sound
 *
 * @note
 * write_byte(TE_TAREXPLOSION)
 * write_coord(position.x)
 * write_coord(position.y)
 * write_coord(position.z)
 */
#define	TE_TAREXPLOSION             4

/**
 * Alphablend sprite, move vertically 30pps
 *
 * @note
 * write_byte(TE_SMOKE)
 * write_coord(position.x)
 * write_coord(position.y)
 * write_coord(position.z)
 * write_short(sprite index)
 * write_byte(scale in 0.1's)
 * write_byte(framerate)
 */
#define	TE_SMOKE                    5

/**
 * Tracer effect from point to point
 *
 * @note
 * write_byte(TE_TRACER)
 * write_coord(startposition.x)
 * write_coord(startposition.y)
 * write_coord(startposition.z)
 * write_coord(endposition.x)
 * write_coord(endposition.y)
 * write_coord(endposition.z)
 */
#define	TE_TRACER                   6

/**
 * TE_BEAMPOINTS with simplified parameters
 *
 * @note
 * write_byte(TE_LIGHTNING)
 * write_coord(startposition.x)
 * write_coord(startposition.y)
 * write_coord(startposition.z)
 * write_coord(endposition.x)
 * write_coord(endposition.y)
 * write_coord(endposition.z)
 * write_byte(life in 0.1's)
 * write_byte(width in 0.1's)
 * write_byte(amplitude in 0.01's)
 * write_short(sprite model index)
 */
#define	TE_LIGHTNING                7

/**
 * TE_BEAMENTS
 *
 * @note
 * write_byte(TE_BEAMENTS)
 * write_short(start entity)
 * write_short(end entity)
 * write_short(sprite index)
 * write_byte(starting frame)
 * write_byte(frame rate in 0.1's)
 * write_byte(life in 0.1's)
 * write_byte(line width in 0.1's)
 * write_byte(noise amplitude in 0.01's)
 * write_byte(red)
 * write_byte(green)
 * write_byte(blue)
 * write_byte(brightness)
 * write_byte(scroll speed in 0.1's)
 */
#define	TE_BEAMENTS                 8

/**
 * 8 random tracers with gravity, ricochet sprite
 *
 * @note
 * write_byte(TE_SPARKS)
 * write_coord(position.x)
 * write_coord(position.y)
 * write_coord(position.z)
 */
#define	TE_SPARKS                   9

/**
 * Quake1 lava splash
 *
 * @note
 * write_byte(TE_LAVASPLASH)
 * write_coord(position.x)
 * write_coord(position.y)
 * write_coord(position.z)
 */
#define	TE_LAVASPLASH               10

/**
 * Quake1 teleport splash
 *
 * @note
 * write_byte(TE_TELEPORT)
 * write_coord(position.x)
 * write_coord(position.y)
 * write_coord(position.z)
 */
#define	TE_TELEPORT                 11

/**
 * Quake1 colormaped (base palette) particle explosion with sound
 *
 * @note
 * write_byte(TE_EXPLOSION2)
 * write_coord(position.x)
 * write_coord(position.y)
 * write_coord(position.z)
 * write_byte(starting color)
 * write_byte(num colors)
 */
#define TE_EXPLOSION2               12

/**
 * Decal from the .BSP file
 *
 * @note
 * write_byte(TE_BSPDECAL)
 * write_coord(position.x) decal position (center of texture in world)
 * write_coord(position.y)
 * write_coord(position.z)
 * write_short(texture index of precached decal texture name)
 * write_short(entity index)
 * [optional - write_short(index of model of above entity) only included if previous short is non-zero (not the world)]
 */
#define TE_BSPDECAL                 13

/**
 * Tracers moving toward a point
 *
 * @note
 * write_byte(TE_IMPLOSION)
 * write_coord(position.x)
 * write_coord(position.y)
 * write_coord(position.z)
 * write_byte(radius)
 * write_byte(count)
 * write_byte(life in 0.1's)
 */
#define TE_IMPLOSION                14

/**
 * Line of moving glow sprites with gravity, fadeout, and collisions
 *
 * @note
 * write_byte(TE_SPRITETRAIL)
 * write_coord(startposition.x)
 * write_coord(startposition.y)
 * write_coord(startposition.z)
 * write_coord(endposition.x)
 * write_coord(endposition.y)
 * write_coord(endposition.z)
 * write_short(sprite index)
 * write_byte(count)
 * write_byte(life in 0.1's)
 * write_byte(scale in 0.1's)
 * write_byte(velocity along vector in 10's)
 * write_byte(randomness of velocity in 10's)
 */
#define TE_SPRITETRAIL              15

/**
 * Additive sprite, plays 1 cycle
 *
 * @note
 * write_byte(TE_SPRITE)
 * write_coord(position.x)
 * write_coord(position.y)
 * write_coord(position.z)
 * write_short(sprite index)
 * write_byte(scale in 0.1's)
 * write_byte(brightness)
 */
#define TE_SPRITE                   17

/**
 * A beam with a sprite at the end
 *
 * @note
 * write_byte(TE_BEAMSPRITE)
 * write_coord(startposition.x)
 * write_coord(startposition.y)
 * write_coord(startposition.z)
 * write_coord(endposition.x)
 * write_coord(endposition.y)
 * write_coord(endposition.z)
 * write_short(beam sprite index)
 * write_short(end sprite index)
 */
#define TE_BEAMSPRITE               18

/**
 * Screen aligned beam ring, expands to max radius over lifetime
 *
 * @note
 * write_byte(TE_BEAMTORUS)
 * write_coord(position.x)
 * write_coord(position.y)
 * write_coord(position.z)
 * write_coord(axis.x)
 * write_coord(axis.y)
 * write_coord(axis.z)
 * write_short(sprite index)
 * write_byte(starting frame)
 * write_byte(frame rate in 0.1's)
 * write_byte(life in 0.1's)
 * write_byte(line width in 0.1's)
 * write_byte(noise amplitude in 0.01's)
 * write_byte(red)
 * write_byte(green)
 * write_byte(blue)
 * write_byte(brightness)
 * write_byte(scroll speed in 0.1's)
 */
#define TE_BEAMTORUS                19

/**
 * Disk that expands to max radius over lifetime
 *
 * @note
 * write_byte(TE_BEAMDISK)
 * write_coord(position.x)
 * write_coord(position.y)
 * write_coord(position.z)
 * write_coord(axis.x)
 * write_coord(axis.y)
 * write_coord(axis.z)
 * write_short(sprite index)
 * write_byte(starting frame)
 * write_byte(frame rate in 0.1's)
 * write_byte(life in 0.1's)
 * write_byte(line width in 0.1's)
 * write_byte(noise amplitude in 0.01's)
 * write_byte(red)
 * write_byte(green)
 * write_byte(blue)
 * write_byte(brightness)
 * write_byte(scroll speed in 0.1's)
 */
#define TE_BEAMDISK                 20

/**
 * Cylinder that expands to max radius over lifetime
 *
 * @note
 * write_byte(TE_BEAMCYLINDER)
 * write_coord(position.x)
 * write_coord(position.y)
 * write_coord(position.z)
 * write_coord(axis.x)
 * write_coord(axis.y)
 * write_coord(axis.z)
 * write_short(sprite index)
 * write_byte(starting frame)
 * write_byte(frame rate in 0.1's)
 * write_byte(life in 0.1's)
 * write_byte(line width in 0.1's)
 * write_byte(noise amplitude in 0.01's)
 * write_byte(red)
 * write_byte(green)
 * write_byte(blue)
 * write_byte(brightness)
 * write_byte(scroll speed in 0.1's)
 */
#define TE_BEAMCYLINDER             21

/**
 * Create a line of decaying beam segments until entity stops moving
 *
 * @note
 * write_byte(TE_BEAMFOLLOW)
 * write_short(entity:attachment to follow)
 * write_short(sprite index)
 * write_byte(life in 0.1's)
 * write_byte(line width in 0.1's)
 * write_byte(red)
 * write_byte(green)
 * write_byte(blue)
 * write_byte(brightness)
 */
#define TE_BEAMFOLLOW               22

/**
 * TE_GLOWSPRITE
 *
 * @note
 * write_byte(TE_GLOWSPRITE)
 * write_coord(position.x)
 * write_coord(position.y)
 * write_coord(position.z)
 * write_short(model index)
 * write_byte(scale / 10)
 * write_byte(size)
 * write_byte(brightness)
 */
#define TE_GLOWSPRITE               23

/**
 * Connect a beam ring to two entities
 *
 * @note
 * write_byte(TE_BEAMRING)
 * write_short(start entity)
 * write_short(end entity)
 * write_short(sprite index)
 * write_byte(starting frame)
 * write_byte(frame rate in 0.1's)
 * write_byte(life in 0.1's)
 * write_byte(line width in 0.1's)
 * write_byte(noise amplitude in 0.01's)
 * write_byte(red)
 * write_byte(green)
 * write_byte(blue)
 * write_byte(brightness)
 * write_byte(scroll speed in 0.1's)
 */
#define TE_BEAMRING                 24

/**
 * Oriented shower of tracers
 *
 * @note
 * write_byte(TE_STREAK_SPLASH)
 * write_coord(startposition.x)
 * write_coord(startposition.y)
 * write_coord(startposition.z)
 * write_coord(vector.x)
 * write_coord(vector.y)
 * write_coord(vector.z)
 * write_byte(color)
 * write_short(count)
 * write_short(base speed)
 * write_short(ramdon velocity)
 */
#define TE_STREAK_SPLASH            25

/**
 * Dynamic light, effect world, minor entity effect
 *
 * @note
 * write_byte(TE_DLIGHT)
 * write_coord(position.x)
 * write_coord(position.y)
 * write_coord(position.z)
 * write_byte(radius in 10's)
 * write_byte(red)
 * write_byte(green)
 * write_byte(blue)
 * write_byte(brightness)
 * write_byte(life in 10's)
 * write_byte(decay rate in 10's)
 */
#define TE_DLIGHT                   27

/**
 * Point entity light, no world effect
 *
 * @note
 * write_byte(TE_ELIGHT)
 * write_short(entity:attachment to follow)
 * write_coord(position.x)
 * write_coord(position.y)
 * write_coord(position.z)
 * write_coord(radius)
 * write_byte(red)
 * write_byte(green)
 * write_byte(blue)
 * write_byte(life in 0.1's)
 * write_coord(decay rate)
 */
#define TE_ELIGHT                   28

/**
 * TE_TEXTMESSAGE
 *
 * @note
 * write_byte(TE_TEXTMESSAGE)
 * write_byte(channel)
 * write_short(x) -1 = center)
 * write_short(y) -1 = center)
 * write_byte(effect) 0 = fade in/fade out, 1 is flickery credits, 2 is write out (training room)
 * write_byte(red) - text color
 * write_byte(green)
 * write_byte(blue)
 * write_byte(alpha)
 * write_byte(red) - effect color
 * write_byte(green)
 * write_byte(blue)
 * write_byte(alpha)
 * write_short(fadein time)
 * write_short(fadeout time)
 * write_short(hold time)
 * [optional] write_short(fxtime) time the highlight lags behing the leading text in effect 2
 * write_string(text message) 512 chars max string size
 */
#define TE_TEXTMESSAGE              29

/**
 * TE_LINE
 *
 * @note
 * write_byte(TE_LINE)
 * write_coord(startposition.x)
 * write_coord(startposition.y)
 * write_coord(startposition.z)
 * write_coord(endposition.x)
 * write_coord(endposition.y)
 * write_coord(endposition.z)
 * write_short(life in 0.1 s)
 * write_byte(red)
 * write_byte(green)
 * write_byte(blue)
 */
#define TE_LINE                     30

/**
 * TE_BOX
 *
 * @note
 * write_byte(TE_BOX)
 * write_coord(boxmins.x)
 * write_coord(boxmins.y)
 * write_coord(boxmins.z)
 * write_coord(boxmaxs.x)
 * write_coord(boxmaxs.y)
 * write_coord(boxmaxs.z)
 * write_short(life in 0.1 s)
 * write_byte(red)
 * write_byte(green)
 * write_byte(blue)
 */
#define TE_BOX                      31

/**
 * Kill all beams attached to entity
 *
 * @note
 * write_byte(TE_KILLBEAM)
 * write_short(entity)
 */
#define TE_KILLBEAM                 99

/**
 * TE_LARGEFUNNEL
 *
 * @note
 * write_byte(TE_LARGEFUNNEL)
 * write_coord(position.x)
 * write_coord(position.y)
 * write_coord(position.z)
 * write_short(sprite index)
 * write_short(flags)
 */
#define TE_LARGEFUNNEL              100

/**
 * Particle spray
 *
 * @note
 * write_byte(TE_BLOODSTREAM)
 * write_coord(position.x)
 * write_coord(position.y)
 * write_coord(position.z)
 * write_coord(vector.x)
 * write_coord(vector.y)
 * write_coord(vector.z)
 * write_byte(color)
 * write_byte(speed)
 */
#define	TE_BLOODSTREAM              101

/**
 * Line of particles every 5 units, dies in 30 seconds
 *
 * @note
 * write_byte(TE_SHOWLINE)
 * write_coord(startposition.x)
 * write_coord(startposition.y)
 * write_coord(startposition.z)
 * write_coord(endposition.x)
 * write_coord(endposition.y)
 * write_coord(endposition.z)
 */
#define	TE_SHOWLINE                 102

/**
 * Particle spray
 *
 * @note
 * write_byte(TE_BLOOD)
 * write_coord(position.x)
 * write_coord(position.y)
 * write_coord(position.z)
 * write_coord(vector.x)
 * write_coord(vector.y)
 * write_coord(vector.z)
 * write_byte(color)
 * write_byte(speed)
 */
#define TE_BLOOD                    103

/**
 * Decal applied to a brush entity (not the world)
 *
 * @note
 * write_byte(TE_DECAL)
 * write_coord(position.x) decal position (center of texture in world)
 * write_coord(position.y)
 * write_coord(position.z)
 * write_byte(texture index of precached decal texture name)
 * write_short(entity index)
 */
#define TE_DECAL                    104

/**
 * Create alpha sprites inside of entity, float upwards
 *
 * @note
 * write_byte(TE_FIZZ)
 * write_short(entity)
 * write_short(sprite index)
 * write_byte density)
 */
#define TE_FIZZ                     105

/**
 * Create a moving model that bounces and makes a sound when it hits
 *
 * @note
 * write_byte(TE_MODEL)
 * write_coord(position.x)
 * write_coord(position.y)
 * write_coord(position.z)
 * write_coord(velocity.x)
 * write_coord(velocity.y)
 * write_coord(velocity.z)
 * write_angle(initial yaw)
 * write_short(model index)
 * write_byte(bounce sound type)
 * write_byte(life in 0.1's)
 */
#define TE_MODEL                    106

/**
 * Spherical shower of models, picks from set
 *
 * @note
 * write_byte(TE_EXPLODEMODEL)
 * write_coord(origin.x)
 * write_coord(origin.y)
 * write_coord(origin.z)
 * write_coord(velocity.x)
 * write_coord(velocity.y)
 * write_coord(velocity.z)
 * write_short(model index)
 * write_short(count)
 * write_byte(life in 0.1's)
 */
#define TE_EXPLODEMODEL             107

/**
 * Box of models or sprites
 *
 * @note
 * write_byte(TE_BREAKMODEL)
 * write_coord(position.x)
 * write_coord(position.y)
 * write_coord(position.z)
 * write_coord(size.x)
 * write_coord(size.y)
 * write_coord(size.z)
 * write_coord(velocity.x)
 * write_coord(velocity.y)
 * write_coord(velocity.z)
 * write_byte(random velocity in 10's)
 * write_short(sprite or model index)
 * write_byte(count)
 * write_byte(life in 0.1 secs)
 * write_byte(flags)
 */
#define TE_BREAKMODEL               108

/**
 * Decal and ricochet sound
 *
 * @note
 * write_byte(TE_GUNSHOTDECAL)
 * write_coord(position.x)
 * write_coord(position.y)
 * write_coord(position.z)
 * write_short(entity index???)
 * write_byte(decal???)
 */
#define TE_GUNSHOTDECAL             109

/**
 * Spray of alpha sprites
 *
 * @note
 * write_byte(TE_SPRITE_SPRAY)
 * write_coord(position.x)
 * write_coord(position.y)
 * write_coord(position.z)
 * write_coord(velocity.x)
 * write_coord(velocity.y)
 * write_coord(velocity.z)
 * write_short(sprite index)
 * write_byte(count)
 * write_byte(speed)
 * write_byte(noise)
 */
#define TE_SPRITE_SPRAY             110

/**
 * Quick spark sprite, client ricochet sound.
 *
 * @note
 * write_byte(TE_ARMOR_RICOCHET)
 * write_coord(position.x)
 * write_coord(position.y)
 * write_coord(position.z)
 * write_byte(scale in 0.1's)
 */
#define TE_ARMOR_RICOCHET           111

/**
 * TE_PLAYERDECAL
 *
 * @note
 * write_byte(TE_PLAYERDECAL)
 * write_byte(playerindex)
 * write_coord(position.x)
 * write_coord(position.y)
 * write_coord(position.z)
 * write_short(entity???)
 * write_byte(decal number)
 * [optional] write_short(model index)
 */
#define TE_PLAYERDECAL              112

/**
 * Create alpha sprites inside of box, float upwards
 *
 * @note
 * write_byte(TE_BUBBLES)
 * write_coord(position.x) (min start position)
 * write_coord(position.y)
 * write_coord(position.z)
 * write_coord(position.x) (max start position)
 * write_coord(position.y)
 * write_coord(position.z)
 * write_coord(float height)
 * write_short(model index)
 * write_byte(count)
 * write_coord(speed)
 */
#define TE_BUBBLES                  113

/**
 * Create alpha sprites along a line, float upwards
 *
 * @note
 * write_byte(TE_BUBBLETRAIL)
 * write_coord(position.x) (min start position)
 * write_coord(position.y) (min start position)
 * write_coord(position.z) (min start position)
 * write_coord(position.x) (max start position)
 * write_coord(position.y) (max start position)
 * write_coord(position.z) (max start position)
 * write_coord(float height)
 * write_short(model index)
 * write_byte(count)
 * write_coord(speed)
 */
#define TE_BUBBLETRAIL              114

/**
 * Spray of opaque sprite1's that fall, single sprite2 for 1..2 secs (this is a high-priority tent)
 *
 * @note
 * write_byte(TE_BLOODSPRITE)
 * write_coord(position.x)
 * write_coord(position.y)
 * write_coord(position.z)
 * write_short(sprite1 index)
 * write_short(sprite2 index)
 * write_byte(color)
 * write_byte(scale)
 */
#define TE_BLOODSPRITE              115

/**
 * Decal applied to the world brush
 *
 * @note
 * write_byte(TE_WORLDDECAL)
 * write_coord(position.x) decal position (center of texture in world)
 * write_coord(position.y)
 * write_coord(position.z)
 * write_byte(texture index of precached decal texture name)
 */
#define TE_WORLDDECAL               116

/**
 * Decal (with texture index > 256) applied to world brush
 *
 * @note
 * write_byte(TE_WORLDDECALHIGH)
 * write_coord(position.x) decal position (center of texture in world)
 * write_coord(position.y)
 * write_coord(position.z)
 * write_byte(texture index of precached decal texture name - 256)
 */
#define TE_WORLDDECALHIGH           117

/**
 * Same as TE_DECAL, but the texture index was greater than 256
 *
 * @note
 * write_byte(TE_DECALHIGH)
 * write_coord(position.x) decal position (center of texture in world)
 * write_coord(position.y)
 * write_coord(position.z)
 * write_byte(texture index of precached decal texture name - 256)
 * write_short(entity index)
 */
#define TE_DECALHIGH                118

/**
 * Makes a projectile (like a nail) (this is a high-priority tent)
 *
 * @note
 * write_byte(TE_PROJECTILE)
 * write_coord(position.x)
 * write_coord(position.y)
 * write_coord(position.z)
 * write_coord(velocity.x)
 * write_coord(velocity.y)
 * write_coord(velocity.z)
 * write_short(modelindex)
 * write_byte(life)
 * write_byte(owner)  projectile won't collide with owner (if owner == 0, projectile will hit any client).
 */
#define TE_PROJECTILE               119

/**
 * Throws a shower of sprites or models
 *
 * @note
 * write_byte(TE_SPRAY)
 * write_coord(position.x)
 * write_coord(position.y)
 * write_coord(position.z)
 * write_coord(direction.x)
 * write_coord(direction.y)
 * write_coord(direction.z)
 * write_short(modelindex)
 * write_byte(count)
 * write_byte(speed)
 * write_byte(noise)
 * write_byte(rendermode)
 */
#define TE_SPRAY                    120

/**
 * Sprites emit from a player's bounding box (ONLY use for players!)
 *
 * @note
 * write_byte(TE_PLAYERSPRITES)
 * write_short(playernum)
 * write_short(sprite modelindex)
 * write_byte(count)
 * write_byte(variance) (0 = no variance in size) (10 = 10% variance in size)
 */
#define TE_PLAYERSPRITES            121

/**
 * Very similar to lavasplash
 *
 * @note
 * write_byte(TE_PARTICLEBURST)
 * write_coord(origin)
 * write_short(radius)
 * write_byte(particle color)
 * write_byte(duration * 10) (will be randomized a bit)
 */
#define TE_PARTICLEBURST            122

/**
 * Makes a field of fire
 *
 * @note
 * write_byte(TE_FIREFIELD)
 * write_coord(origin)
 * write_short(radius) (fire is made in a square around origin. -radius, -radius to radius, radius)
 * write_short(modelindex)
 * write_byte(count)
 * write_byte(flags)
 * write_byte(duration (in seconds) * 10) (will be randomized a bit)
 */
#define TE_FIREFIELD                123

/**
 * Flags for the TE_FIREFIELD effect, controlling its performance and aesthetic
 * features
 */
#define TEFIRE_FLAG_ALLFLOAT        1        // All sprites will drift upwards as they animate
#define TEFIRE_FLAG_SOMEFLOAT       2        // Some of the sprites will drift upwards. (50% chance)
#define TEFIRE_FLAG_LOOP            4        // If set, sprite plays at 15 fps, otherwise plays at whatever rate stretches the animation over the sprite's duration.
#define TEFIRE_FLAG_ALPHA           8        // If set, sprite is rendered alpha blended at 50% else, opaque
#define TEFIRE_FLAG_PLANAR          16       // If set, all fire sprites have same initial Z instead of randomly filling a cube.

/**
 * Attaches a TENT to a player (this is a high-priority tent)
 *
 * @note
 * write_byte(TE_PLAYERATTACHMENT)
 * write_byte(entity index of player)
 * write_coord(vertical offset) (attachment origin.z = player origin.z + vertical offset)
 * write_short(model index)
 * write_short(life * 10 )
 */
#define TE_PLAYERATTACHMENT         124

/**
 * TE_KILLPLAYERATTACHMENTS
 *
 * @note
 * write_byte(TE_KILLPLAYERATTACHMENTS)
 * write_byte(entity index of player)
 */
#define TE_KILLPLAYERATTACHMENTS    125       * Will expire all TENTS attached to a player.

/**
 * Much more compact shotgun message
 *
 * @note This message is used to make a client approximate a 'spray' of gunfire.
 *       Any weapon that fires more than one bullet per frame and fires in a bit
 *       of a spread is a good candidate for MULTIGUNSHOT use. (shotguns)
 * @note This effect makes the client do traces for each bullet, these client
 *       traces ignore entities that have studio models.Traces are 4096 long.
 * @note
 * write_byte(TE_MULTIGUNSHOT)
 * write_coord(origin.x)
 * write_coord(origin.y)
 * write_coord(origin.z)
 * write_coord(direction.x)
 * write_coord(direction.y)
 * write_coord(direction.z)
 * write_coord(x noise * 100)
 * write_coord(y noise * 100)
 * write_byte(count)
 * write_byte(bullethole decal texture index)
 */
#define TE_MULTIGUNSHOT             126


/**
 * Larger message than the standard tracer, but allows some customization.
 *
 * @note
 * write_byte(TE_USERTRACER)
 * write_coord(origin.x)
 * write_coord(origin.y)
 * write_coord(origin.z)
 * write_coord(velocity.x)
 * write_coord(velocity.y)
 * write_coord(velocity.z)
 * write_byte(life * 10)
 * write_byte(color) this is an index into an array of color vectors in the engine. (0 - )
 * write_byte(length * 10)
 */
#define TE_USERTRACER               127

/**
 * @endsection
 */

/**
 * From hltv.h from the HLSDK, these are used in conjunction with SVC_DIRECTOR
 * sub commands of svc_director
 */
#define DRC_CMD_NONE				0	// NULL director command
#define DRC_CMD_START				1	// start director mode
#define DRC_CMD_EVENT				2	// informs about director command
#define DRC_CMD_MODE				3	// switches camera modes
#define DRC_CMD_CAMERA				4	// sets camera registers
#define DRC_CMD_TIMESCALE			5	// sets time scale
#define DRC_CMD_MESSAGE				6	// send HUD centerprint
#define DRC_CMD_SOUND				7	// plays a particular sound
#define DRC_CMD_STATUS				8	// status info about broadcast
#define DRC_CMD_BANNER				9	// banner file name for HLTV gui
#define	DRC_CMD_FADE				10	// send screen fade command
#define DRC_CMD_SHAKE				11	// send screen shake command
#define DRC_CMD_STUFFTEXT			12	// like the normal svc_stufftext but as director command

#define DRC_CMD_LAST				12

/**
 * HLTV_EVENT event flags
 */
#define DRC_FLAG_PRIO_MASK		0x0F	// priorities between 0 and 15 (15 most important)
#define DRC_FLAG_SIDE			(1<<4)	//
#define DRC_FLAG_DRAMATIC		(1<<5)	// is a dramatic scene
#define DRC_FLAG_SLOWMOTION		(1<<6)  // would look good in SloMo
#define DRC_FLAG_FACEPLAYER		(1<<7)  // player is doning something (reload/defuse bomb etc)
#define DRC_FLAG_INTRO			(1<<8)	// is a introduction scene
#define DRC_FLAG_FINAL			(1<<9)	// is a final scene
#define DRC_FLAG_NO_RANDOM		(1<<10)	// don't randomize event data

#define MAX_DIRECTOR_CMD_PARAMETERS		4
#define MAX_DIRECTOR_CMD_STRING			128
// vim: set ts=4 sw=4 tw=99 noet:
//
// AMX Mod X, based on AMX Mod by Aleksander Naszko ("OLO").
// Copyright (C) The AMX Mod X Development Team.
//
// This software is licensed under the GNU General Public License, version 3 or higher.
// Additional exceptions apply. For full license details, see LICENSE.txt or visit:
//     https://alliedmods.net/amxmodx-license

//
// Message Stocks
//
 
#if defined _message_stocks_included
	#endinput
#endif
#define _message_stocks_included

/* Creates a death message. */
stock dod_make_deathmsg(killer, victim, weaponNUM)
{
	message_begin(MSG_ALL, get_user_msgid("DeathMsg"), {0,0,0}, 0);
	write_byte(killer);
	write_byte(victim);
	write_byte(weaponNUM);
	message_end();

	return 1;
}

/* Kills a user without a message. */
stock user_silentkill(index)
{
	static msgid = 0;
	new msgblock;
	if (!msgid)
	{
		msgid = get_user_msgid("DeathMsg");
	}
	msgblock = get_msg_block(msgid);
	set_msg_block(msgid, BLOCK_ONCE);	
	user_kill(index, 1);
	set_msg_block(msgid, msgblock);

	return 1;
}

/* Creates a death message. */
stock make_deathmsg(killer, victim, headshot, const weapon[])
{
	message_begin(MSG_ALL, get_user_msgid("DeathMsg"), {0,0,0}, 0);
	write_byte(killer);
	write_byte(victim);

	new mod_name[32];
	get_modname(mod_name, 31);
	if (equal(mod_name, "cstrike") || equal(mod_name, "czero") || equal(mod_name, "csv15") || equal(mod_name, "cs13"))
		write_byte(headshot);
	write_string(weapon);
	message_end();

	return 1;
}

/**
 * Sends a predefined text message to player.
 * Predefined texts are default game messages which will be translated
 * to player's game language, e.g. #Game_join_ct.
 *
 * @note Set index to 0 to send text globally.
 *
 * @note There does not necessarily have to be a total of 6 arguments.
 *       It will depend if message takes arguments, e.g.:
 *         client_printex(id, print_chat, "#Game_join_ct", "Pimp Daddy")
 *         client_printex(id, print_chat, "1", "#Game_radio", "Pimp Daddy", "Hello world!")
 *
 * @param index         Index of the player, use 0 to send to all players.
 * @param type          The message destination. See print_* constants.
 * @param msg_name      The custom or predefined message to send.
 * @param msg_param1    Optional message argument.
 * @param msg_param2    Optional message argument.
 * @param msg_param3    Optional message argument.
 * @param msg_param4    Optional message argument.
 *
 * @noreturn
 */
stock client_printex(index, type, const msg_name[], const msg_param1[] = "", const msg_param2[] = "", const msg_param3[] = "", const msg_param4[] = "")
{
	new ch = msg_name[0];

	// If not a predefined message, we don't care about it and forward directly to client_print.
	// Special case for radio message. msg_name is an index, msg_param1 #Game_radio*, etc. Checking index should be enough.
	if (ch != '#' && (type != print_radio || !strtol(msg_name)))
	{
		return client_print(index, type, msg_name, msg_param1, msg_param2, msg_param3, msg_param4);
	}

	// Even if message starts with '#', we should check its length for safety.
	new length = strlen(msg_name);

	// If string is larger than expected, we forward to client_print which will cut message properly.
	// This means also this can't be a predefined game message.
	//   Max console length: 128 = \n (126) + \0 (127)
	//   Max SayText length: 192 = \n (190) + \0 (191)
	if ((length > 126 && (print_notify <= type <= print_console)) 
	|| ( length > 190 && (print_chat   <= type <= print_radio)))
	{
		return client_print(index, type, msg_name, msg_param1, msg_param2, msg_param3, msg_param4);
	}
	
	static msgTextMsg; 
	if (!msgTextMsg) 
	{ 
		msgTextMsg = get_user_msgid("TextMsg"); 
	}

	message_begin(index > 0 ? MSG_ONE_UNRELIABLE : MSG_BROADCAST, msgTextMsg, .player = index);
	write_byte(type);
	write_string(msg_name);
	if (msg_param1[0]) { write_string(msg_param1); }
	if (msg_param2[0]) { write_string(msg_param2); }
	if (msg_param3[0]) { write_string(msg_param3); }
	if (msg_param4[0]) { write_string(msg_param4); }
	message_end();
	
	return 1;
}
// vim: set ts=4 sw=4 tw=99 noet:
//
// AMX Mod X, based on AMX Mod by Aleksander Naszko ("OLO").
// Copyright (C) The AMX Mod X Development Team.
//
// This software is licensed under the GNU General Public License, version 3 or higher.
// Additional exceptions apply. For full license details, see LICENSE.txt or visit:
//     https://alliedmods.net/amxmodx-license

//
// Message Functions
//

#if defined _coremsg_included
  #endinput
#endif
#define _coremsg_included

#include <message_const>

/* These functinos are used to generate client messages.
 * You may generate menu, smoke, shockwaves, thunderlights,
 * intermission and many many others messages.
 * See HL SDK for more examples. */
native message_begin(dest, msg_type, const origin[3] = {0,0,0}, player = 0);
native message_begin_f(dest, msg_type, const Float:origin[3] = {0.0,0.0,0.0}, player = 0);
native message_end();
native write_byte(x);
native write_char(x);
native write_short(x);
native write_long(x);
native write_entity(x);
native write_angle(x);
native write_angle_f(Float:x);
native write_coord(x);
native write_coord_f(Float:x);
native write_string(const x[]);

/* These are the same as above, except that the messages sent
 *  are also sent to all other plugins and Metamod plugins.
 * This means that if you send one of these messages, other plugins will
 *  be notified, which was previously impossible.  
 * BE CAREFUL! Using these incorrectly, or not for their intended purpose,
 *  could cause infinite recursion or something just as bad. 
 * NOTE! These natives are experimental.
 */
native emessage_begin(dest, msg_type, const origin[3] = {0,0,0}, player = 0);
native emessage_begin_f(dest, msg_type, const Float:origin[3] = {0.0,0.0,0.0}, player = 0);
native emessage_end();
native ewrite_byte(x);
native ewrite_char(x);
native ewrite_short(x);
native ewrite_long(x);
native ewrite_entity(x);
native ewrite_angle(x);
native ewrite_angle_f(Float:x);
native ewrite_coord(x);
native ewrite_coord_f(Float:x);
native ewrite_string(const x[]);

/* Sets/Gets what engine messages are blocked. */
native set_msg_block(iMessage, iMessageFlags);
native get_msg_block(iMessage);

/* Lets you directly hook a message in the engine!
 * You can overwrite the message before anything happens and either let the message continue
 * or fully block it. Here is how it works:
 * If you hook a message, the message is stored but not sent. You have the opportunity to
 * not only execute code, but to get/set the contents of the message, before you choose to 
 * either block it or let it go on its way. The hooked function will be passed a msg_id, msg_dest, and entity index. 
 * The return value can be passed to unregister_message() to stop the message from being hooked */
native register_message(iMsgId, const szFunction[]);

/* Unregisters a message hook previously created with register_message
 * You must pass the proper message id, and return value from the message to unregister the message successfully. */
native unregister_message(iMsgId, registeredmsg);


/* The get/set _msg commands will fail if used outside a hooked message scope.
 * They should never be used unless inside a registered message function.
 * There are eight different ways of sending a message, five are ints, two are floats, and one is string.
 * These are denoted by iArgType.  argn is the number
 * of the argument. Exceeding the bounds of 1 to get_msg_args() is a bad idea. 
 * As of AMX Mod X 1.5, the middle parameter of set_* no longer does anything.
 * You cannot change the message argument type (as this would crash the mod anyway)
 */

/* Gets number of arguments that were passed to this message */
native get_msg_args();

/* Gets the argument type of argument argn */
native get_msg_argtype(argn);

/* Gets the value of argn. */
native get_msg_arg_int(argn);
native Float:get_msg_arg_float(argn);
native get_msg_arg_string(argn, szReturn[], iLength);

/* sets the value of argn. */
native set_msg_arg_int(argn, argtype, iValue);
native set_msg_arg_float(argn, argtype, Float:fValue);
native set_msg_arg_string(argn, const szString[]);

/* Gets the origin of a message */
native get_msg_origin(const Float:_Origin[3]);
// vim: set ts=4 sw=4 tw=99 noet:
//
// AMX Mod X, based on AMX Mod by Aleksander Naszko ("OLO").
// Copyright (C) The AMX Mod X Development Team.
//
// This software is licensed under the GNU General Public License, version 3 or higher.
// Additional exceptions apply. For full license details, see LICENSE.txt or visit:
//     https://alliedmods.net/amxmodx-license

#if defined _newmenus_included
  #endinput
#endif
#define _newmenus_included

#define MEXIT_ALL		1		/* Menu will have an exit option (default)*/
#define MEXIT_FORCE		2		/* Menu will have an exit option, even when pagination is disabled. 
 * There have to be less than 10 items in the menu or it won't appear. The exit 
 * option will be appended to the last item with no extra slot padding. If you 
 * want it in the 10th slot you have to pad it manually with menu_addblank2 */
#define MEXIT_NEVER		-1		/* Menu will not have an exit option */

#define MPROP_PERPAGE	1		/* Number of items per page (param1 = number, 0=no paginating, 7=default) */
#define MPROP_BACKNAME	2		/* Name of the back button (param1 = string) */
#define MPROP_NEXTNAME	3		/* Name of the next button (param1 = string) */
#define MPROP_EXITNAME	4		/* Name of the exit button (param1 = string) */
#define MPROP_TITLE		5		/* Menu title text (param1 = string) */
#define MPROP_EXIT		6		/* Exit functionality (param1 = number, see MEXIT constants) */
#define MPROP_NOCOLORS	8		/* Sets whether colors are not auto (param1 = number, 0=default) */
#define MPROP_NUMBER_COLOR	10	/* Color indicator to use for numbers (param1 = string, "\r"=default) */

#define MEXIT_NORMAL	0		/* DEPRECATED, do not use (has no effect) */
#define MENUPAD_NONE	0		/* DEPRECATED, do not use (has no effect) */
#define MENUPAD_PAGE	1		/* DEPRECATED, do not use (has no effect) */
#define MPROP_ORDER		7		/* DEPRECATED, do not use (has no effect) */
#define MPROP_PADMENU	9		/* DEPRECATED, do not use (has no effect) */

/**
 * @brief Creates a new menu object.
 *
 * The handler function should be prototyped as:
 *
 * public <function>(id, menu, item)
 *  id     - Client the menu is being acted upon.
 *  menu   - Menu resource identifier.
 *  item   - Item the client selected.  If less than 0, the menu was 
 *           cancelled and the item is a status code.  menu_display 
 *			 should never be called immediately if the item is a status 
 *			 code, for re-entrancy reasons.
 *
 * The handler function should always return PLUGIN_HANDLED to block 
 * any old menu handlers from potentially feeding on the menu, unless 
 * that is the desired functionality.
 *
 * @param title 		Title the menu should use.
 * @param handler		Name of the handler function.  The function will be invoked 
 *						once and only once to every menu_display() call.
 * @param ml			Unused (should be 0).
 * @return				Menu resource identifier which must be destroyed via 
 *						menu_destroy().  All menus are destroyed when the plugin 
 *						unloads.
 * @error				Function name not found.
 */
native menu_create(const title[], const handler[], ml=0);

/**
 * Creates a menu item callback handler.  
 *
 * The handler function should be prototyped as:
 *
 * public <function>(id, menu, item)
 *  id      - Client index being displayed to.
 *  menu    - Menu resource identifier.
 *  item    - Item being drawn.
 * <return> - ITEM_IGNORE to use the default functionality.  ITEM_ENABLED to 
 *            explicitly enable or ITEM_DISABLED to explicitly disable.
 *
 * @param function		Function name.
 * @return				Menu callback ID.
 */
native menu_makecallback(const function[]);

/**
 * Adds an menu to a menu.
 *
 * @param menu			Menu resource identifier.
 * @param name			Item text to display.
 * @param info			Item info string for internal information.
 * @param paccess		Access required by the player viewing the menu.
 * @param callback		If set to a valid ID from menu_makecallback(), the 
 *						callback will be invoked before drawing the item.
 * @noreturn
 * @error				Invalid menu resource.
 */
native menu_additem(menu, const name[], const info[]="", paccess=0, callback=-1);

/**
 * Returns the number of pages in a menu.
 *
 * @param menu			Menu resource identifier.
 * @return				Number of pages in the menu.
 * @error				Invalid menu resource.
 */
native menu_pages(menu);

/**
 * Returns the number of items in a menu.
 *
 * @param menu			Menu resource identifier.
 * @return				Number of items in the menu.
 * @error				Invalid menu resource.
 */
native menu_items(menu);

/**
 * Displays a menu to one client.  This should never be called from a handler 
 * when the item is less than 0 (i.e. calling this from a cancelled menu will 
 * result in an error).
 *
 * Starting with 1.8.3 this allows to specify a menu timeout similar to the 
 * show_menu native. If the menu exists on the client past the timeout *any* 
 * further action will send the MENU_TIMEOUT status code to the menu handler.
 * That includes actions which would otherwise send MENU_EXIT, such as the
 * client selecting an item or disconnecting and calling menu_cancel or 
 * menu_destroy on a live menu.
 *
 * @param id			Client index.
 * @param menu			Menu resource identifier.
 * @param page			Page to start from (starting from 0).
 * @param time			If >=0 menu will timeout after this many seconds
 * @noreturn
 * @error				Invalid menu resource or client index.
 */
native menu_display(id, menu, page=0, time=-1);

/**
 * Given a page on a menu and a keypress on that page, returns the item id selected.
 * If the item is less than 0, a special option was chosen (such as MENU_EXIT).
 *
 * @param menu			Menu resource identifier.
 * @param page			Page on the menu.
 * @param key			Key pressed (from 1 to 10).
 * @return				Item identifier, or <0 for a special selection code.
 * @error				Invalid menu resource.
 */
native menu_find_id(menu, page, key);

/**
 * Retrieves info about a menu item.
 *
 * @param menu			Menu resource identifier.
 * @param item			Item identifier.
 * @param access		Variable to store access value.
 * @param info			Buffer to store item info.
 * @param infolen		Item info buffer length.
 * @param name			Buffer to store item display text.
 * @param namelen		Item name buffer length.
 * @param callback		Callback ID.
 * @return				1 on success, 0 on failure.
 * @error				Invalid menu resource.
 */
native menu_item_getinfo(menu, item, &access, info[], infolen, name[]="", namelen=0, &callback);

/**
 * Sets an item's display text.
 *
 * @param menu			Menu resource identifier.
 * @param item			Item identifier.
 * @param name			New item display text.
 * @return				1 on success, 0 on failure.
 * @error				Invalid menu resource.
 */
native menu_item_setname(menu, item, const name[]);

/**
 * Sets an item's info string.
 *
 * @param menu			Menu resource identifier.
 * @param item			Item identifier.
 * @param info			New item info string.
 * @return				1 on success, 0 on failure.
 * @error				Invalid menu resource.
 */
native menu_item_setcmd(menu, item, const info[]);

/**
 * Sets an item's callback.
 *
 * @param menu			Menu resource identifier.
 * @param item			Item identifier.
 * @param callback		New callback from menu_makecallback(), or -1 to clear.
 * @return				1 on success, 0 on failure.
 * @error				Invalid menu resource.
 */
native menu_item_setcall(menu, item, callback=-1);

/**
 * Destroys a menu.  Player menus will be cancelled (although may still linger 
 * on the HUD), and future attempts to access the menu resource will result in 
 * an error.
 *
 * This must be called if you create menus dynamically, otherwise you will 
 * leak memory.  For normal dynamic menus, you will destroy the menu in the 
 * handler function (remembering to handle the case of a menu being cancelled, 
 * it must still be destroyed).
 *
 * @param menu			Menu resource identifier.
 * @noreturn
 * @error				Invalid menu resource.
 */
native menu_destroy(menu);

/**
 * Returns information about a menu (if any) the client is currently viewing.
 *
 * If newmenu is valid, then the menu will refer to the menuid associated with 
 * the title.  If newmenu is not valid, and the menu is valid, then the player 
 * is viewing a menu displayed with show_menu().
 *
 * Both may be invalid if the player is not viewing a menu.
 *
 * @param id			Client index.
 * @param menu			Variable to store old menu id.  If none, then <1 will be 
 *						stored.
 * @param newmenu		Variable to store new menu id.  If none, then -1 will be 
 *						stored.
 * @param menupage		Variable to store current page of the new menu, if any.
 * @return				1 if the player is viewing a menu, 0 otherwise.
 * @error				Invalid client.
 */
native player_menu_info(id, &menu, &newmenu, &menupage=0);

/**
 * Adds a blank line to a menu.
 * 
 * When using slot=1 this might break your menu. To achieve this functionality
 * menu_addblank2 should be used.
 * 
 * @param menu			Menu resource identifier.
 * @param slot			1 (default) if the line should shift the numbering down.
 * 						0 if the line should be a visual shift only.
 * @noreturn
 * @error				Invalid menu resource.
 */
native menu_addblank(menu, slot=1);

/**
 * Adds a text line to a menu.  Only available in amxmodx 1.8.1 and above.
 *
 * When using slot=1 this might break your menu. To achieve this functionality
 * menu_addtext2 should be used.
 * 
 * @param menu			Menu resource identifier.
 * @param text			Text to add.
 * @param slot			1 (default) if the line should shift the numbering down.
 * 						0 if the line should be a visual shift only.
 * @noreturn
 * @error				Invalid menu resource.
 */
native menu_addtext(menu, const text[], slot=1);

/**
 * Adds a blank line to a menu, always shifting the numbering down.
 * 
 * This will add a special item to create a blank line. It will affect the menu
 * item count and pagination. These items can be modified later but will ignore 
 * access and item callback results.
 * 
 * Only available in 1.8.3 and above.
 * 
 * @param menu          Menu resource identifier.
 * 
 * @return              1 on success, 0 on failure.
 * @error               Invalid menu resource.
 *                      Too many items on non-paginated menu (max is 10)
 */
native menu_addblank2( menu );

/**
 * Adds a text line to a menu, always shifting the numbering down.
 * 
 * This will add a special item to create a blank line. It will affect the menu
 * item count and pagination. These items can be modified later but will ignore 
 * access and item callback results.
 * 
 * Only available in 1.8.3 and above.
 *
 * @param menu          Menu resource identifier.
 * @param text          Text to add.
 * 
 * @return              1 on success, 0 on failure.
 * @error               Invalid menu resource.
 *                      Too many items on non-paginated menu (max is 10)
 */
native menu_addtext2( menu, const text[] );

/**
 * Sets a menu property.
 *
 * @param menu			Menu resource identifier.
 * @param prop			MPROP_ constant.
 * @param ...			Property parameters.
 * @return				1 on success, 0 on failure.
 * @error				Invalid menu resource or property.
 */
native menu_setprop(menu, prop, ...);

/**
 * Cancels a player's menu, effectively forcing the player to select MENU_EXIT.
 * The menu will still exist on their screen but any results are invalidated,
 * and the callback is invoked.
 *
 * @param player		Client index.
 * @noreturn
 * @error				Invalid client index.
 */
native menu_cancel(player);
// vim: set ts=4 sw=4 tw=99 noet:
//
// AMX Mod X, based on AMX Mod by Aleksander Naszko ("OLO").
// Copyright (C) The AMX Mod X Development Team.
//
// This software is licensed under the GNU General Public License, version 3 or higher.
// Additional exceptions apply. For full license details, see LICENSE.txt or visit:
//     https://alliedmods.net/amxmodx-license

//
// Natural Selection Module Functions
//

#if defined NS_INC
	#endinput
#endif
#define NS_INC	

#if AMXX_VERSION_NUM >= 175
 #pragma reqlib ns
 #if !defined AMXMODX_NOAUTOLOAD
  #pragma loadlib ns
 #endif
#else
 #pragma library ns
#endif



#include <ns_const>


/**
 * Called whenever the client's class is changed.
 *
 * @param	id			The index of the player who changed.
 * @param 	newclass	The class the client changed to.  Check the class enum in ns_const.inc.
 * @param 	oldclass	The class the client changed from.  Check the class enum in ns_const.inc.
 * @noreturn
 */
forward client_changeclass(id, newclass, oldclass);

/**
 * Called whenever the client builds a structure.
 *
 * @param idPlayer		The player index who triggered the building.
 * @param idStructure	The structure index that was created.
 * @param type			The type of structure that was built (1 for marine, 2 for alien).
 * @param impulse		The impulse command that was issued to build this structure.
 * @noreturn
 */
forward client_built(idPlayer, idStructure, type, impulse);

/**
 * Tell whether or not the map is combat.
 *
 * @return		1 if combat, 0 otherwise.
 */
native ns_is_combat();

/**
 * Returns the gameplay type for the currently active map.
 * Refer to ns_const.inc's NSGameplay enum for details.
 *
 * @note		The earliest this is guaranteed to be accurate is during plugin_init().  It needs
 *				the info_gameplay entity to be properly set within the map, or it will return "Unknown",
 *				or "Cantfind".
 *
 * @return		Return the gameplay mode, as accurate as the module can tell.
 */
native NSGameplay:ns_get_gameplay();

/**
 * Exact syntax as get_user_team, but should be more accurate.
 *
 * @param id	Player id.
 * @param buff	Buffer to store team name in.
 * @param len	Buffer length.
 * @return		The pev_team setting for the player.
 */
native ns_get_user_team(id, buff[], len);

/**
 * Send an NS-style popup message.
 * 
 * @param target		The client to receive the message.  Set to 0 to send to everybody.
 * @param szMsg		The message to send, 180 characters max.
 * @param ah			Whether to only display the message on clients who have the cvar "cl_autohelp" set to 1.
 * @noreturn
 */
native ns_popup(target, const szMsg[180], ah=0);

/**
 * Sets a player model.  Omit the second parameter to return to default
 *
 * @note				The model does not revert on death, teamswitch, gestation, etc.
 *
 * @param id			The player id to change.
 * @param szModel		The model to change to.
 * @noreturn
 */
native ns_set_player_model(id, const szModel[]="");

/**
 * Sets a player skin.  Omit the second parameter to return to default
 *
 * @note				The skin does not revert on death, teamswitch, gestation, etc.
 *
 * @param id			The player id to change.
 * @param skin			The skin number to change to.
 * @noreturn
 */
native ns_set_player_skin(id, skin=-1);

/**
 * Sets a player body.  Omit the second parameter to return to default
 *
 * @note				The body does not revert on death, teamswitch, gestation, etc.
 *
 * @param id			The player id to change.
 * @param body			The body number to change to.
 * @noreturn
 */
native ns_set_player_body(id, body=-1);

/**
 * Set this to modify the player's speed by a certain amount.
 *
 * @note				The speed does not revert on death, teamswitch, gestation, etc.
 *
 * @param id			The player id to change.
 * @param speedchange	The speed to modify the player speed by.  Set to 0 to revert to default speed.
 * @noreturn
 */
native ns_set_speedchange(id, speedchange=0);

/**
 * Returns a client's current speed modifier.
 *
 * @param	id			The client id to check.
 * @return				The module's current speed modifier for the client.
 */
native ns_get_speedchange(id);

/**
 * Returns a client's maxspeed before the speed change modifier is factored in.
 *
 * @param	id			The client id to check.
 * @return				The maxspeed for the client.
 */
native ns_get_maxspeed(id);

/* Returns whether or not this mask is set from the entity's iuser4 field.  Use the "mask" enum for reference. */
native ns_get_mask(id,mask);

/* Sets or removes the mask from the entity's iuser4 field. Set "value" to 1 to turn the mask on, 0 to turn it off. */
native ns_set_mask(id,mask,value);

/* Returns built/unbuilt structures.
	If:
		builtOnly is 1 (default):
			Only fully built structures are counted.
		builtOnly is 0:
			Any structure meeting the classname is counted.
		
		Number is 0 (default):
			The total number of matching structures is returned.
		Number is any other value:
			The index of the #th matching structure is returned.
*/
native ns_get_build(const classname[],builtOnly=1,Number=0);

/* Returns if the player has the weapon or not in their pev->weapons field.
   set "setweapon" to 0 to turn the bit off, set to 1 to turn it on. Or omit it to just return the value. */
native ns_has_weapon(id,weapon,setweapon=-1);

/* Gets spawn point for specified team (type). 
	If:
		Team is equal to 0:
			Ready room spawns are returned.
		Team is greater than 0:
			Spawns for the team are returned.
			
		Number is equal to 0:
			Total number of spawns is returned.
		Number is greater than 0:
			The location of the specified spawn is returned.
*/
native ns_get_spawn(team,number=0,Float:ret[3]);

/* Returns the class of the player.  Look in the classes enum in ns_const.inc for the value's meaning. */
native ns_get_class(id);

/**
 * Gets the player's jetpack fuel reserve.
 *
 * @param id		The player to get fuel from.
 * @return			The amount of fuel in the player's reserve. (0.0 through 100.0)
 */
native Float:ns_get_jpfuel(id);

/**
 * Sets the player's jetpack fuel reserve.
 *
 * @param id		The player to set fuel.
 * @param fuel		The amount of fuel to set, as a percentage (0.0 through 100.0)
 * @noreturn
 */
native ns_set_jpfuel(id, Float:fuel);

/**
 * Adds to the player's jetpack fuel reserve.
 *
 * @param id		The player to add fuel to.
 * @param amount	The amount of fuel to add, as a percentage (0.0 through 100.0)
 * @return			The new amount of fuel in the player's reserve. (0.0 through 100.0)
 */
native Float:ns_add_jpfuel(id, Float:amount);

/**
 * Gets the player's energy percentage.
 *
 * @param id		The player to get the energy from.
 * @return			The amount of energy the player has (0.0 through 100.0)
 */
native Float:ns_get_energy(id);

/**
 * Sets the player's energy percentage.
 *
 * @param id		The player to set the energy on.
 * @param energy	The amount of energy to set (0.0 through 100.0)
 * @noreturn
 */
native ns_set_energy(id, Float:energy);

/**
 * Adds to the player's energy percentage.
 *
 * @param id		The player to add the energy to.
 * @param amount	The amount of energy to add to the player.
 * @return			The new amount of energy the player has (0.0 through 100.0)
 */
native Float:ns_add_energy(id, Float:amount);


/**
 * Returns a player's resources.
 *
 * @note			This is only for alien players.
 * @param id		The id of the player to check.
 * @return			Amount of resources this player has.
 */
native Float:ns_get_res(id);

/**
 * Sets a player's resources.
 *
 * @note			This is only for alien players.
 * @param id		The id of the player to set.
 * @param res		Amount of resources to set on this player.
 * @noreturn
 */
native ns_set_res(id, Float:res);

/**
 * Adds an amount of resources to the player.
 *
 * @note			This is only for alien players.
 * @param id		The id of the player to add resources to.
 * @param amount	The amount to add to the player.
 * @return			The new amount of resources the player has.
 */
native Float:ns_add_res(id, Float:amount);

/**
 * Returns the team's resources.
 * 
 * @param Team		1 for teama, 2 for teamb. (eg: in MvA maps, 1 is marines,
					2 is aliens.  In mvm, 1 is marine1, 2 is marine2)
 * @return			The amount of resources in this team's resource pool.
 */
native Float:ns_get_teamres(Team);

/**
 * Sets the team's resources in the resource pool.
 * 
 * @note			If this is used on an alien team, the resources will be
 *					distributed between all of the players who need resources.
 * @param Team		1 for teama, 2 for teamb. (eg: in MvA maps, 1 is marines,
 *					2 is aliens.  In mvm, 1 is marine1, 2 is marine2)
 * @param value	The amount to set the resources to set to.
 * @noreturn
 */
native ns_set_teamres(Team, Float:value);

/**
 * Adds to the team's resources in the resource pool.
 * 
 * @note			If this is used on an alien team, the resources will be
 *					distributed between all of the players who need resources.
 * @param Team		1 for teama, 2 for teamb. (eg: in MvA maps, 1 is marines,
 *					2 is aliens.  In mvm, 1 is marine1, 2 is marine2)
 * @param value	The amount to set the resources to add to the pool
 * @return			The new amount of resources in the resource pool.
 */
native Float:ns_add_teamres(Team,Float:value);


/**
 * Returns the player's experience.
 *
 * @note			Combat only.
 * @param id		The player to get experience value from.
 * @return			The amount of experience this player has.
 */
native Float:ns_get_exp(id);

/**
 * Sets the player's experience.
 *
 * @note			Combat only.
 * @param id		The player to set experience value on.
 * @param exp		The amount of experience this player will have.
 * @noreturn
 */
native ns_set_exp(id,Float:exp);

/**
 * Adds to the player's experience.
 *
 * @note			Combat only.
 * @param id		The player to add experience value to.
 * @param value	The amount of experience this player will receive.
 * @return			The new amount of experience this player has.
 */
native Float:ns_add_exp(id, Float:value);

/**
 * Gets the player's points spent count in combat.
 *
 * @param id		The player to check.
 * @return			The amount of points this player has spent.
 */
native ns_get_points(id);

/**
 * Sets the player's points spent count in combat.
 *
 * @param id		The player to set this on.
 * @param points	The amount to set this to.
 * @noreturn
 */
native ns_set_points(id, points);

/**
 * Adds to the player's points spent count in combat.
 *
 * @param id		The player to add this to.
 * @param value	The value to add to the points spent.
 * @return			The new value of the points spent variable.
 */
native ns_add_points(id,points);

/**
 * Gets the damage for this weapon.
 *
 * @note			Use weapon index, not player index!
 * @param idWeapon	The entity index of the weapon to check.
 * @return			The damage this weapon does.
 */
native Float:ns_get_weap_dmg(idWeapon);

/**
 * Sets the damage for this weapon.
 *
 * @note			Use weapon index, not player index!
 * @param idWeapon	The entity index of the weapon to set.
 * @param damage	The damage to make this weapon cause.
 * @noreturn
 */
native ns_set_weap_dmg(idWeapon, Float:damage);

/**
 * Gets the maximum range for this weapon.
 *
 * @note			Use weapon index, not player index!
 * @param idWeapon	The entity index of the weapon to check.
 * @return			The maximum range this weapon has.
 */
native Float:ns_get_weap_range(idWeapon);

/**
 * Sets the maximum range for this weapon.
 *
 * @note			Use weapon index, not player index!
 * @param idWeapon	The entity index of the weapon to set.
 * @param range	The maximum range this weapon will have.
 * @noreturn
 */
native ns_set_weap_range(idWeapon, Float:range);

/**
 * Gets the weapon's clip ammo.
 *
 * @note			Use weapon index, not player index!
 * @param idWeapon	The weapon to get the clip ammo from.
 * @return			The amount of ammunition in the weapon's clip.
 */
native ns_get_weap_clip(idWeapon);

/**
 * Sets the weapon's ammo in the clip.
 *
 * @note			Use weapon index, not player index!
 * @param idWeapon	The weapon to set the clip ammo on.
 * @param clipsize	The amount of ammunition to set in the weapon's clip.
 * @noreturn
 */
native ns_set_weap_clip(idWeapon, clipsize);

/**
 * Gets the player's weapon reserve (backpack ammo) for the specified
 * type of weapon.
 *
 * @note			Use player index, not weapon index!
 * @param id		The player id to check ammo count on.
 * @param weapon	The weapon type to check ammo count for.
 * @return			The ammunition count in the player's reserve.
 */
native ns_get_weap_reserve(id,weapon);

/**
 * Sets the player's weapon reserve (backpack ammo) for the specified
 * type of weapon.
 *
 * @note			Use player index, not weapon index!
 * @param id		The player id to set ammo count on.
 * @param weapon	The weapon type to set ammo count for.
 * @param ammo		The ammunition count to set.
 * @noreturn
 */
native ns_set_weap_reserve(id,weapon,ammo);

/**
 * Gets the player's score.
 *
 * @note			The score from level is automatically factored into the scoreboard in combat.
 * @param idPlayer	The player to get the score for.
 * @return			The player's score.
 */
native ns_get_score(idPlayer);

/**
 * Sets the player's score.
 *
 * @note			The score from level is automatically factored into the scoreboard in combat.
 * @param idPlayer	The player to get the score for.
 * @param score	What to set the player's score as.
 * @noreturn
 */
native ns_set_score(idPlayer, score);

/* Adds to a player's score
 * Returns the new score on success
 */
native ns_add_score(idPlayer,score);

/* Gets a player's death count. */
native ns_get_deaths(idPlayer);

/* Sets a player's death count. */
native ns_set_deaths(idPlayer,numdeaths);

/* Adds to a player's death count
 * Returns the new death count on success
 */
native ns_add_deaths(idPlayer,numdeaths);

/* Gets the index of the owner of a structure. -1 for no owner. */
native ns_get_struct_owner(idStructsure);

/* Sets the index of the owner of a structure. -1 for no owner. */
native ns_set_struct_owner(idStructure,indexOwner);

/* Gets the trait type tied to the hive.  Look at the hivetrait enum for the values. */
native ns_get_hive_trait(idHive);

/* Sets the trait type tied to the hive.  Look at the hivetrait enum for the values. */
native ns_set_hive_trait(idHive,trait);

/* Sets the players field of view, set "_fov" to 0.0 (or omit it) to return to normal. FOV change will persist until disconnect unless reset by a plugin */
native ns_set_fov(idPlayer,Float:_fov=0.0);

/**
 * Give the player an item.
 *
 * @param id		The player to give the item to.
 * @param class	The map-classname of the entity to give to the player.
 * @noreturn
 */
native ns_give_item(id, const class[]);

/**
 * Returns 1 if a player has the hive ability number.
 * If ability is 0, it will return the number of active hives.
 *
 * @param idPlayer	The player index to look up.
 * @param ability	The ability number to check, set to 0 to get number of active hives.
 * @return			If ability is != 0, returns 1 or 0 depending on if the client has the ability.
 *					If ability is 0, returns the number of active hives.
 */
native ns_get_hive_ability(idPlayer, ability=0);

/**
 * Triggered whenever a client's pev->team changes.
 *
 * @param id		The id of the client.
 * @param newteam	The team number of the new team.
 * @param oldteam	The team number of the old team.
 * @noreturn
 */
forward client_changeteam(id, newteam, oldteam);

/**
 * Triggered whenever a client's pev->deadflag changes from >0 to 0.
 *
 * @param id		The id of the client.
 * @noreturn
 */
forward client_spawn(id);

/**
 * Calls NS's private damage routine on the victim entity.
 *
 * @deprecated
 * @note		This is provided for backwards compatibility with peachy's module.
 *				It is suggested to use hamsandwich for this action instead.
 *
 * @param IDVictim		The victim that is taking the damage.
 * @param IDInflictor	The entity that is causing the damage (weapon, etc).
 * @param IDAttacker	The attacker who is triggering the damage (person shooting).
 * @param Damage		The amount of damage being done.
 * @param DamageType	The damage type being done (bitmask).
 */
native ns_takedamage(IDVictim, IDInflictor, IDAttacker, Float:Damage, DamageType);

/**
 * Attempts to unstick a player.
 *
 * @param id				Player to unstick.
 * @param StartDistance	Distance to start from the player to check for a new location.
 * @param MaxAttempts		How many attempts to try to find a new spot before giving up.
 * @return					1 on success, 0 on cannot find a place to move player to,
 *							-1 on invalid state (stunned/webbed), -2 on invalid class (comm/egg)
 *							-3 if the player is dead or a spectator, -4 on invalid player,
 *							-5 if the player is not connected.
 */
native ns_unstick_player(id, StartDistance=32, MaxAttempts=128);

/**
 * Whether or not there is a game in progress.
 *
 * @return		true if a game is in progress, false otherwise.
 */
native bool:ns_round_in_progress();

/**
 * Called at the approximate time that a round is started.
 *
 * @noreturn
 */
forward round_start();

/**
 * Called immediately when a round ends
 *
 * @param roundtime		The length of the round in seconds.
 * @noreturn
 */
forward round_end(Float:roundtime);

forward map_reset(isload);

native ns_get_weapon(idPlayer,weaponid,&weapontype=0);

/* Returns the location name of the provided x/y position
 * (z origin is ignored; can't have location over location)
 * -
 * Note that as of NS 3.2 beta 2, on the following maps
 * the returned string should be passed through ns_lookup_title
 * to be human readable:
 *   ns_bast, ns_hera, ns_nothing, ns_tanith,
 *   ns_nancy, ns_caged, ns_eclipse, ns_veil
 *
 * Passing the 5th parameter as non zero will auto look up
 * the title if it exists.
 */
native ns_get_locationname(Float:x, Float:y, name[], len, titlelookup=0);

/* Looks up a key from titles.txt
 * Returns -1 if the key is not found
 * Otherwise it returns the length of the output
 */
native ns_lookup_title(const KeyName[], Output[], length);

/* Forces the structure to fully build
 * Removes the ghost state from marine structures.
 * Do not use this on hives! It wont work.
 */
native ns_build_structure(idStructure);

/* Forces the structure to begin recycling 
 * Passing an index other than a marine structure will
 * have undefined results!
 * -
 * Note: This calls a private NS function!
 *       Be careful when using this!
 */
native ns_recycle(idStructure);

/* Forces the weldable to trigger
 * Passing an index other than a weldable
 * will have undefined results!
 * -
 * NS renames func_weldable to avhweldable
 * at map load.
 * -
 * Note: This calls a private NS function!
 *       Be careful when using this!
 */
native ns_finish_weldable(idWeldable);

/* Gets the total time needed to weld this
 * func_weldable shut.
 * Note: NS renames "func_weldable"s to "avhweldable"s
 * at run time!
 */
native Float:ns_get_weld_time(idWeldable);

/* Sets the total time needed to weld this
 * func_weldable shut.
 */
native ns_set_weld_time(idWeldable,Float:value);

/* Adds to the weldable's time required to open. 
 * Returns the new required time on success.
 * Note this native clamps the low value to 0.
 */
native Float:ns_add_weld_time(idWeldable,Float:value);

/* Gets the total time this func_weldable
 * has been welded.
 */
native Float:ns_get_weld_done(idWeldable);

/* Sets the total time this func_weldable
 * has been welded.
 */
native ns_set_weld_done(idWeldable,Float:value);

/* Adds to the total time this func_weldable
 * has been welded.  Returns the new value.
 * Note this native clamps the low value to 0.0
 */
native Float:ns_add_weld_done(idWeldable,Float:value);

/* Gets/sets/adds to the energy pool of this observatory. */
native Float:ns_get_obs_energy(idObs);
native ns_set_obs_energy(idObs,Float:value);
native Float:ns_add_obs_energy(idObs,Float:value);

/**
 * Removes an upgrade from the player's bought and active upgrade lists.
 * This will not refund the points spent on the upgrade, nor will it
 * immediately strip the upgrade if the player is alive.  Rather, it will
 * make it so the player no longer receives the upgrade on spawn.
 *
 * @note This only works in combat.
 * @params idPlayer		The player index to change upgrades for.
 * @params ugprade		The impulse number for the upgrade to strip.
 * @return 				2 for upgrade removed from player's bought and active list.
 *						1 for upgrade removed from player's bought list only.
 *						3 for upgrade removed from player's active list only (shouldn't happen, just incase.)
 *						0 for the player didn't have the upgrade in either list.
 */
native ns_remove_upgrade(idPlayer, upgrade);

/**
 * Particle system natives
 * -
 * The particle system emulates a map-based custom particle system.
 * Familiarity with the keyvalues from the map-based particle systems
 * is recommended! You will be lost otherwise!
 * -
 * prsearle's NSPEdit is also recommended for designing the systems:
 * http://homepage.ntlworld.com/pr.searle/NSPSEdit/NSPSEdit.html
 */

/* Creates a handle to the a particle system to configure
 * -
 * Note! this is not a particle system you can pass to 
 * ns_fire_ps()!
 */
native RawPS:ns_create_ps();

/* Sets the name of the particle system.
 * -
 * This is used for things like ns_get_ps_id()
 * and through calling another particle system
 * through the "ps_to_gen" field
 */
native ns_set_ps_name(RawPS:system, const name[]);

/* Sets the sprite to use for the particle system
 * -
 * You do NOT have to precache the sprite, BUT
 * the sprite must obviously be on the client to 
 * display.
 */
native ns_set_ps_sprite(RawPS:system, const sprite[]);

/* Finalizes the particle system.  Do not configure it after this.
 * A usable particle system handle is returned.
 */
native Particle:ns_spawn_ps(RawPS:system);

/* Draws a particle system at the given origin (and angles)
 * Flags are the FEV_* defines from hlsdk_const.inc
 * Only use handles returned by ns_spawn_ps or ns_get_ps_id here!
 */
native ns_fire_ps(Particle:system,const Float:origin[3],const Float:angles[3]={0.0,0.0,0.0}, flags=0);

/* Looks up a particle system by name
 * Returns a usable particle system handle.
 */
native Particle:ns_get_ps_id(const Name[]);

/* The following are the parameters for configuring the 
 * particle system.  Look through the fgd and NSPSEdit
 * for details!
 */
native ns_set_ps_genrate(RawPS:system, genrate);
native ns_set_ps_genshape(RawPS:system, NSPS_GenShape:genshape);
native ns_set_ps_genshape_params(RawPS:system, const params[]);
native ns_set_ps_spriteframes(RawPS:system, spriteframes);
native ns_set_ps_numparticles(RawPS:system, numparticles);
native ns_set_ps_size(RawPS:system, Float:size);
native ns_set_ps_vel_params(RawPS:system, const params[]);
native ns_set_ps_vel_shape(RawPS:system, NSPS_VelShape:shape);
native ns_set_ps_sys_life(RawPS:system, Float:lifetime);
native ns_set_ps_particle_life(RawPS:system, Float:lifetime);
native ns_set_ps_rendermode(RawPS:system, NSPS_RenderMode:rendermode);
native ns_set_ps_to_gen(RawPS:system, const name[]);
native ns_set_ps_anim_speed(RawPS:system, speed);
native ns_set_ps_spawn_flags(RawPS:system, NSPS_Flags:flags);
native ns_set_ps_base_color(RawPS:system, const colors[]);
native ns_set_ps_scale(RawPS:system, Float:scale);
native ns_set_ps_max_alpha(RawPS:system, Float:maxalpha);
// vim: set ts=4 sw=4 tw=99 noet:
//
// AMX Mod X, based on AMX Mod by Aleksander Naszko ("OLO").
// Copyright (C) The AMX Mod X Development Team.
//
// This software is licensed under the GNU General Public License, version 3 or higher.
// Additional exceptions apply. For full license details, see LICENSE.txt or visit:
//     https://alliedmods.net/amxmodx-license

//
// Natural Selection Module Constants
//

#if defined NS_CONST_INC
	#endinput
#endif
#define NS_CONST_INC


enum NSGameplay
{
	NSGame_CantTell,		/**< It is too soon to tell (can't find avhgameplay
								 entity or it doesn't have private data) */

	NSGame_MarineVAlien,	/**< Marine vs Aliens (standard) gameplay */
	NSGame_MarineVMarine,	/**< Marine vs Marine */
	NSGame_AlienVAlien,		/**< Alien  vs Alien  */

	NSGame_Unknown,			/**< Can find the gameplay entity, but can't 
								 determine gameplay type. */
};

// entity pev->iuser4 fields
enum {
	MASK_NONE = 0,
	MASK_SIGHTED = 1,
	MASK_DETECTED = 2,
	MASK_BUILDABLE = 4,
	MASK_BASEBUILD0 = 8,		// Base build slot #0
	MASK_WEAPONS1 = 8,		// Marine weapons 1
	MASK_CARAPACE = 8,		// Alien carapace
	MASK_WEAPONS2 = 16,		// Marines weapons 2
	MASK_REGENERATION = 16,		// Alien regeneration
	MASK_BASEBUILD1 = 16,		// Base build slot #1
	MASK_WEAPONS3 = 32,		// Marine weapons 3
	MASK_REDEMPTION = 32,		// Alien redemption
	MASK_BASEBUILD2 = 32,		// Base build slot #2
	MASK_ARMOR1 = 64,		// Marine armor 1
	MASK_CELERITY = 64,		// Alien celerity
	MASK_BASEBUILD3 = 64,		// Base build slot #3
	MASK_ARMOR2 = 128,		// Marine armor 2
	MASK_ADRENALINE = 128,		// Alien adrenaline
	MASK_BASEBUILD4 = 128,		// Base build slot #4
	MASK_ARMOR3 = 256,		// Marine armor 3
	MASK_SILENCE = 256,		// Alien silence
	MASK_BASEBUILD5 = 256,		// Base build slot #5
	MASK_JETPACK = 512,		// Marine jetpacks
	MASK_CLOAKING = 512,		// Alien cloaking
	MASK_BASEBUILD6 = 512,		// Base build slot #6
	MASK_FOCUS = 1024,		// Alien focus
	MASK_MOTION = 1024,		// Marine motion tracking
	MASK_BASEBUILD7 = 1024,		// Base build slot #7
	MASK_SCENTOFFEAR = 2048,	// Alien scent of fear
	MASK_DEFENSE2 = 4096,		// Defense level 2
	MASK_DEFENSE3 = 8192,		// Defense level 3
	MASK_ELECTRICITY = 8192,	// Electricy
	MASK_MOVEMENT2 = 16384,		// Movement level 2,
	MASK_MOVEMENT3 = 32768,		// Movement level 3
	MASK_HEAVYARMOR = 32768,	// Marine heavy armor
	MASK_SENSORY2 = 65536,		// Sensory level 2
	MASK_SENSORY3 = 131072,		// Sensory level 3
	MASK_ALIEN_MOVEMENT = 262144,	// Onos is charging
	MASK_WALLSTICKING = 524288,	// Flag for wall-sticking
	MASK_PRIMALSCREAM = 1048576,	// Alien is in range of active primal scream
	MASK_UMBRA = 2097152,		// In umbra
	MASK_DIGESTING = 4194304,	// When set on a visible player, player is digesting.  When set on invisible player, player is being digested
	MASK_RECYCLING = 8388608,	// Building is recycling
	MASK_TOPDOWN = 16777216,	// Commander view
	MASK_PLAYER_STUNNED = 33554432,	// Player has been stunned by stomp
	MASK_ENSNARED = 67108864,   	// Webbed
	MASK_ALIEN_EMBRYO = 134217728,  // Gestating
	MASK_SELECTABLE = 268435456,	// ???
	MASK_PARASITED = 536870912,	// Parasite flag
	MASK_SENSORY_NEARBY = 1073741824 // Sensory chamber in range
};


enum {
	CLASS_UNKNOWN = 0,
	CLASS_SKULK,
	CLASS_GORGE,
	CLASS_LERK,
	CLASS_FADE,
	CLASS_ONOS,
	CLASS_MARINE,
	CLASS_JETPACK,
	CLASS_HEAVY,
	CLASS_COMMANDER,
	CLASS_GESTATE,
	CLASS_DEAD,
	CLASS_NOTEAM
};

enum {
	WEAPON_NONE = 0,
	WEAPON_CLAWS,
	WEAPON_SPIT,
	WEAPON_SPORES,
	WEAPON_SPIKE,
	WEAPON_BITE,
	WEAPON_BITE2,
	WEAPON_SWIPE,
	WEAPON_WEBSPINNER,
	WEAPON_METABOLIZE,
	WEAPON_PARASITE,
	WEAPON_BLINK,
	WEAPON_DIVINEWIND,
	WEAPON_KNIFE,
	WEAPON_PISTOL,
	WEAPON_LMG,
	WEAPON_SHOTGUN,
	WEAPON_HMG,
	WEAPON_WELDER,
	WEAPON_MINE,
	WEAPON_GRENADE_GUN,
	WEAPON_LEAP,
	WEAPON_CHARGE,
	WEAPON_UMBRA,
	WEAPON_PRIMALSCREAM,
	WEAPON_BILEBOMB,
	WEAPON_ACIDROCKET,
	WEAPON_HEALINGSPRAY,
	WEAPON_GRENADE,
	WEAPON_STOMP,
	WEAPON_DEVOUR,
	WEAPON_MAX
};

enum {
	HIVETRAIT_NONE	= 0,
	HIVETRAIT_DC	= 92,
	HIVETRAIT_SC	= 93,
	HIVETRAIT_MC	= 94
};

enum NSPS_VelShape
{
	NSPS_VS_POINT = 1,
	NSPS_VS_BOX,
	NSPS_VS_SPHERE,
	NSPS_VS_BLOB
};

/* Genshape used in ns_set_ps_genshape
 * NOTE: The following are in the ns.ps file but
 *       are not listed in the .fgd file.  Use
 *       at your own risk!
 *       Line, Triangle, Plane, Cylinder, 
 *       Cone, Disc, Rectangle and None
 */
enum NSPS_GenShape
{
	NSPS_GS_POINT = 0,
	NSPS_GS_LINE,
	NSPS_GS_TRIANGLE,
	NSPS_GS_PLANE,
	NSPS_GS_BOX,
	NSPS_GS_CYLINDER,
	NSPS_GS_CONE,
	NSPS_GS_BLOB,
	NSPS_GS_DISC,
	NSPS_GS_RECTANGLE,
	NSPS_GS_NONE
};
enum NSPS_RenderMode
{
	NSPS_R_NORMAL = 0,
	NSPS_R_TRANSCOLOR,
	NSPS_R_TRANSTEXTURE,
	NSPS_R_GLOW,
	NSPS_R_TRANSALPHA,
	NSPS_R_ADDITIVE
};
enum NSPS_Flags
{
	NSPS_FL_START_ON = 1,
	NSPS_FL_PARTICLE_DENSITY = 2,
	NSPS_FL_FADE_IN = 4,
	NSPS_FL_FADE_OUT = 8,
	NSPS_FL_USE_GRAVITY = 16,
	NSPS_FL_USE_TRI = 32,
	NSPS_FL_CONSTRAIN_PITCH = 128,
	NSPS_FL_COLLIDE = 256,
	NSPS_FL_HI_DETAIL = 512,
	NSPS_FL_FACE_UP = 1024
};
// vim: set ts=4 sw=4 tw=99 noet:
//
// AMX Mod X, based on AMX Mod by Aleksander Naszko ("OLO").
// Copyright (C) The AMX Mod X Development Team.
//
// This software is licensed under the GNU General Public License, version 3 or higher.
// Additional exceptions apply. For full license details, see LICENSE.txt or visit:
//     https://alliedmods.net/amxmodx-license

//
// NVault Functions
//

#if defined _nvault_included
  #endinput
#endif
#define _nvault_included

#if AMXX_VERSION_NUM >= 175
 #pragma reqlib nvault
 #if !defined AMXMODX_NOAUTOLOAD
  #pragma loadlib nvault
 #endif
#else
 #pragma library nvault
#endif

/* All timestamps are in UNIX epoch form. */

/* Opens a vault by name (such as "myvault")
 * Returns a vault id, INVALID_HANDLE otherwise (-1)
 */
native nvault_open(const name[]);

/* Gets a vault value by returning an int
 * setting a byref float or setting a string + maxlength
 */
native nvault_get(vault, const key[], {Float,_}:...);

/* Looks up a vault value for full information
 * Returns 0 if the entry is not found
 */
native nvault_lookup(vault, const key[], value[], maxlen, &timestamp);

/* Sets a vault value (with current timestamp) */
native nvault_set(vault, const key[], const value[]);

/* Sets a permanent vault value (no timestamp) */
native nvault_pset(vault, const key[], const value[]);

/* Prunes the vault for entries that are within the given timestamps.
 * This will not erase values set with pset
 */
native nvault_prune(vault, start, end);

/* Closes a vault */
native nvault_close(vault);

/* Removes a key from the vault */
native nvault_remove(vault, const key[]);

/* "Touches" a key to update its timestamp value.  
 * If stamp is -1 (default), it will use the current time.
 * Like the unix command "touch," it will create an empty key
 *  if the value does not exist.
 */
native nvault_touch(vault, const key[], timestamp=-1);
// vim: set ts=4 sw=4 tw=99 noet:
//
// AMX Mod X, based on AMX Mod by Aleksander Naszko ("OLO").
// Copyright (C) The AMX Mod X Development Team.
//
// This software is licensed under the GNU General Public License, version 3 or higher.
// Additional exceptions apply. For full license details, see LICENSE.txt or visit:
//     https://alliedmods.net/amxmodx-license

//
// Regular Expressions API
//

#if defined _regex_included
	#endinput
#endif
#define _regex_included

#if AMXX_VERSION_NUM >= 175
	#pragma reqlib regex
	#if !defined AMXMODX_NOAUTOLOAD
		#pragma loadlib regex
	#endif
#else
	#pragma library regex
#endif


enum Regex
{
	REGEX_MATCH_FAIL   = -2,
	REGEX_PATTERN_FAIL = -1,
	REGEX_NO_MATCH     =  0,
	REGEX_OK           =  1
};

/**
 * Flags for compiling regex expressions.
 * These come directly from the pcre library and can be used in regex_compile_ex.
 */
#define PCRE_CASELESS           0x00000001  /* Ignore Case */
#define PCRE_MULTILINE          0x00000002  /* Multilines (affects ^ and $ so that they match the start/end of a line rather than matching the start/end of the string). */
#define PCRE_DOTALL             0x00000004  /* Single line (affects . so that it matches any character, even new line characters). */
#define PCRE_EXTENDED           0x00000008  /* Pattern extension (ignore whitespace and # comments). */
#define PCRE_ANCHORED           0x00000010  /* Force pattern anchoring. */
#define PCRE_DOLLAR_ENDONLY     0x00000020  /* $ not to match newline at end. */
#define PCRE_UNGREEDY           0x00000200  /* Invert greediness of quantifiers */
#define PCRE_NOTEMPTY           0x00000400  /* An empty string is not a valid match. */
#define PCRE_UTF8               0x00000800  /* Use UTF-8 Chars */
#define PCRE_NO_UTF8_CHECK      0x00002000  /* Do not check the pattern for UTF-8 validity (only relevant if PCRE_UTF8 is set) */
#define PCRE_NEVER_UTF          0x00010000  /* Lock out interpretation of the pattern as UTF-8 */
#define PCRE_FIRSTLINE          0x00040000  /* Force matching to be before newline */
#define PCRE_DUPNAMES           0x00080000  /* Allow duplicate names for subpattern */
#define PCRE_NEWLINE_CR         0x00100000  /* Specify that a newline is indicated by a single character CR           )                            */
#define PCRE_NEWLINE_CRLF       0x00300000  /* specify that a newline is indicated by the two-character CRLF sequence )  Overrides the default     */
#define PCRE_NEWLINE_ANY        0x00400000  /* Specify that any Unicode newline sequence should be recognized.        )  newline definition (LF)   */
#define PCRE_NEWLINE_ANYCRLF    0x00500000  /* Specify that any of CR, LF and CRLF sequences should be recognized     )                            */
#define PCRE_UCP                0x20000000  /* Change the way PCRE processes \B, \b, \D, \d, \S, \s, \W, \w etc. to use Unicode properties */

/**
 * Regex expression error codes.
 * This can be used with regex_compile_ex and regex_match_ex.
 */
enum /*RegexError*/
{
	REGEX_ERROR_NONE           =  0,    /* No error */
	REGEX_ERROR_NOMATCH        = -1,    /* No match was found */
	REGEX_ERROR_NULL           = -2,
	REGEX_ERROR_BADOPTION      = -3,
	REGEX_ERROR_BADMAGIC       = -4,
	REGEX_ERROR_UNKNOWN_OPCODE = -5,
	REGEX_ERROR_NOMEMORY       = -6,
	REGEX_ERROR_NOSUBSTRING    = -7,
	REGEX_ERROR_MATCHLIMIT     = -8,
	REGEX_ERROR_CALLOUT        = -9,    /* Never used by PCRE itself */
	REGEX_ERROR_BADUTF8        = -10,
	REGEX_ERROR_BADUTF8_OFFSET = -11,
	REGEX_ERROR_PARTIAL        = -12,
	REGEX_ERROR_BADPARTIAL     = -13,
	REGEX_ERROR_INTERNAL       = -14,
	REGEX_ERROR_BADCOUNT       = -15,
	REGEX_ERROR_DFA_UITEM      = -16,
	REGEX_ERROR_DFA_UCOND      = -17,
	REGEX_ERROR_DFA_UMLIMIT    = -18,
	REGEX_ERROR_DFA_WSSIZE     = -19,
	REGEX_ERROR_DFA_RECURSE    = -20,
	REGEX_ERROR_RECURSIONLIMIT = -21,
	REGEX_ERROR_NULLWSLIMIT    = -22,   /* No longer actually used */
	REGEX_ERROR_BADNEWLINE     = -23,
	REGEX_ERROR_BADOFFSET      = -24,
	REGEX_ERROR_SHORTUTF8      = -25,
	REGEX_ERROR_RECURSELOOP    = -26,
	REGEX_ERROR_JIT_STACKLIMIT = -27,
	REGEX_ERROR_BADMODE        = -28,
	REGEX_ERROR_BADENDIANNESS  = -29,
	REGEX_ERROR_DFA_BADRESTART = -30,
	REGEX_ERROR_JIT_BADOPTION  = -31,
	REGEX_ERROR_BADLENGTH      = -32,
	REGEX_ERROR_UNSET          = -33
};

/**
 * Precompile a regular expression.
 *
 * @note  Use this if you intend on using the same expression multiple times.
 *        Pass the regex handle returned here to regex_match_c to check for matches.
 *
 * @note  This handle is automatically freed on map change.  However,
 *        if you are completely done with it before then, you should
 *        call regex_free on this handle.
 *
 * @note  Consider using regex_compile_ex instead if you want to use PCRE_* flags.
 *
 * @param pattern       The regular expression pattern.
 * @param ret           Error code encountered, if applicable.
 * @param error         Error message encountered, if applicable.
 * @param maxLen        Maximum string length of the error buffer.
 * @param flags         General flags for the regular expression.
 *                      i = Ignore case
 *                      m = Multilines (affects ^ and $ so that they match
 *                          the start/end of a line rather than matching the
 *                          start/end of the string).
 *                      s = Single line (affects . so that it matches any character,
 *                          even new line characters).
 *                      x = Pattern extension (ignore whitespace and # comments).
 *
 * @return              -1 on error in the pattern, > valid regex handle (> 0) on success.
 */
native Regex:regex_compile(const pattern[], &ret = 0, error[] = "", maxLen = 0, const flags[]="");

/**
 * Matches a string against a pre-compiled regular expression pattern.
 *
 * @note  You should free the returned handle with regex_free()
 *        when you are done with this pattern.
 *
 * @note  Use the regex handle passed to this function to extract
 *        matches with regex_substr().
 *
 * @param string        The string to check.
 * @param pattern       The regular expression pattern.
 * @param ret           Error code, if applicable, or number of results on success. See REGEX_ERROR_* defines.
 *
 * @return              -2 = Matching error (error code is stored in ret)
 *                       0 = No match.
 *                      >1 = Number of results.
 */
native regex_match_c(const string[], Regex:pattern, &ret = 0);

/**
 * Matches a string against a regular expression pattern.
 *
 * @note  If you intend on using the same regular expression pattern
 *        multiple times, consider using regex_compile and regex_match_ex
 *        instead of making this function reparse the expression each time.
 *
 * @note  Flags only exist in amxmodx 1.8 and later.
 *
 * @note  You should free the returned handle with regex_free()
 *        when you are done extracting all of the substrings.
 *
 * @param string        The string to check.
 * @param pattern       The regular expression pattern.
 * @param ret           Error code, or result state of the match.
 * @param error         Error message, if applicable.
 * @param maxLen        Maximum length of the error buffer.
 * @param flags         General flags for the regular expression.
 *                      i = Ignore case
 *                      m = Multilines (affects ^ and $ so that they match
 *                          the start/end of a line rather than matching the
 *                          start/end of the string).
 *                      s = Single line (affects . so that it matches any character,
 *                          even new line characters).
 *                      x = Pattern extension (ignore whitespace and # comments).
 *
 * @return              -2 = Matching error (error code is stored in ret)
 *                      -1 = Error in pattern (error message and offset # in error and ret)
 *                       0 = No match.
 *                      >1 = Handle for getting more information (via regex_substr)
 */
native Regex:regex_match(const string[], const pattern[], &ret = 0, error[] = "", maxLen = 0, const flags[] = "");

/**
 * Returns a matched substring from a regex handle.
 *
 * @note  Substring ids start at 0 and end at ret - 1, where ret is from the corresponding
 *        regex_match* function call.
 *
 * @param id            The regex handle to extract data from.
 * @param str_id        The index of the expression to get - starts at 0, and ends at ret - 1.
 * @param buffer        The buffer to set to the matching substring.
 * @param maxLen        The maximum string length of the buffer.
 *
 * @return              1 on success, otherwise 0 on failure.
 */
native regex_substr(Regex:id, str_id, buffer[], maxLen);

/**
 * Frees the memory associated with a regex result, and sets the handle to 0.
 *
 * @note  This must be called on all results from regex_match() when you are done extracting
 *        the results with regex_substr().
 *
 * @note  The results of regex_compile() or regex_compile_ex() (and subsequently, regex_match_c())
 *        only need to be freed when you are done using the pattern.
 *
 * @note  Do not use the handle again after freeing it!
 *
 * @param id            The regex handle to free.
 * @noreturn
 */
native regex_free(&Regex:id);


/**
 * The following natives are only available in 1.8.3 and above.
 */

/**
 * Precompile a regular expression.
 *
 * @note  Use this if you intend on using the same expression multiple times.
 *        Pass the regex handle returned here to regex_match_c() to check for matches.
 *
 * @note  Unlike regex_compile(), this allows you to use PCRE flags directly.
 *
 * @param pattern       The regular expression pattern.
 * @param flags         General flags for the regular expression, see PCRE_* defines.
 * @param error         Error message encountered, if applicable.
 * @param maxLen        Maximum string length of the error buffer.
 * @param errcode       Regex type error code encountered, if applicable. See REGEX_ERROR_* defines.
 *
 * @return              Valid regex handle (> 0) on success, or -1 on failure.
 */
native Regex:regex_compile_ex(const pattern[], flags = 0, error[]= "", maxLen = 0, &errcode = 0);

/**
 * Matches a string against a pre-compiled regular expression pattern, matching all
 * occurrences of the pattern inside the string. This is similar to using the "g" flag
 * in perl regex.
 *
 * @note  You should free the returned handle (with regex_free())
 *        when you are done with this pattern.
 *
 * @note  Use the regex handle passed to this function to extract
 *        matches with regex_substr().
 *
 * @param pattern       The regular expression pattern.
 * @param string        The string to check.
 * @param ret           Error code, if applicable, or number of results on success.
 *                      See REGEX_ERROR_* defines.
 *
 * @return              -2 = Matching error (error code is stored in ret)
 *                       0 = No match.
 *                      >1 = Number of results.
 */
native regex_match_all_c(const string[], Regex:pattern, &ret = 0);

/**
 * Matches a string against a regular expression pattern, matching all occurrences of the
 * pattern inside the string. This is similar to using the "g" flag in perl regex.
 *
 * @note  If you intend on using the same regular expression pattern
 *        multiple times, consider using regex_compile and regex_match_ex
 *        instead of making this function reparse the expression each time.
 *
 * @note  Flags only exist in amxmodx 1.8 and later.
 *
 * @note  You should free the returned handle with regex_free()
 *        when you are done extracting all of the substrings.
 *
 * @param string        The string to check.
 * @param pattern       The regular expression pattern.
 * @param flags         General flags for the regular expression, see PCRE_* defines.
 * @param error         Error message encountered, if applicable.
 * @param maxLen        Maximum string length of the error buffer.
 * @param errcode       Regex type error code encountered, if applicable. See REGEX_ERROR_* defines.
 *
 * @return              -2 = Matching error (error code is stored in ret)
 *                      -1 = Error in pattern (error message and offset # in error and ret)
 *                       0 = No match.
 *                      >1 = Handle for getting more information (via regex_substr)
 */
native Regex:regex_match_all(const string[], const pattern[], flags = 0, error[]= "", maxLen = 0, &errcode = 0);

/**
 * Matches a string against a regular expression pattern.
 *
 * @note  If you intend on using the same regular expression pattern
 *        multiple times, consider using compile regex_compile_ex and regex_match*
 *        instead of making this function reparse the expression each time.
 *
 * @param str           The string to check.
 * @param pattern       The regular expression pattern.
 * @param flags         General flags for the regular expression.
 * @param error         Error message, if applicable.
 * @param maxLen        Maximum length of the error buffer.
 * @param errcode       Regex type error code encountered, if applicable. See REGEX_ERROR_* defines.
 *
 * @return              -2 = Matching error (error code is stored in ret)
 *                      -1 = Pattern error (error code is stored in ret)
 *                       0 = No match.
 *                      >1 = Number of results.
 */
stock regex_match_simple(const str[], const pattern[], flags = 0, error[]= "", maxLen = 0, &errcode = 0)
{
	new Regex:regex = regex_compile_ex(pattern, flags, error, maxLen, errcode);

	if (regex < 0)
	{
		return -1;
	}

	new substrings = regex_match_c(regex, str);

	regex_free(regex);

	return substrings;
}

/**
 * Flags used with regex_replace to control the replacement behavior.
 */
#define REGEX_FORMAT_DEFAULT   0       /* Uses the standard formatting rules to replace matches */
#define REGEX_FORMAT_NOCOPY    (1<<0)  /* The sections that do not match the regular expression are not copied when replacing matches. */
#define REGEX_FORMAT_FIRSTONLY (1<<1)  /* Only the first occurrence of a regular expression is replaced. */

/**
 * Perform a regular expression search and replace.
 *
 * An optional parameter, flags, allows you to specify options on how the replacement is performed.
 * Supported format specifiers for replace parameter:
 *   $number  : Substitutes the substring matched by group number.
 *              n must be an integer value designating a valid backreference, greater than 0, and of two digits at most.
 *   ${name}  : Substitutes the substring matched by the named group name (a maximum of 32 characters).
 *   $&       : Substitutes a copy of the whole match.
 *   $`       : Substitutes all the text of the input string before the match.
 *   $'       : Substitutes all the text of the input string after the match.
 *   $+       : Substitutes the last group that was captured.
 *   $_       : Substitutes the entire input string.
 *   $$       : Substitutes a literal "$".
 * As note, the character \ can be also used with format specifier, this is same hehavior as $.
 *
 * @param pattern       The regular expression pattern.
 * @param string        The string to check.
 * @param error         Error message, if applicable.
 * @param maxLen        Maximum length of the error buffer.
 * @param replace       The string will be used to replace any matches. See above for format specifiers.
 * @param flags         General flags to control how the string is replaced. See REGEX_FORMAT_* defines.
 * @param errcode       Regex type error code encountered, if applicable. See REGEX_ERROR_* defines.
 *
 * @return              -2 = Matching error (error code is stored in ret)
 *                       0 = No match.
 *                      >1 = Number of matches.
 */
native regex_replace(Regex:pattern, string[], maxLen, const replace[], flags = REGEX_FORMAT_DEFAULT, &errcode = 0);
// vim: set ts=4 sw=4 tw=99 noet:
//
// AMX Mod X, based on AMX Mod by Aleksander Naszko ("OLO").
// Copyright (C) The AMX Mod X Development Team.
//
// Codebase from Ivan, -g-s-ivan@web.de (AMX 0.9.3)
// Modification by Olaf Reusch, kenterfie@hlsw.de (AMXX 0.16, AMX 0.96)
//
// This software is licensed under the GNU General Public License, version 3 or higher.
// Additional exceptions apply. For full license details, see LICENSE.txt or visit:
//     https://alliedmods.net/amxmodx-license

//
// Socket Functions
//

#if defined _socket_included
	#endinput
#endif
#define _socket_included

#if AMXX_VERSION_NUM >= 175
 #pragma reqlib sockets
 #if !defined AMXMODX_NOAUTOLOAD
  #pragma loadlib sockets
 #endif
#else
 #pragma library socket
#endif

// Use SOCKET_TCP for TCP Socket connections

#define SOCKET_TCP 1

// Use SOCKET_UDP for UDP Socket connections

#define SOCKET_UDP 2

/* Opens a new connection to hostname:port via protocol (either SOCKET_TCP or SOCKET_UDP),
 * returns a socket (positive) or negative or zero on error.
 * States of error:
 * 0 - no error
 * 1 - error while creating socket
 * 2 - couldn't resolve hostname
 * 3 - couldn't connect to given hostname:port
*/

native socket_open(const _hostname[], _port, _protocol = SOCKET_TCP, &_error);

/* Closes a Socket */

native socket_close(_socket);

/* Recieves Data to string with the given length */

native socket_recv(_socket, _data[], _length);

/* Sends data to the Socket */

native socket_send(_socket, const _data[], _length);

/* Same as socket_send but Data can contain null bytes */

native socket_send2(_socket, const _data[], _length);

/* This function will return true if the state (buffer content) have changed within the last recieve or
* the timeout, where timeout is a value in ÂµSeconds, (1 sec =1000000 Âµsec).
* Use to check if new data is in your socket. */

native socket_change(_socket, _timeout=100000);
// vim: set ts=4 sw=4 tw=99 noet:
//
// AMX Mod X, based on AMX Mod by Aleksander Naszko ("OLO").
// Copyright (C) The AMX Mod X Development Team.
//
// This software is licensed under the GNU General Public License, version 3 or higher.
// Additional exceptions apply. For full license details, see LICENSE.txt or visit:
//     https://alliedmods.net/amxmodx-license

//
// Sorting Functions
//

//
// All sort functions are based off the qsort() function from the
//  C standard library, which uses the Quick Sort algorithm.
// For more info, see: http://linux.wku.edu/~lamonml/algor/sort/sort.html
//

#if defined _sorting_included
  #endinput
#endif
#define _sorting_included

/**
 * Contains sorting orders.
 */
enum SortMethod
{
	Sort_Ascending = 0,
	Sort_Descending,
	Sort_Random,
};

/**
 * Data types for ADT Array Sorts
 */
enum SortType
{
	Sort_Integer = 0,
	Sort_Float,
 	Sort_String,
};
/**
 * Basic sorting functions below.
 */

native SortIntegers(array[], array_size, SortMethod:order = Sort_Ascending);

native SortFloats(Float:array[], array_size, SortMethod:order = Sort_Ascending);

native SortStrings(array[][], num_strings, SortMethod:order = Sort_Ascending);

/**
 * Custom sorting functions below.
 */

/** 
 * Sorts a custom 1D array.  You must pass in a comparison function.
 * The sorting algorithm then uses your comparison function to sort the data.
 * The function is called in the following manner:
 * 
 * public MySortFunc(elem1, elem2, const array[], const data[], data_size)
 *
 *  elem1, elem2	- Current element pair being compared
 *  array[]			- Array in its current mid-sorted state.
 *  data[]			- Extra data array you passed to the sort func.
 *  data_size		- Size of extra data you passed to the sort func.
 *
 * Your function should return:
 *  -1 if elem1 should go before elem2
 *   0 if elem1 and elem2 are equal
 *   1 if elem1 should go after elem2
 * Note that the parameters after elem2 are all optional and you do not need to specify them.
 */
native SortCustom1D(array[], array_size, const comparefunc[], data[]="", data_size=0);


/** 
 * Sorts a custom 2D array.
 * The sorting algorithm then uses your comparison function to sort the data.
 * The function is called in the following manner:
 *
 * public MySortFunc(const elem1[], const elem2[], const array[], data[], data_size)
 *
 *  elem1[], elem2[] - Current element array pairs being compared
 *  array[][]		 - Array in its currently being sorted state.
 *  data[]			 - Extra data array you passed to the sort func.
 *  data_size		 - Size of extra data you passed to the sort func.
 *
 * Your function should return:
 *  -1 if elem1[] should go before elem2[]
 *   0 if elem1[] and elem2 are equal[]
 *   1 if elem1[] should go after elem2[]
 * Note that the parameters after elem2[] are all optional and you do not need to specify them.
 */
native SortCustom2D(array[][], array_size, const comparefunc[], data[]="", data_size=0);

/**
 * Sort an ADT Array. Specify the type as Integer, Float, or String.
 *
 * @param array			Array Handle to sort
 * @param order			Sort order to use, same as other sorts.
 * @param type			Data type stored in the ADT Array
 * @noreturn
 */
native SortADTArray(Array:array, SortMethod:order, SortType:type);
// vim: set ts=4 sw=4 tw=99 noet:
//
// AMX Mod X, based on AMX Mod by Aleksander Naszko ("OLO").
// Copyright (C) The AMX Mod X Development Team.
//
// This software is licensed under the GNU General Public License, version 3 or higher.
// Additional exceptions apply. For full license details, see LICENSE.txt or visit:
//     https://alliedmods.net/amxmodx-license

//
// SQLX - Newer SQL Database API
//

#if defined _sqlx_included
  #endinput
#endif
#define _sqlx_included

//eh..
#define SQL_NumRows SQL_NumResults

#if AMXX_VERSION_NUM >= 175
 #pragma reqclass sqlx
 #if !defined AMXMODX_NOAUTOLOAD
  #pragma defclasslib sqlx mysql
 #endif //!defined AMXMODX_NOAUTOLOAD
#endif //AMXX_VERSION_NUM

enum Handle
{
   Empty_Handle
};

/**
 * Creates a connection information tuple.
 * This tuple must be passed into connection routines.
 * Freeing the tuple is not necessary, but is a good idea if you 
 *  create many of them.  You can cache these handles globally.
 * !!NOTE!! I have seen most people think that this connects to the DB.
 *   Nowhere does it say this, and in fact it does not.  It only caches
 *   the connection information, the host/user/pass/etc.
 *
 * The optional timeout parameter specifies how long connections should wait before
 * giving up.  If 0, the default (which is undefined) is used.
 *
 */
native Handle:SQL_MakeDbTuple(const host[], const user[], const pass[], const db[], timeout=0);


/**
 * Frees an SQL handle.
 * The handle can be to anything (tuple, connection, query, results, etc).
 * If you free a database connection, it closes the connection as well.
 */
native SQL_FreeHandle(Handle:h);


/**
 * Opens a database connection.
 * Returns an SQL handle, which must be freed.
 * Returns Empty_Handle on failure.
 */
native Handle:SQL_Connect(Handle:cn_tuple, &errcode, error[], maxlength);


/**
 * Sets the character set of the current connection. 
 * Like SET NAMES .. in mysql, but stays after connection problems.
 * 
 * If a connection tuple is supplied, this should be called before SQL_Connect or SQL_ThreadQuery.
 * Also note the change will remain until you call this function with another value.
 * 
 * Example: "utf8", "latin1"
 *
 * @param h					Database or connection tuple Handle.
 * @param charset			The character set string to change to.
 * @return					True, if character set was changed, false otherwise.
 */
native bool:SQL_SetCharset(Handle:h, const charset[]);


/**
 * Prepares a query.
 * The query must always be freed.
 * This does not actually do the query!
 */
native Handle:SQL_PrepareQuery(Handle:db, const fmt[], any:...);


/**
 * Back-quotes characters in a string for database querying.
 * Note: The buffer's maximum size should be 2*strlen(string) to catch
 * all scenarios.
 *
 * @param db				Database handle for localization, or Empty_Handle 
 *                          for when a handle is not available.
 * @param buffer			Buffer to copy to.
 * @param buflen			Maximum size of the buffer.
 * @param string			String to backquote (should not overlap buffer).
 * @return					Length of new string, or -1 on failure.
 */
native SQL_QuoteString(Handle:db, buffer[], buflen, const string[]);

/**
 * Back-quotes characters in a string for database querying.
 * Note: The buffer's maximum size should be 2*strlen(string) to catch
 * all scenarios.
 *
 * @param db				Database handle for localization, or Empty_Handle 
 *                          for when a handle is not available.
 * @param buffer			Buffer to copy to.
 * @param buflen			Maximum size of the buffer.
 * @param fmt				Format of string to backquote (should not overlap buffer).
 * @param ...				Format arguments.
 * @return					Length of new string, or -1 on failure.
 */
native SQL_QuoteStringFmt(Handle:db, buffer[], buflen, const fmt[], any:...);


#define TQUERY_CONNECT_FAILED	-2
#define TQUERY_QUERY_FAILED	-1
#define TQUERY_SUCCESS		0
/**
 * Prepares and executes a threaded query.
 * This will not interrupt gameplay in the event of a poor/lossed 
 *  connection, however, the interface is more complicated and 
 *  asynchronous.  Furthermore, a new connection/disconnection is 
 *  made for each query to simplify driver support.
 * The handler should look like:
 *
 * @param failstate - One of the three TQUERY_ defines.
 * @param query - Handle to the query, do not free it.
 * @param error - An error message, if any.
 * @param errnum - An error code, if any.
 * @param data - Data array you passed in.
 * @param size - Size of the data array you passed in.
 * @param queuetime - Amount of gametime that passed while the query was resolving.
 * 
 * public QueryHandler(failstate, Handle:query, error[], errnum, data[], size, Float:queuetime)
 *
 * Note! The handle you pass in is a DB Tuple, NOT an active connection!
 * Note! The handle does not need to be freed.
 * Also note: This function is not guaranteed to be in another thread
 *  (in fact - it's not).  You're seeing data "after the fact", 
 *  and as such to execute another query you should run 
 *  SQL_ThreadQuery again with new data.
 */
native SQL_ThreadQuery(Handle:db_tuple, const handler[], const query[], const data[]="", dataSize=0);


/**
 * Executes a query.
 * Returns 1 if the query succeeded.
 * Returns 0 if the query failed.
 * NOTE: You can call this multiple times as long as its parent
 *  connection is kept open.  Each time the result set will be freed
 *  from the previous call.
 */
native SQL_Execute(Handle:query);

/**
 * Gets information about a failed query error.
 * Returns the errorcode.
 */
native SQL_QueryError(Handle:query, error[], maxlength);


/**
 * Returns 1 if there are more results to be read,
 *  0 otherwise.
 */
native SQL_MoreResults(Handle:query);


/**
 * Tells whether a specific column in the current row
 *  is NULL or not.
 */
native SQL_IsNull(Handle:query, column);

/**
 * Retrieves the current result.
 * A successful query starts at the first result,
 *  so you should not call SQL_NextRow() first.
 * Passing no extra params - return int
 * Passing one extra param - return float in 1st extra arg
 * Passing two extra params - return string in 1st arg, max length in 2nd
 * Example:
 *  new num = SQL_ReadResult(query, 0)
 *  new Float:num2
 *  new str[32]
 *  SQL_ReadResult(query, 1, num2)
 *  SQL_ReadResult(query, 2, str, 31)
 */
native SQL_ReadResult(Handle:query, column, {Float,_}:...);


/**
 * Advances to the next result (return value should be ignored).
 */
native SQL_NextRow(Handle:query);


/** 
 * Returns the number of affected rows.
 */
native SQL_AffectedRows(Handle:query);


/**
 * Returns the number of rows total.
 */
native SQL_NumResults(Handle:query);


/**
 * Returns the number of columns total.
 */
native SQL_NumColumns(Handle:query);


/** 
 * Returns the name of a column.
 * Errors on a bad field number.
 */
native SQL_FieldNumToName(Handle:query, num, name[], maxlength);


/**
 * Returns the number of a named column, or -1 if not found.
 */
native SQL_FieldNameToNum(Handle:query, const name[]);


/**
 * Rewinds a result set to the first row.
 */
native SQL_Rewind(Handle:query);


/**
 * Returns the insert id of the last INSERT query. 
 * Returns 0 otherwise.
 */
native SQL_GetInsertId(Handle:query);


/**
 * Returns which driver this plugin is currently bound to.
 */
native SQL_GetAffinity(driver[], maxlen);

/**
 * Sets driver affinity.  You can use this to force a particular 
 *  driver implementation.  This will automatically change all SQL
 *  natives in your plugin to be "bound" to the module in question.
 * If no such module is found, it will return 0.  This isn't necessarily bad - 
 *  the user might have typed the wrong driver.  Unless your plugin is built
 *  to handle different driver types at once, you should let this error pass.
 * Note, that using this while you have open handles to another database 
 *  type will cause problems.  I.e., you cannot open a handle, switch
 *  affinity, then close the handle with a different driver.
 * Switching affinity is an O(n*m) operation, where n is the number of
 *  SQL natives and m is the number of used natives in total.
 * Intuitive programmers will note that this causes problems for threaded queries.
 *  You will have to either force your script to work under one affinity, or to 
 *  pack the affinity type into the query data, check it against the current, then
 *  set the new affinity if necessary.  Then, restore the old for safety.
 */
native SQL_SetAffinity(const driver[]);

/**
 * Returns the original query string that a query handle used.
 */
native SQL_GetQueryString(Handle:query, buffer[], maxlength);

/**
 * For queries which return multiple result sets, this advances to the next 
 * result set if one is available.  Otherwise, the current result set is 
 * destroyed and will no longer be accessible.
 *
 * This function will always return false on SQLite, and when using threaded 
 * queries in MySQL.  Nonetheless, it has the same effect of removing the last 
 * result set.
 *
 * @param query		Query Handle.
 * @return			True on success, false on failure.
 */
native bool:SQL_NextResultSet(Handle:query);

/**
 * This function can be used to find out if a table in a Sqlite database exists.
 * (updated for newer API)
 */
stock bool:sqlite_TableExists(Handle:db, const table[])
{
	new Handle:query = SQL_PrepareQuery(
					db,
					"SELECT name FROM sqlite_master WHERE type='table' AND name='%s' LIMIT 1;", 
					table);
					
	if (!SQL_Execute(query) || !SQL_NumResults(query))
	{
		SQL_FreeHandle(query);
		return false;
	}
	
	SQL_FreeHandle(query);

	return true;
}

/**
 * Use this for executing a query where you don't care about the result.
 * Returns 0 on failure, 1 on success
 */
stock SQL_SimpleQuery(Handle:db, const query[], error[]="", maxlength=0, &rows=0)
{
	new Handle:hQuery = SQL_PrepareQuery(db, "%s", query);
	
	if (!SQL_Execute(hQuery))
	{
		SQL_QueryError(hQuery, error, maxlength);
		SQL_FreeHandle(hQuery);
		return 0;
	}
	
	rows = SQL_NumResults(hQuery);
	
	SQL_FreeHandle(hQuery);
	
	return 1;
}

/**
 * Use this for executing a query where you don't care about the result.
 * Returns 0 on failure, 1 on success
 */
stock SQL_SimpleQueryFmt(Handle:db, error[]="", maxlength=0, &rows=0, const fmt[], any:...)
{
	static query_buf[2048];
	vformat(query_buf, 2047, fmt, 6);
	
	new Handle:hQuery = SQL_PrepareQuery(db, "%s", query_buf);
	
	if (!SQL_Execute(hQuery))
	{
		SQL_QueryError(hQuery, error, maxlength);
		SQL_FreeHandle(hQuery);
		return 0;
	}
	
	rows = SQL_NumResults(hQuery);
	
	SQL_FreeHandle(hQuery);
	
	return 1;
}

/**
 * Use this for executing a query and not caring about the error.
 * Returns -1 on error, >=0 on success (with number of affected rows)
 */
stock SQL_QueryAndIgnore(Handle:db, const queryfmt[], any:...)
{
	static query[4096];
	new Handle:hQuery;
	new ret;
	
	vformat(query, sizeof(query)-1, queryfmt, 3);
	
	hQuery = SQL_PrepareQuery(db, "%s", query);
	
	if (SQL_Execute(hQuery))
	{
		ret = SQL_AffectedRows(hQuery);
	} else {
		ret = -1;
	}
	
	SQL_FreeHandle(hQuery);
	
	return ret;
}

stock Handle:SQL_MakeStdTuple(timeout = 0)
{
	static host[64], user[32], pass[32], db[128];
	static get_type[12], set_type[12];
	
	get_cvar_string("amx_sql_host", host, 63);
	get_cvar_string("amx_sql_user", user, 31);
	get_cvar_string("amx_sql_pass", pass, 31);
	get_cvar_string("amx_sql_type", set_type, 11);
	get_cvar_string("amx_sql_db", db, 127);
	
	SQL_GetAffinity(get_type, 12);
	
	if (!equali(get_type, set_type))
	{
		if (!SQL_SetAffinity(set_type))
		{
			log_amx("Failed to set affinity from %s to %s.", get_type, set_type);
		}
	}
	
	return SQL_MakeDbTuple(host, user, pass, db, timeout);
}
// vim: set ts=4 sw=4 tw=99 noet:
//
// AMX Mod X, based on AMX Mod by Aleksander Naszko ("OLO").
// Copyright (C) The AMX Mod X Development Team.
//
// This software is licensed under the GNU General Public License, version 3 or higher.
// Additional exceptions apply. For full license details, see LICENSE.txt or visit:
//     https://alliedmods.net/amxmodx-license

//
// String Manipulation
//

#if defined _string_included
  #endinput
#endif
#define _string_included

#define charsmax(%1) (sizeof(%1)-1)

/**
 * @global 	Unless otherwise noted, all string functions which take in a 
 *			writable buffer and maximum length should NOT have the null terminator INCLUDED
 * 			in the length.  This means that this is valid: 
 * 			copy(string, charsmax(string), ...)
 */
 
/**
 * Calculates the length of a string.
 *
 * @param string		String to check.
 * @return				Number of valid character bytes in the string.
 */
native strlen(const string[]);

/**
 * Tests whether a string is found inside another string.
 *
 * @param source		String to search in.
 * @param string		Substring to find inside the original string.
 *
 * @return				-1 on failure (no match found). Any other value
 *						indicates a position in the string where the match starts.
 */
native contain(const source[], const string[]);

/**
 * Tests whether a string is found inside another string with case ignoring.
 *
 * @param source		String to search in.
 * @param string		Substring to find inside the original string.
 *
 * @return				-1 on failure (no match found). Any other value
 *						indicates a position in the string where the match starts.
 */
native containi(const source[],const string[]);

/**
 * Given a string, replaces the first occurrence of a search string with a 
 * replacement string.
 *
 * @param text			String to perform search and replacements on.
 * @param len			Maximum length of the string buffer.
 * @param what			String to search for.
 * @param with			String to replace the search string with.
 *
 * @return				The new string length after replacement, or 0 if no replacements were made.
 */
native replace(text[], len, const what[], const with[]);

/**
 * Given a string, replaces all occurrences of a search string with a 
 * replacement string.
 *
 * @note Similar to replace_all() stock, but implemented as native and 
 *       with different algorithm. This native doesn't error on bad 
 *       buffer size and will smartly cut off the string in a way 
 *       that pushes old data out.
 *	
 * @note Only available in 1.8.3 and above.
 *
 * @param text			String to perform search and replacements on.
 * @param maxlength		Maximum length of the string buffer.
 * @param search		String to search for.
 * @param replace		String to replace the search string with.
 * @param caseSensitive	If true (default), search is case sensitive.
 *
 * @return				Number of replacements that were performed.
 */
native replace_string(text[], maxlength, const search[], const replace[], bool:caseSensitive=true);

/**
 * Given a string, replaces the first occurrence of a search string with a 
 * replacement string.
 *
 * @note Similar to replace() native, but implemented with more options and 
 *       with different algorithm. This native doesn't error on bad 
 *       buffer size and will smartly cut off the string in a way 
 *       that pushes old data out.
 *	
 * @note Only available in 1.8.3 and above.
 *
 * @param text			String to perform search and replacements on.
 * @param maxlength		Maximum length of the string buffer.
 * @param search		String to search for.
 * @param replace		String to replace the search string with.
 * @param searchLen		If higher than -1, its value will be used instead of
 *						a strlen() call on the search parameter.
 * @param replaceLen	If higher than -1, its value will be used instead of
 *						a strlen() call on the replace parameter.
 * @param caseSensitive	If true (default), search is case sensitive.
 *
 * @return				Index into the buffer (relative to the start) from where
 *						the last replacement ended, or -1 if no replacements were
 *						made.
 */
native replace_stringex(text[], maxlength, const search[], const replace[], searchLen=-1, replaceLen=-1, bool:caseSensitive=true);

/**
 * Concatenates one string onto another.
 *
 * @param dest			String to append to.
 * @param len			Maximum length of entire buffer.
 * @param src			Source string to concatenate.
 * @param max			Number of characters to add.
 *
 * @return				Number of of all merged characters.
 */
native add(dest[],len,const src[],max=0);

/**
 * Formats a string according to the AMX Mod X format rules (see documentation).
 *
 * @note Example: format(dest, "Hello %s. You are %d years old", "Tom", 17).
 *       If any of your input buffers overlap with the destination buffer,
 *       format() falls back to a "copy-back" version as of 1.65.  This is 
 *       slower, so you should using a source string that is the same as
 *       the destination.
 *
 * @param output		Destination string buffer.
 * @param len			Maximum length of output string buffer.
 * @param format		Formatting rules.
 * @param ...			Variable number of format parameters.
 *
 * @return				Number of cells written.
 */
native format(output[], len, const format[], any:...);

/**
 * Formats a string according to the AMX Mod X format rules (see documentation).
 *
 * @note Same as format(), except does not perform a "copy back" check.
 *       This means formatex() is faster, but DOES NOT ALLOW this type
 *       of call:
 *         formatex(buffer, len, "%s", buffer)
 *         formatex(buffer, len, buffer, buffer)
 *         formatex(buffer, len, "%s", buffer[5])
 *       This is because the output is directly stored into "buffer", 
 *       rather than copied back at the end.
 *
 * @param output		Destination string buffer.
 * @param len			Maximum length of output string buffer.
 * @param format		Formatting rules.
 * @param ...			Variable number of format parameters.
 *
 * @return				Number of cells written.
 */
native formatex(output[], len, const format[], any:...);

/**
 * Formats a string according to the AMX Mod X format rules (see documentation).
 *
 * @note This is the same as format(), except it grabs parameters from a 
 *       parent parameter stack, rather than a local.  This is useful for 
 *       implementing your own variable argument functions.
 *
 * @note Replacement for format_args.  Much faster and %L compatible.
 *       This works exactly like vsnprintf() from C.
 *       You must pass in the output buffer and its size,
 *        the string to format, and the number of the FIRST variable
 *        argument parameter.  For example, for:
 *        function (a, b, c, ...)
 *        You would pass 4 (a is 1, b is 2, c is 3, et cetera).
 *       There is no vformatex().
 *
 * @param buffer		Destination string buffer.
 * @param len			Maximum length of output string buffer.
 * @param fmt			Formatting rules.
 * @param vararg		Argument number which contains the '...' symbol.
 *						Note: Arguments start at 1.
 * @return 				Number of bytes written.
 */
native vformat(buffer[], len, const fmt[], vararg);

/**
 * Formats a string according to the AMX Mod X format rules (see documentation).
 *
 * @note Same as vformat(), except works in normal style dynamic natives.
 *       Instead of passing the format arg string, you can only pass the 
 *       actual format argument number itself.
 *       If you pass 0, it will read the format string from an optional 
 *       fifth parameter.
 *
 * @param buffer		Destination string buffer.
 * @param len			Maximum length of output string buffer.
 * @param fmt_arg		Argument number which contains the format.
 * @param vararg		Argument number which contains the '...' symbol.
 *						Note: Arguments start at 1.
 * @return 				Number of bytes written.
 */
native vdformat(buffer[], len, fmt_arg, vararg, ...);

/**
 * Gets parameters from function as formated string. 
 *
 * @param output		Destination string buffer.
 * @param len			Maximum length of output string buffer.
 * @param pos			Argument number which contains the '...' symbol.
 *
 * @return				Number of bytes written.
 */
native format_args(output[], len, pos = 0);

/**
 * Converts an integer to a string.
 *
 * @param num			Integer to convert.
 * @param string		Buffer to store string in.
 * @param len			Maximum length of string buffer.
 *
 * @return				Number of cells written to buffer.
 */
native num_to_str(num,string[],len);

/**
 * Converts a string to an integer.
 *
 * @param string		String to convert.
 * @return				Integer conversion of string, or 0 on failure.
 */
native str_to_num(const string[]);

/**
 * Parses the 'string' interpreting its content as an integral number of the specified 'base', 
 * which is returned as integer value. The function also sets the value of 'endPos' to point 
 * to the position of the first character after the number.
 * 
 * This is the same as C++ strtol function with a difference on second param.
 * 
 * The function first discards as many whitespace characters as necessary until the first 
 * non-whitespace character is found. Then, starting from this character, takes as many 
 * characters as possible that are valid following a syntax that depends on the 'base' parameter,
 * and interprets them as a numerical value. Finally, a position of the first character following
 * the integer representation in 'string' is stored in 'endPos'.
 * 
 * If the value of 'base' is zero, the syntax expected is similar to that of integer constants, 
 * which is formed by a succession of :
 *    An optional sign character (+ or -)
 *    An optional prefix indicating octal or hexadecimal base ("0" or "0x"/"0X" respectively)
 *    A sequence of decimal digits (if no base prefix was specified) or either octal or hexadecimal digits if a specific prefix is present
 *
 * If the 'base' value is between 2 and 36, the format expected for the integral number is a succession 
 * of any of the valid digits and/or letters needed to represent integers of the specified radix 
 * (starting from '0' and up to 'z'/'Z' for radix 36). The sequence may optionally be preceded by 
 * a sign (either + or -) and, if base is 16, an optional "0x" or "0X" prefix.
 *
 * If the first sequence of non-whitespace characters in 'string' is not a valid integral number
 * as defined above, or if no such sequence exists because either 'string' is empty or it contains
 * only whitespace characters, no conversion is performed.
 *
 * @param string    The string to parse.
 * @param endPos    The position of the first character following the number.
 *                  On success and when containing only numbers, position is at the end of string, meaning equal to 'string' length.
 *                  On failure, position is sets always to 0.
 * @param base      The numerical base (radix) that determines the valid characters and their interpretation.
 *                  If this is 0, the base used is determined by the format in the sequence.
 * @return          On success, the function returns the converted integral number as integer value.
 *                  If no valid conversion could be performed, a zero value is returned.
 *                  If the value read is out of the range of representable values by a cell, 
 *                  the function returns 'cellmin' or 'cellmax'.
 */
native strtol(const string[], &endPos = 0, base = 0);

/**
 * Parses the 'string' interpreting its content as an floating point number and returns its value as a float.
 * The function also sets the value of 'endPos' to point to the position of the first character after the number.
 * 
 * This is the same as C++ strtod function with a difference on second param.
 * 
 * The function first discards as many whitespace characters as necessary until the first 
 * non-whitespace character is found. Then, starting from this character, takes as many 
 * characters as possible that are valid and interprets them as a numerical value. 
 * Finally, a position of the first character following the float representation in 'string' 
 * is stored in 'endPos'.
 * 
 * If the first sequence of non-whitespace characters in 'string' is not a valid float number
 * as defined above, or if no such sequence exists because either 'string' is empty or it contains
 * only whitespace characters, no conversion is performed.
 *
 * @param string    The string to parse.
 * @param endPos    The position of the first character following the number.
 *                  On success and when containing only numbers, position is at the end of string, meaning equal to 'string' length.
 *                  On failure, position is sets always to 0.
 * @return          On success, the function returns the converted floating point number as float value.
 *                  If no valid conversion could be performed, a zero value is returned.
 */
native Float:strtof(const string[], &endPos = 0);

/**
 * Converts a floating point number to a string.
 *
 * @param fl			Floating point number to convert.
 * @param string		Buffer to store string in.
 * @param len			Maximum length of string buffer.
 *
 * @return				Number of cells written to buffer.
 */
native float_to_str(Float:fl, string[], len);

/** 
 * Converts a string to a floating point number.
 *
 * @param string		String to convert to a foat.
 * @return				Floating point result, or 0.0 on error.
 */
native Float:str_to_float(const string[]);

/**
 * Returns whether two strings are equal.
 *
 * @param a				First string (left).
 * @param b				Second string (right).
 * @param c				Number of characters to compare.
 *
 * @return				True if equal, false otherwise.
 */
native equal(const a[],const b[],c=0);

/**
 * Returns whether two strings are equal with case ignoring.
 *
 * @param a				First string (left).
 * @param b				Second string (right).
 * @param c				Number of characters to compare.
 *
 * @return				True if equal, false otherwise.
 */
native equali(const a[],const b[],c=0);

/**
 * Copies one string to another string.
 *
 * @note If the destination buffer is too small to hold the source string, the 
 *       destination will be truncated.
 *
 * @param dest			Destination string buffer to copy to.
 * @param len			Destination buffer length.
 * @param src			Source string buffer to copy from.
 *
 * @return				Number of cells written.
 */
native copy(dest[],len,const src[]);

/**
 * Copies one string to another string until ch is found.
 *
 * @param dest			Destination string buffer to copy to.
 * @param len			Destination buffer length.
 * @param src			Source string buffer to copy from.
 * @param ch			Character to search for.
 *
 * @return				Number of cells written.
 */
native copyc(dest[],len,const src[],ch);

/**
 * Sets string with given character.
 *
 * @param src			Destination string buffer to copy to.
 * @param len			Destination buffer length.
 * @param ch			Character to set string.
 *
 * @noreturn
 */
native setc(src[],len,ch);

/**
 * Gets parameters from text.
 *
 * @note Example: to split text: "^"This is^" the best year",
 *       call function like this: parse(text,arg1,len1,arg2,len2,arg3,len3,arg4,len4)
 *       and you will get: "This is", "the", "best", "year"
 *       Function returns number of parsed parameters.
 *
 * @param text			String to parse.
 * @param ...			Variable number of format parameters.
 *
 * @return				Number of parsed parameters.
 */
native parse(const text[], ... );

/**
 * Breaks a string in two by token.
 *
 * @note Trimming spaces is buggy. Consider strtok2 instead.
 *
 * @note See argbreak() for doing this with parameters.
 *       Example:
 *        str1[] = This *is*some text
 *        strtok(str1, left, 24, right, 24, '*')
 *        left will be "This "
 *        Right will be "is*some text"
 *        If you use trimSpaces, all spaces are trimmed from Left.
 *
 * @param text			String to tokenize
 * @param Left			Buffer to store left half
 * @param leftLen		Size of left buffer
 * @param Right			Buffer to store right half
 * @param rightLen		Size of right buffer
 * @param token			Token to split by
 * @param trimSpaces	Whether spaces are trimmed.
 *
 * @noreturn
 */
native strtok(const text[], Left[], leftLen, Right[], rightLen, token=' ', trimSpaces=0);
   
/**
 * Below are the trim flags for strtok2
 *
 * You can specify how the left and right buffers will
 * be trimmed by strtok2. LTRIM trims spaces from the
 * left side. RTRIM trims from the right side.
 *
 * The defines TRIM_INNER, TRIM_OUTER and TRIM_FULL are
 * shorthands for commonly used flag combinations.
 *
 * When the initial string is trimmed, using TRIM_INNER
 * for all subsequent strtok2 calls will ensure that left
 * and right are always trimmed from both sides.
 *
 * Examples:
 * str1[] = "  This is  *  some text  "
 * strtok2(str1, left, 24, right, 24, '*', TRIM_FULL)
 *  left will be "This is", right will be "some text"
 *
 * str2[] = "  Here is  |  an  | example  "
 * trim(str2)
 * strtok2(str2, left, 24, right, 24, '|', TRIM_INNER)
 *  left will be "Here is", right will be "an  | example"
 * strtok2(right, left, 24, right, 24, '|', TRIM_INNER)
 *  left will be "an", right will be "example"
 *
 * str3[] = "  One  -  more  "
 * strtok2(str3, left, 24, right, 24, '-', TRIM_OUTER)
 *  left will be "One  ", right will be "  more"
 *
 * str4[] = "  Final  .  example  "
 * strtok2(str4, left, 24, right, 24, '.', LTRIM_LEFT|LTRIM_RIGHT)
 *  left will be "Final  ", right will be "example  "
*/
#define LTRIM_LEFT (1<<0)
#define RTRIM_LEFT (1<<1)
#define LTRIM_RIGHT (1<<2)
#define RTRIM_RIGHT (1<<3)

#define TRIM_INNER RTRIM_LEFT|LTRIM_RIGHT
#define TRIM_OUTER LTRIM_LEFT|RTRIM_RIGHT
#define TRIM_FULL TRIM_OUTER|TRIM_INNER

/**
 * Breaks a string in two by token.
 *
 * @note Only available in 1.8.3 and above.
 *
 * @param text			String to tokenize
 * @param left			Buffer to store left half
 * @param llen			Size of left buffer
 * @param right			Buffer to store right half
 * @param rlen			Size of right buffer
 * @param token			Token to split by
 * @param trim			Flags for trimming behavior, see above
 *
 * @return				Returns position of token in string if found, 
 *						-1 if token was not found
 */
native strtok2(const text[], left[], const llen, right[], const rlen, const token = ' ', const trim = 0);

/**
 * Removes whitespace characters from the beginning and end of a string.
 *
 * @param text			The string to trim.
 * @return				Number of bytes written.
 */
native trim(text[]);

/**
 * Converts all chars in string to lower case.
 *
 * @param string		The string to convert.
 * @return				Number of bytes written.
 */
native strtolower(string[]);

/**
 * Converts all chars in string to upper case.
 *
 * @param string		The string to convert.
 * @return				Number of bytes written.
 */
native strtoupper(string[]);

/**
 * Make a string's first character uppercase.
 *
 * @param string		The string to convert.
 * @return				1 on success, otherwise 0.
 */
native ucfirst(string[]);

/**
 * Returns whether a character is numeric.
 *
 * @note Multi-byte characters will always return false.
 *
 * @param ch			Character to test.
 * @return				True if character is numeric, otherwise false.
 */
native isdigit(ch);

/**
 * Returns whether a character is an ASCII alphabet character.
 *
 * @note Multi-byte characters will always return false.
 *
 * @param ch			Character to test.
 * @return				True if character is alphabetical, otherwise false.
 */
native isalpha(ch);

/**
 * Returns whether a character is whitespace.
 *
 * @note Multi-byte characters will always return false.
 *
 * @param ch			Character to test.
 * @return				True if character is whitespace, otherwise false.
 */
native isspace(ch);

/**
 * Returns whether a character is numeric or an ASCII alphabet character.
 *
 * @note Multi-byte characters will always return false.
 *
 * @param ch			Character to test.
 * @return				True if character is numeric, otherwise false.
 */
native isalnum(ch);

/**
 * Returns if a character is multi-byte or not.
 *
 * @note Only available in 1.8.3 and above.
 *
 * @param ch			Character to test.
 * @return				0 for a normal 7-bit ASCII character,
 *						otherwise number of bytes in multi-byte character.
 */
native is_char_mb(ch);

/**
 * Returns whether an alphabetic character is uppercase.
 *
 * @note Only available in 1.8.3 and above.
 * @note Multi-byte characters will always return false.
 *
 * @param ch			Character to test.
 * @return				True if character is uppercase, otherwise false.
 */
native bool:is_char_upper(ch);

/**
 * Returns whether an alphabetic character is lowercase.
 *
 * @note Only available in 1.8.3 and above.
 * @note Multi-byte characters will always return false.
 *
 * @param ch			Character to test.
 * @return				True if character is lowercase, otherwise false.
 */
native bool:is_char_lower(ch);

/**
 * Returns whether a given string contains only digits.
 * This returns false for zero-length strings.
 *
 * @param sString		Character to test.
 * @return				True if string contains only digit, otherwise false.
 */
stock bool:is_str_num(const sString[])
{
	new i = 0;
	
	while (sString[i] && isdigit(sString[i]))
		++i;
	
	return sString[i] == 0 && i != 0;
}

/** 
 * Returns the number of bytes a character is using.  This is
 * for multi-byte characters (UTF-8).  For normal ASCII characters,
 * this will return 1.
 *
 * @note Only available in 1.8.3 and above.
 *
 * @param source		Source input string.
 * @return				Number of bytes the current character uses.
 */
native get_char_bytes(const source[]);

/**
 * Returns an uppercase character to a lowercase character.
 *
 * @note Only available in 1.8.3 and above.
 *
 * @param chr			Characer to convert.
 * @return				Lowercase character on success, 
 *						no change on failure.
 */
stock char_to_upper(chr)
{
	if (is_char_lower(chr))
	{
		return (chr & ~(1<<5));
	}
	return chr;
}

/**
 * Returns a lowercase character to an uppercase character.
 *
 * @note Only available in 1.8.3 and above.
 *
 * @param chr			Characer to convert.
 * @return				Uppercase character on success, 
 *						no change on failure.
 */
stock char_to_lower(chr)
{
	if (is_char_upper(chr))
	{
		return (chr | (1<<5));
	}
	return chr;
}

/**
 * Concatenates one string onto another.
 *
 * @param dest			String to append to.
 * @param source		Source string to concatenate.
 * @param maxlength		Maximum length of entire buffer.
 * @return				Number of bytes written.
 */
native strcat(dest[], const source[], maxlength);

/**
 * Tests whether a string is found inside another string.
 *
 * @param string		String to search in.
 * @param sub			Substring to find inside the original string.
 * @param ignorecase	If true, search is case insensitive.
 *						If false (default), search is case sensitive.
 * @param pos			
 * @return				-1 on failure (no match found). Any other value
 *						indicates a position in the string where the match starts.
 */
native strfind(const string[], const sub[], ignorecase=0, pos=0);

/**
 * Compares two strings lexographically.
 *
 * @param string1		First string (left).
 * @param string2		Second string (right).
 * @param ignorecase	If true, comparison is case insensitive.
 *						If false (default), comparison is case sensitive.
 * @return				-1 if string1 < string2
 *						0 if string1 == string2
 *						1 if string1 > string2
 */
native strcmp(const string1[], const string2[], ignorecase=0);

/**
 * Compares two strings parts lexographically.
 *
 * @note Only available in 1.8.3 and above.
 *
 * @param string1		First string (left).
 * @param string2		Second string (right).
 * @param num			Number of characters to compare.
 * @param ignorecase	If true, comparison is case insensitive.
 *						If false (default), comparison is case sensitive.
 * @return				-1 if string1 < string2
 *						0 if string1 == string2
 *						1 if string1 > string2
 */
native strncmp(const string1[], const string2[], num, bool:ignorecase=false);

/**
 * Backwards compatibility stock - use argbreak or argparse.
 * @deprecated			this function does not work properly.
 */
//#pragma deprecated Use argbreak() instead
stock strbreak(const text[], Left[], leftLen, Right[], rightLen)
{
	return argbreak(text, Left, leftLen, Right, rightLen);
}

/**
 * Parses an argument string to find the first argument. You can use this to
 * replace strbreak().
 *
 * @note Only available in 1.8.3 and above.
 *
 * @note You can use argparse() to break a string into all of its arguments:
 *       new arg[N], pos;
 *       while (true) {
 *         pos = argparse(string, pos, arg, sizeof(arg) - 1);
 *         if (pos == -1)
 *           break;
 *       }
 *
 * @note All initial whitespace is removed. Remaining characters are read until an
 *       argument separator is encountered. A separator is any whitespace not inside
 *       a double-quotation pair (i.e. "x b" is one argument). If only one quotation
 *       mark appears, argparse() acts as if one existed at the end of the string.
 *       Quotation marks are never written back, and do not act as separators. For
 *       example, "a""b""c" will return "abc". An empty quote pair ("") will count
 *       as an argument containing no characters.
 *
 * @note argparse() will write an empty string to argbuffer if no argument is found.
 *
 * @param text          String to tokenize.
 * @param pos           Position to start parsing from.
 * @param argbuffer     Buffer to store first argument.
 * @param maxlen        Size of the buffer.
 * @return              If no argument was found, -1 is returned. Otherwise,
 *                      the index to the next position to parse from is
 *                      returned. This might be the very end of the string.
 */
native argparse(const text[], pos, argbuffer[], maxlen);

/**
 * Emulates strbreak() using argparse().
 *
 * @param text			Source input string.
 * @param left			Buffer to store string left part.
 * @param leftlen		Maximum length of the string part buffer.
 * @param right			Buffer to store string right part.
 * @param rightlen		Maximum length of the string part buffer.
 *
 * @return				-1 if no match was found; otherwise, an index into source
 *						marking the first index after the searched text.  The
 *						index is always relative to the start of the input string.
 */
stock argbreak(const text[], left[], leftlen, right[], rightlen)
{
	new pos = argparse(text, 0, left, leftlen);

	if (pos == -1)
		return -1;

	new textlen = strlen(text);
	while (pos < textlen && isspace(text[pos]))
		pos++;

	copy(right, rightlen, text[pos]);
	return pos;
}

/**
 * Returns text in a string up until a certain character sequence is reached.
 *
 * @note Only available in 1.8.3 and above.
 *
 * @param source		Source input string.
 * @param split			A string which specifies a search point to break at.
 * @param part			Buffer to store string part.
 * @param partLen		Maximum length of the string part buffer.
 *
 * @return				-1 if no match was found; otherwise, an index into source
 *						marking the first index after the searched text.  The
 *						index is always relative to the start of the input string.
 */
native split_string(const source[], const split[], part[], partLen);

/**
 * It is basically strbreak but you have a delimiter that is more than one character in length. By Suicid3.
 *
 * @param szInput		Source input string.
 * @param szLeft		Buffer to store left string part.
 * @param pL_Max		Maximum length of the string part buffer.
 * @param szRight		Buffer to store right string part.
 * @param pR_Max		Maximum length of the string part buffer.
 * @param szDelim		A string which specifies a search point to break at.
 * 
 * @noreturn
 */
stock split(const szInput[], szLeft[], pL_Max, szRight[], pR_Max, const szDelim[])
{
	new iEnd = contain(szInput, szDelim);
	new iStart = iEnd + strlen(szDelim);

	//If delimiter isnt in Input just split the string at max lengths
	if (iEnd == -1)
	{
		iStart = copy(szLeft, pL_Max, szInput);
		copy(szRight, pR_Max, szInput[iStart]);
		return;
	}

	//If delimter is in Input then split at input for max lengths
	if (pL_Max >= iEnd)
		copy(szLeft, iEnd, szInput);
	else
		copy(szLeft, pL_Max, szInput);

	copy(szRight, pR_Max, szInput[iStart]);

	return;
}

/**
 * Removes a path from szFilePath leaving the name of the file in szFile for a pMax length.
 *
 * @param szFilePath	String to perform search and replacements on.
 * @param szFile		Buffer to store file name.
 * @param pMax			Maximum length of the string buffer.
 * 
 * @noreturn
 */
stock remove_filepath(const szFilePath[], szFile[], pMax)
{
	new len = strlen(szFilePath);

	while ((--len >= 0) && (szFilePath[len] != '/') && (szFilePath[len] != '\')) { }

	copy(szFile, pMax, szFilePath[len + 1]);

	return;
}

/**
 * Replaces a contained string iteratively.
 *
 * @note Consider using replace_string() instead.
 *
 * @note This ensures that no infinite replacements will take place by
 *       intelligently moving to the next string position each iteration.
 *
 * @param string	String to perform search and replacements on.
 * @param len		Maximum length of the string buffer.
 * @param what		String to search for.
 * @param with		String to replace the search string with.
 
 * @return			Number of replacements on success, otherwise 0.
 */
stock replace_all(string[], len, const what[], const with[])
{
	new pos = 0;
	
	if ((pos = contain(string, what)) == -1)
	{
		return 0;
	}
	
	new total = 0;
	new with_len = strlen(with);
	new diff = strlen(what) - with_len;
	new total_len = strlen(string);
	new temp_pos = 0;
	
	while (replace(string[pos], len - pos, what, with) != 0)
	{
		total++;

		/* jump to position after replacement */
		pos += with_len;
		
		/* update cached length of string */
		total_len -= diff;
		
		/* will the next call be operating on the last character? */
		if (pos >= total_len)
		{
			break;
		}
		
		/* find the next position from our offset */
		temp_pos = contain(string[pos], what);
		
		/* if it's invalid, we're done */
		if (temp_pos == -1)
		{
			break;
		}
		
		/* otherwise, reposition and update counters */
		pos += temp_pos;
	}
	
	return total;
}

/**
 * Breaks a string into pieces and stores each piece into an array of buffers.
 *
 * @param text				The string to split.
 * @param split				The string to use as a split delimiter.
 * @param buffers			An array of string buffers (2D array).
 * @param maxStrings		Number of string buffers (first dimension size).
 * @param maxStringLength	Maximum length of each string buffer.
 * @param copyRemainder		False (default) discard excess pieces, true to ignore
 *							delimiters after last piece.
 * @return					Number of strings retrieved.
 */
stock explode_string(const text[], const split[], buffers[][], maxStrings, maxStringLength, bool:copyRemainder = false)
{
	new reloc_idx, idx, total;

	if (maxStrings < 1 || !split[0])
	{
		return 0;
	}

	while ((idx = split_string(text[reloc_idx], split, buffers[total], maxStringLength)) != -1)
	{
		reloc_idx += idx;
		if (++total == maxStrings)
		{
			if (copyRemainder)
			{
				copy(buffers[total-1], maxStringLength, text[reloc_idx-idx]);
			}
			return total;
		}
	}

	copy(buffers[total++], maxStringLength, text[reloc_idx]);

	return total;
}

/**
 * Joins an array of strings into one string, with a "join" string inserted in
 * between each given string.  This function complements ExplodeString.
 *
 * @param strings		An array of strings.
 * @param numStrings	Number of strings in the array.
 * @param join			The join string to insert between each string.
 * @param buffer		Output buffer to write the joined string to.
 * @param maxLength		Maximum length of the output buffer.
 * @return				Number of bytes written to the output buffer.
 */
stock implode_strings(const strings[][], numStrings, const join[], buffer[], maxLength)
{
	new total, length, part_length;
	new join_length = strlen(join);
	for (new i=0; i<numStrings; i++)
	{
		length = copy(buffer[total], maxLength-total, strings[i]);
		total += length;
		if (length < part_length)
		{
			break;
		}
		if (i != numStrings - 1)
		{
			length = copy(buffer[total], maxLength-total, join);
			total += length;
			if (length < join_length)
			{
				break;
			}
		}
	}
	return total;
}
// vim: set ts=4 sw=4 tw=99 noet:
//
// AMX Mod X, based on AMX Mod by Aleksander Naszko ("OLO").
// Copyright (C) The AMX Mod X Development Team.
//
// This software is licensed under the GNU General Public License, version 3 or higher.
// Additional exceptions apply. For full license details, see LICENSE.txt or visit:
//     https://alliedmods.net/amxmodx-license

//
// INI Parser Functions
//

#if defined _textparse_ini_included
	#endinput
#endif
#define _textparse_ini_included

/**
 * This parser API is entirely event based.  
 * You must hook events to receive data.
 */
 
/**
 * The INI file format is defined as:
 *    WHITESPACE: 0x20, \n, \t, \r
 *    IDENTIFIER: A-Z a-z 0-9 _ - , + . $ ? / 
 *    STRING    : Any set of symbols
 * 
 * Basic syntax is comprised of SECTIONs.
 *    A SECTION is defined as:
 *    [SECTIONNAME]
 *    OPTION
 *    OPTION
 *    OPTION...
 *
 * SECTIONNAME is an IDENTIFIER.
 *    OPTION can be repeated any number of times, once per line.
 *    OPTION is defined as one of:
 *      KEY = "VALUE"
 *      KEY = VALUE
 *      KEY
 *    Where KEY is an IDENTIFIER and VALUE is a STRING.
 * 
 * WHITESPACE should always be omitted.
 *    COMMENTS should be stripped, and are defined as text occurring in:
 *    ;<TEXT>
 * 
 * Example file below.  Note that the second line is technically invalid.  
 * The event handler must decide whether this should be allowed.
 *    --FILE BELOW--
 *    [gaben]
 *    hi = clams
 *    bye = "NO CLAMS"
 *
 *    [valve]
 *    cannot
 *    maintain
 *    products
 */
  
/**
 * Parser invalid code.
 */
enum INIParser
{
	Invalid_INIParser = 0
};

/**
 * Creates a new INI parser.  
 * This is used to set parse hooks.
 *
 * @return              A new handle to an INI Parse structure.
 */
native INIParser:INI_CreateParser();

/**
 * Disposes of an INI parser.
 *
 * @param handle        Handle to an INI Parse structure.
 *
 * @return              True if disposed, false otherwise.
 */
native INI_DestroyParser(&INIParser:handle);

/**
 * Parses an INI config file.
 *
 * @param handle        A handle to an INI Parse structure.
 * @param file          A string containing the file path.
 * @param line          An optional by reference cell to store the last line number read.
 * @param col           An optional by reference cell to store the last column number read.
 
 * @return              An SMCParseError result.
 * @error               Invalid or corrupt handle. 
 */
native bool:INI_ParseFile(INIParser:handle, const file[], &line = 0, &col = 0);

/**
 * Sets the INI_ParseStart function of a parse handle.
 *
 * @note  Below is the prototype of callback:
 *        -
 *          Called when parsing is started.
 *
 *          @param handle        A handle to an INI Parse structure.
 *
 *          @noreturn
 *
 *          public OnParseStart(INIParser:handle)
 *        -
 * @param handle        Handle to an INI Parse structure.
 * @param func          A ParseStart callback.
 *
 * @noreturn
 * @error               Invalid or corrupt handle. 
 */
native INI_SetParseStart(INIParser:handle, const func[]);

/**
 * Sets the INI_ParseEnd function of a parse handle.
 *
 * @note  Below is the prototype of callback:
 *        -
 *          Called when parsing is halted.
 *
 *          @param handle        A handle to an INI Parse structure.
 *          @param halted        True if abnormally halted, false otherwise.
 *
 *          @noreturn
 *
 *          public OnParseEnd(INIParser:handle, bool:halted)
 *        -
 * @param handle        Handle to an INI Parse structure.
 * @param func          A ParseEnd callback.
 *
 * @noreturn
 * @error               Invalid or corrupt handle. 
 */
native INI_SetParseEnd(INIParser:handle, const func[]);

/**
 * Sets the two main reader functions.
 *
 * @note  Below is the prototype of callback:
 *        -
 *          NewSection: 
 *              Called when the parser finds a new section.
 *
 *              @param handle           Handle to an INI Parse structure.
 *              @param section          Name of section in between the [ and ] characters.
 *              @param invalid_tokens   True if invalid tokens were detected in the name.
 *              @param close_bracket    True if a closing bracket was detected, false otherwise.
 *              @param extra_tokens     True if extra tokens were detected on the line.
 *              @param curtok           Contains current token in the line where the section name starts.
 *                                      You can add to this offset when failing to point to a token.
 *              @return                 True to keep parsing, false otherwise.
 *
 *              public bool:OnNewSection(INIParser:handle, const section[], bool:invalid_tokens, bool:close_bracket, bool:extra_tokens, curtok)
 *
 *          KeyValue: 
 *              Called when the parser finds a new key/value pair.
 *
 *              @param handle           Handle to an INI Parse structure.
 *              @param key              Name of key.
 *              @param value            String containing value (with quotes stripped, if any).
 *              @param invalid_tokens   Whether or not the key contained invalid tokens.
 *              @param equal_token      There was an '=' sign present (in case the value is missing).
 *              @param quotes           Whether value was enclosed in quotes.
 *              @param curtok           Contains the token index of the start of the value string.  
 *                                      This can be changed when returning false.
 *              @return                 True to keep parsing, false otherwise.
 * 
 *              public bool:OnKeyValue(INIParser:handle, const key[], const value[], bool:invalid_tokens, bool:equal_token, bool:quotes, curtok)
 *        -  
 * @param handle        Handle to an INI Parse structure.
 * @param kv            A KeyValue callback. 
 * @param ns            An optional NewSection callback. 
 *
 * @noreturn
 */
native INI_SetReaders(INIParser:smc, const kvFunc[], const nsFunc[] = "" );

/**
 * Sets a raw line reader on an INI parser handle.
 *
 * @note  Below is the prototype of callback:
 *        -
 *          Called whenever a raw line is read.
 *
 *          @param handle       The INI Parse handle.
 *          @param line         Contents of line.
 *          @param lineno       The line number it occurs on.
 *          @param curtok       Pointer to optionally store failed position in string.
 *
 *          @return             True to keep parsing, false otherwise.
 *
 *          public bool:OnRawLine(INIParser:smc, const line[], lineno, curtok)
 *
 * @param handle        Handle to an INI Parse structure.
 * @param func          A RawLine callback.
 *
 * @noreturn
 */
native INI_SetRawLine(INIParser:handle, const func[]);
// vim: set ts=4 sw=4 tw=99 noet:
//
// AMX Mod X, based on AMX Mod by Aleksander Naszko ("OLO").
// Copyright (C) The AMX Mod X Development Team.
//
// This software is licensed under the GNU General Public License, version 3 or higher.
// Additional exceptions apply. For full license details, see LICENSE.txt or visit:
//     https://alliedmods.net/amxmodx-license

//
// SMC Parser Functions
//

#if defined _textparse_smc_included
	#endinput
#endif
#define _textparse_smc_included

/**
 * Everything below describes the SMC Parse, or "SourceMod Configuration" format.
 * This parser is entirely event based.  You must hook events to receive data.
 * The file format itself is nearly identical to Valve's KeyValues format (also known as VDF).
 */

/**
 * The SMC file format is defined as:
 *    WHITESPACE: 0x20, \n, \t, \r
 *    IDENTIFIER: Any ASCII character EXCLUDING ", {, }, ;, //, / *, or WHITESPACE.
 *    STRING    : Any set of symbols enclosed in quotes.
 *
 *    Note: if a STRING does not have quotes, it is parsed as an IDENTIFIER.
 *
 * Basic syntax is comprised of SECTIONBLOCKs.
 *    A SECTIONBLOCK defined as:
 *
 *    SECTIONNAME
 *    {
 *        OPTION
 *    }
 *
 * OPTION can be repeated any number of times inside a SECTIONBLOCK.
 * A new line will terminate an OPTION, but there can be more than one OPTION per line.
 * OPTION is defined any of:
 *    "KEY"  "VALUE"
 *    SECTIONBLOCK
 *
 * SECTIONNAME, KEY, VALUE, and SINGLEKEY are strings
 * SECTIONNAME cannot have trailing characters if quoted, but the quotes can be optionally removed.
 * If SECTIONNAME is not enclosed in quotes, the entire sectionname string is used (minus surrounding whitespace).
 * If KEY is not enclosed in quotes, the key is terminated at first whitespace.
 * If VALUE is not properly enclosed in quotes, the entire value string is used (minus surrounding whitespace).
 * The VALUE may have inner quotes, but the key string may not.
 *
 * For an example, see scripting/testsuite/textparse_test.cfg
 *
 * WHITESPACE should be ignored.
 * Comments are text occurring inside the following tokens, and should be stripped
 * unless they are inside literal strings:
 *    ;<TEXT>
 *    //<TEXT>
 *    / *<TEXT> * /
 */

/**
 * Parser invalid code.
 */
enum SMCParser
{
	Invalid_SMCParser = 0
};

/**
 * Parse result directive.
 */
enum SMCResult
{
	SMCParse_Continue,          /* Continue parsing */
	SMCParse_Halt,              /* Stop parsing here */
	SMCParse_HaltFail           /* Stop parsing and return failure */
};

/**
 * Parse error codes.
 */
enum SMCError
{
	SMCError_Okay = 0,          /* No error */
	SMCError_StreamOpen,        /* Stream failed to open */
	SMCError_StreamError,       /* The stream died... somehow */
	SMCError_Custom,            /* A custom handler threw an error */
	SMCError_InvalidSection1,   /* A section was declared without quotes, and had extra tokens */
	SMCError_InvalidSection2,   /* A section was declared without any header */
	SMCError_InvalidSection3,   /* A section ending was declared with too many unknown tokens */
	SMCError_InvalidSection4,   /* A section ending has no matching beginning */
	SMCError_InvalidSection5,   /* A section beginning has no matching ending */
	SMCError_InvalidTokens,     /* There were too many unidentifiable strings on one line */
	SMCError_TokenOverflow,     /* The token buffer overflowed */
	SMCError_InvalidProperty1,  /* A property was declared outside of any section */
};

/**
 * Creates a new SMC parser.
 * This is used to set parse hooks.
 *
 * @return              A new handle to an SMC Parse structure.
 */
native SMCParser:SMC_CreateParser();

/**
 * Disposes of an SMC parser.
 *
 * @param handle        Handle to an SMC Parse structure.
 *
 * @return              True if disposed, false otherwise.
 */
native SMC_DestroyParser(&SMCParser:handle);

/**
 * Parses a config file.
 *
 * @param handle        A handle to an SMC Parse structure.
 * @param file          A string containing the file path.
 * @param line          An optional by reference cell to store the last line number read.
 * @param col           An optional by reference cell to store the last column number read.
 *
 * @return              An SMCParseError result.
 * @error               Invalid or corrupt handle.
 */
native SMCError:SMC_ParseFile(SMCParser:handle, const file[], &line = 0, &col = 0);

/**
 * Sets the SMC_ParseStart function of a parse handle.
 *
 * @note  Below is the prototype of callback:
 *        -
 *          Called when parsing is started.
 *
 *          @param handle        Handle to an SMC Parse structure.
 *
 *          @noreturn
 *
 *          public OnParseStart(SMCParser:handle)
 *        -
 * @param handle        Handle to an SMC Parse structure.
 * @param func          A ParseStart callback.
 *
 * @noreturn
 * @error               Invalid or corrupt handle.
 */
native SMC_SetParseStart(SMCParser:handle, const func[]);

/**
 * Sets the SMC_ParseEnd function of a parse handle.
 *
 * @note  Below is the prototype of callback:
 *        -
 *          Called when parsing is halted.
 *
 *          @param handle        Handle to an SMC Parse structure.
 *          @param halted        True if abnormally halted, false otherwise.
 *          @param failed        True if parsing failed, false otherwise.
 *
 *          @noreturn
 *
 *          public OnParseEnd(SMCParser:handle, bool:halted, bool:failed)
 *        -
 * @param handle        Handle to an SMC Parse structure.
 * @param func          A ParseEnd callback.
 *
 * @noreturn
 * @error               Invalid or corrupt handle.
 */
native SMC_SetParseEnd(SMCParser:handle, const func[]);

/**
 * Sets the three main reader functions.
 *
 * @note  Enclosing quotes are always stripped.
 * @note  Below is the prototype of callbacks:
 *        -
 *          NewSection:
 *              Called when the parser finds a new section or sub-section.
 *
 *              @param handle           Handle to an SMC Parse structure.
 *              @param name             String containing section name.
 *
 *              @return                 An SMCResult action to take.
 *
 *              public SMCResult:OnNewSection(SMCParser:handle, const name[])
 *
 *          KeyValue:
 *              Called when the parser finds a new key/value pair.
 *
 *              @param handle        Handle to an SMC Parse structure.
 *              @param key           String containing key name.
 *              @param value         String containing value name.
 *
 *              @return              An SMCResult action to take.
 *
 *              public SMCResult:OnKeyValue(SMCParser:handle, const key[], const value[])
 *
 *          EndSection:
 *              Called when the parser finds the end of the current section.
 *
 *              @param handle        Handle to an SMC Parse structure.
 *              
 *              @return              An SMCResult action to take.
 *
 *              public SMCResult:OnEndSection(SMCParser:handle)
 * -
 * @param handle        Handle to an SMC Parse structure.
 * @param kv            A KeyValue callback.
 * @param ns            An optional NewSection callback.
 * @param es            An optional EndSection callback.
 *
 * @noreturn
 */
native SMC_SetReaders(SMCParser:smc, const kvFunc[], const nsFunc[] = "", const esFunc[] = "");

/**
 * Sets a raw line reader on an text parser handle.
 *
 * @note  Below is the prototype of callbacks:
 *        -
 *          Called whenever a raw line is read.
 *
 *          @param handle        Handle to an SMC Parse structure.
 *          @param line          A string containing the raw line from the file.
 *          @param lineno        The line number it occurs on.
 *
 *          @return              An SMCResult action to take.
 *
 *          public SMCResult:SMC_RawLine(SMCParser:handle, const line[], lineno)
 *        -
 * @param handle        Handle to an SMC Parse structure.
 * @param func          A RawLine callback.
 *
 * @noreturn
 */
native SMC_SetRawLine(SMCParser:handle, const func[]);

/**
 * Gets an error string for an SMCError code.
 *
 * @note  SMCError_Okay returns false.
 * @note  SMCError_Custom (which is thrown on SMCParse_HaltFail) returns false.
 *
 * @param error         The SMCParseError code.
 * @param buffer        A string buffer for the error (contents undefined on failure).
 * @param buf_max       The maximum size of the buffer.
 *
 * @return              True on success, false otherwise.
 */
native bool:SMC_GetErrorString(SMCError:error, buffer[], buf_max);
// vim: set ts=4 sw=4 tw=99 noet:
//
// AMX Mod X, based on AMX Mod by Aleksander Naszko ("OLO").
// Copyright (C) The AMX Mod X Development Team.
//
// This software is licensed under the GNU General Public License, version 3 or higher.
// Additional exceptions apply. For full license details, see LICENSE.txt or visit:
//     https://alliedmods.net/amxmodx-license

//
// TFCX Constants
//

#if defined _tfcconst_included
  #endinput
#endif
#define _tfcconst_included


#define TFCMAX_WEAPONS	37

enum {
	TFC_AMMO_SHELLS = 0, 
	TFC_AMMO_BULLETS, 
	TFC_AMMO_CELLS, 
	TFC_AMMO_ROCKETS, 
	TFC_AMMO_NADE1, 
	TFC_AMMO_NADE2, 
};

enum {
	TFC_WPN_NONE = 0,
	TFC_WPN_TIMER,//TFC_WPN_UNK1,
	TFC_WPN_SENTRYGUN,//TFC_WPN_UNK2,
	TFC_WPN_MEDIKIT,
	TFC_WPN_SPANNER,
	TFC_WPN_AXE,
	TFC_WPN_SNIPERRIFLE,
	TFC_WPN_AUTORIFLE,
	TFC_WPN_SHOTGUN,
	TFC_WPN_SUPERSHOTGUN,
	TFC_WPN_NG,
	TFC_WPN_SUPERNG,
	TFC_WPN_GL,
	TFC_WPN_FLAMETHROWER,
	TFC_WPN_RPG,
	TFC_WPN_IC,
	TFC_WPN_FLAMES,//TFC_WPN_UNK16,
	TFC_WPN_AC,
	TFC_WPN_UNK18,
	TFC_WPN_UNK19,
	TFC_WPN_TRANQ,
	TFC_WPN_RAILGUN,
	TFC_WPN_PL,
	TFC_WPN_KNIFE,
	TFC_WPN_CALTROP, // 24
	TFC_WPN_CONCUSSIONGRENADE,
	TFC_WPN_NORMALGRENADE,
	TFC_WPN_NAILGRENADE,
	TFC_WPN_MIRVGRENADE,
	TFC_WPN_NAPALMGRENADE,
	TFC_WPN_GASGRENADE,
	TFC_WPN_EMPGRENADE,
};

enum {
	TFC_PC_SCOUT = 1,
	TFC_PC_SNIPER,
	TFC_PC_SOLDIER,
	TFC_PC_DEMOMAN,
	TFC_PC_MEDIC,
	TFC_PC_HWGUY,
	TFC_PC_PYRO,
	TFC_PC_SPY,
	TFC_PC_ENGENEER,	// Typo; preserved for backward compatibility
	TFC_PC_ENGINEER = 9,
	TFC_PC_CIVILIAN = 11,
};

// Goal items
#define TFC_GOALITEM_BLUE   (1 << 17)
#define TFC_GOALITEM_RED    (1 << 18)
#define TFC_GOALITEM_YELLOW (1 << 24)
#define TFC_GOALITEM_GREEN  (1 << 25)
// vim: set ts=4 sw=4 tw=99 noet:
//
// AMX Mod X, based on AMX Mod by Aleksander Naszko ("OLO").
// Copyright (C) The AMX Mod X Development Team.
//
// This software is licensed under the GNU General Public License, version 3 or higher.
// Additional exceptions apply. For full license details, see LICENSE.txt or visit:
//     https://alliedmods.net/amxmodx-license

//
// TFCX Stats Functions
//

#if defined _tfcstats_included
  #endinput
#endif
#define _tfcstats_included

/* Gets stats from given weapon index. If wpnindex is 0
* then the stats are from all weapons. If weapon has not been used function
* returns 0 in other case 1. Fields in stats are:
* 0 - kills
* 1 - deaths
* 2 - headshots
* 3 - teamkilling
* 4 - shots
* 5 - hits
* 6 - damage
* For body hits fields see amxconst.inc. */
native get_user_wstats(index,wpnindex,stats[8],bodyhits[8]);

/* Gets round stats from given weapon index.*/
native get_user_wrstats(index,wpnindex,stats[8],bodyhits[8]);

/* Gets overall stats which are stored in file on server
* and updated on every respawn or user disconnect.
* Function returns the position in stats by diff. kills to deaths. */
native get_user_stats(index,stats[8],bodyhits[8]);

/* Gets round stats of player. */
native get_user_rstats(index,stats[8],bodyhits[8]);

/* Gets stats with which user have killed/hurt his victim. If victim is 0
* then stats are from all victims. If victim has not been hurt, function
* returns 0 in other case 1. User stats are reset on his respawn. */
native get_user_vstats(index,victim,stats[8],bodyhits[8],wpnname[]="",len=0);

/* Gets stats with which user have been killed/hurt. If killer is 0
* then stats are from all attacks. If killer has not hurt user, function
* returns 0 in other case 1. User stats are reset on his respawn. */
native get_user_astats(index,wpnindex,stats[8],bodyhits[8],wpnname[]="",len=0);

/* Resets life, weapon, victims and attackers user stats. */
native reset_user_wstats(index);

/* Gets overall stats which stored in stats.dat file in amx folder
* and updated on every mapchange or user disconnect.
* Function returns next index of stats entry or 0 if no more exists. */
native get_stats(index,stats[8],bodyhits[8],name[],len);

/* Returns number of all entries in stats. */
native get_statsnum();
// vim: set ts=4 sw=4 tw=99 noet:
//
// AMX Mod X, based on AMX Mod by Aleksander Naszko ("OLO").
// Copyright (C) The AMX Mod X Development Team.
//
// This software is licensed under the GNU General Public License, version 3 or higher.
// Additional exceptions apply. For full license details, see LICENSE.txt or visit:
//     https://alliedmods.net/amxmodx-license

//
// TFCX Functions
//

#if defined _tfcx_included
  #endinput
#endif
#define _tfcx_included

#include <tfcconst>
#include <tfcstats>

#if AMXX_VERSION_NUM >= 175
 #pragma reqclass xstats
 #if !defined AMXMODX_NOAUTOLOAD
  #pragma defclasslib xstats tfcx
 #endif
#else
 #pragma library tfcx
#endif

/************* Shared Natives Start ********************************/

/* Forward types */
enum {
  XMF_DAMAGE = 0,
  XMF_DEATH,
};

/* Use this function to register forwards */
native register_statsfwd( ftype );

/* Function is called after player to player attacks ,
* if players were damaged by teammate TA is set to 1 */
forward client_damage(attacker,victim,damage,wpnindex,hitplace,TA);

/* Function is called after player death ,
* if player was killed by teammate TK is set to 1 */
forward client_death(killer,victim,wpnindex,hitplace,TK);

/* Custom Weapon Support */
/* function will return index of new weapon */
native custom_weapon_add( const wpnname[],melee = 0,const logname[]="" ); 
/* Function will pass damage done by this custom weapon to stats module and other plugins */
native custom_weapon_dmg( weapon, att, vic, damage, hitplace=0 ); 
/* Function will pass info about custom weapon shot to stats module */
native custom_weapon_shot( weapon,index ); // weapon id , player id

/* function will return 1 if true */
native xmod_is_melee_wpn(wpnindex);

/* Returns weapon name. */
native xmod_get_wpnname(wpnindex,name[],len);

/* Returns weapon logname. */
native xmod_get_wpnlogname(wpnindex,name[],len);

/* Returns weapons array size */
native xmod_get_maxweapons();

/* Returns stats array size ex. 8 in TS , 9 in DoD */
native xmod_get_stats_size();

/* Returns 1 if true */
native xmod_is_custom_wpn(wpnindex);

/************* Shared Natives End ********************************/

stock tfc_isgrenade( weapon ){
  switch( weapon )
  {
    case TFC_WPN_CALTROP,
         TFC_WPN_CONCUSSIONGRENADE,
         TFC_WPN_NORMALGRENADE,
         TFC_WPN_NAILGRENADE,
         TFC_WPN_MIRVGRENADE,
         TFC_WPN_NAPALMGRENADE,
         TFC_WPN_GASGRENADE,
         TFC_WPN_EMPGRENADE:
      return 1;
    default: return 0;
  }
  return 0;
}

native tfc_userkill( index );

/* Use this function to set private data offsets if needed 
Default offsets:
	timer: 932
	sentrygun: 83
from AssKicR
	shells: 53
	bullets: 55
	cells: 57
	rockets: 59
	nade1: 14
	nade2: 15
*/
native tfc_setpddata(timer,sentrygun,shells,bullets,cells,rockets,nade1,nade2);

/*********************************************************************/

native 	tfc_setmodel(index, const Model[], const Skin[]);
native 	tfc_clearmodel(index);

/* Get amount of ammo in backpack on a user for a specific weapon */
/* Ammo Types in tfcconst.inc */
native 	tfc_getbammo(index, ammo);

/* Set amount of ammo in backpack on a user for a specific weapon */
native 	tfc_setbammo(index, ammo, value);

/* Returns amount of ammo in weapon's clip (backpack) */
/* Weapons list in tfcconst.inc */
native tfc_getweaponbammo(index, weapon);

/* Sets amount of ammo in weapon's clip (backpack) */
native tfc_setweaponbammo(index, weapon, value);

/* Returns amount of ammo in weapon's clip */
/* Index must be weapon's entity index */
native tfc_getweaponammo(index);

/* Sets amount of ammo in weapon's clip */
/* Index must be weapon's entity index */
native tfc_setweaponammo(index, value);

/* Returns 1 if user is carrying a goal item such as a flag or a keycard, else 0.
 * Team is by reference parameter that will be set to owning team(s) of the goal item.
 * Use the TFC_GOALITEM_* constants to determine the owning team.
 */
native tfc_get_user_goalitem(index, &team);

/* Returns 1 if the player is a spy and is currently feigning death */
native tfc_is_user_feigning(index);

/* Returns 1 if the two teams are allies, 0 otherwise 
 * Note: Team must be 1->4
 *       Team 0 will always return 0
 *       Any other team will result in an error
 */
native tfc_is_team_ally(TeamA,TeamB);
// vim: set ts=4 sw=4 tw=99 noet:
//
// AMX Mod X, based on AMX Mod by Aleksander Naszko ("OLO").
// Copyright (C) The AMX Mod X Development Team.
//
// This software is licensed under the GNU General Public License, version 3 or higher.
// Additional exceptions apply. For full license details, see LICENSE.txt or visit:
//     https://alliedmods.net/amxmodx-license

//
// Time Specific Functions
//

#if defined _time_included
  #endinput
#endif
#define _time_included

/* Time unit types for get_time_length() */
enum 
{
    timeunit_seconds = 0,
    timeunit_minutes,
    timeunit_hours,
    timeunit_days,
    timeunit_weeks,
};

// seconds are in each time unit
#define SECONDS_IN_MINUTE 60
#define SECONDS_IN_HOUR   3600
#define SECONDS_IN_DAY    86400
#define SECONDS_IN_WEEK   604800

/* Stock by Brad */
stock get_time_length(id, unitCnt, type, output[], outputLen)
{
// IMPORTANT: 	You must add register_dictionary("time.txt") in plugin_init()

// id:          The player whose language the length should be translated to (or 0 for server language).
// unitCnt:     The number of time units you want translated into verbose text.
// type:        The type of unit (i.e. seconds, minutes, hours, days, weeks) that you are passing in.
// output:      The variable you want the verbose text to be placed in.
// outputLen:	The length of the output variable.

    if (unitCnt > 0)
    {
        // determine the number of each time unit there are
        new weekCnt = 0, dayCnt = 0, hourCnt = 0, minuteCnt = 0, secondCnt = 0;

        switch (type)
        {
            case timeunit_seconds: secondCnt = unitCnt;
            case timeunit_minutes: secondCnt = unitCnt * SECONDS_IN_MINUTE;
            case timeunit_hours:   secondCnt = unitCnt * SECONDS_IN_HOUR;
            case timeunit_days:    secondCnt = unitCnt * SECONDS_IN_DAY;
            case timeunit_weeks:   secondCnt = unitCnt * SECONDS_IN_WEEK;
        }

        weekCnt = secondCnt / SECONDS_IN_WEEK;
        secondCnt -= (weekCnt * SECONDS_IN_WEEK);

        dayCnt = secondCnt / SECONDS_IN_DAY;
        secondCnt -= (dayCnt * SECONDS_IN_DAY);

        hourCnt = secondCnt / SECONDS_IN_HOUR;
        secondCnt -= (hourCnt * SECONDS_IN_HOUR);

        minuteCnt = secondCnt / SECONDS_IN_MINUTE;
        secondCnt -= (minuteCnt * SECONDS_IN_MINUTE);

        // translate the unit counts into verbose text
        new maxElementIdx = -1;
        new timeElement[5][33];

        if (weekCnt > 0)
            format(timeElement[++maxElementIdx], 32, "%i %L", weekCnt, id, (weekCnt == 1) ? "TIME_ELEMENT_WEEK" : "TIME_ELEMENT_WEEKS");
        if (dayCnt > 0)
            format(timeElement[++maxElementIdx], 32, "%i %L", dayCnt, id, (dayCnt == 1) ? "TIME_ELEMENT_DAY" : "TIME_ELEMENT_DAYS");
        if (hourCnt > 0)
            format(timeElement[++maxElementIdx], 32, "%i %L", hourCnt, id, (hourCnt == 1) ? "TIME_ELEMENT_HOUR" : "TIME_ELEMENT_HOURS");
        if (minuteCnt > 0)
            format(timeElement[++maxElementIdx], 32, "%i %L", minuteCnt, id, (minuteCnt == 1) ? "TIME_ELEMENT_MINUTE" : "TIME_ELEMENT_MINUTES");
        if (secondCnt > 0)
            format(timeElement[++maxElementIdx], 32, "%i %L", secondCnt, id, (secondCnt == 1) ? "TIME_ELEMENT_SECOND" : "TIME_ELEMENT_SECONDS");

        switch(maxElementIdx)
        {
            case 0: format(output, outputLen, "%s", timeElement[0]);
            case 1: format(output, outputLen, "%s %L %s", timeElement[0], id, "TIME_ELEMENT_AND", timeElement[1]);
            case 2: format(output, outputLen, "%s, %s %L %s", timeElement[0], timeElement[1], id, "TIME_ELEMENT_AND", timeElement[2]);
            case 3: format(output, outputLen, "%s, %s, %s %L %s", timeElement[0], timeElement[1], timeElement[2], id, "TIME_ELEMENT_AND", timeElement[3]);
            case 4: format(output, outputLen, "%s, %s, %s, %s %L %s", timeElement[0], timeElement[1], timeElement[2], timeElement[3], id, "TIME_ELEMENT_AND", timeElement[4]);
        }
    }
}
// vim: set ts=4 sw=4 tw=99 noet:
//
// AMX Mod X, based on AMX Mod by Aleksander Naszko ("OLO").
// Copyright (C) The AMX Mod X Development Team.
// Copyright (C) 2005 Suzuka.
//
// This software is licensed under the GNU General Public License, version 3 or higher.
// Additional exceptions apply. For full license details, see LICENSE.txt or visit:
//     https://alliedmods.net/amxmodx-license

//
// TSFUN Constants
//

#if defined _tsconst_included
  #endinput
#endif
#define _tsconst_included

#define TSMAX_WEAPONS 44	// 37 + throwing knife + brekable + 5 custom weapon slots

#define TSPWUP_NONE			0
#define TSPWUP_RANDOM			0
#define TSPWUP_SLOWMO 			1
#define TSPWUP_INFAMMO		 	2
#define TSPWUP_KUNGFU		 	4
#define TSPWUP_SLOWPAUSE 		8
#define TSPWUP_DFIRERATE		16
#define TSPWUP_GRENADE			32
#define TSPWUP_HEALTH			64
#define TSPWUP_ARMOR			128
#define TSPWUP_SUPERJUMP		256

#define TSITEM_KUNGFU			1<<0
#define TSITEM_SUPERJUMP		1<<1

#define TSKF_STUNTKILL			1<<0
#define TSKF_SLIDINGKILL		1<<1
#define TSKF_DOUBLEKILL			1<<2
#define TSKF_ISSPEC			1<<3
#define TSKF_KILLEDSPEC			1<<4

#define TSA_SILENCER			1
#define TSA_LASERSIGHT			2
#define TSA_FLASHLIGHT			4
#define TSA_SCOPE				8

#define TSMSG_NORMAL			6
#define TSMSG_WAITING			11
#define TSMSG_DEAD			1
#define TSMSG_KILLER			2
#define TSMSG_DEMOLITION		3
#define TSMSG_SPECIALIST		4
#define TSMSG_UNSTOPPABLE		5
#define TSMSG_THEONE			10

#define STUNT_NONE 0
#define STUNT_DUCK 1
#define STUNT_ROLL 2
#define STUNT_DIVE 3
#define STUNT_GETUP 4
#define STUNT_FLIP 5

enum {
  TSW_GLOCK18 = 1,
  TSW_UNK1,
  TSW_UZI,
  TSW_M3,
  TSW_M4A1,
  TSW_MP5SD,
  TSW_MP5K,
  TSW_ABERETTAS,
  TSW_MK23,
  TSW_AMK23,
  TSW_USAS,
  TSW_DEAGLE,
  TSW_AK47,
  TSW_57,
  TSW_AUG,
  TSW_AUZI,
  TSW_TMP,
  TSW_M82A1,
  TSW_MP7,
  TSW_SPAS,
  TSW_GCOLTS,
  TSW_GLOCK20,
  TSW_UMP,
  TSW_M61GRENADE,
  TSW_CKNIFE,
  TSW_MOSSBERG,
  TSW_M16A4,
  TSW_MK1,
  TSW_C4,
  TSW_A57,
  TSW_RBULL,
  TSW_M60E3,
  TSW_SAWED_OFF,
  TSW_KATANA,
  TSW_SKNIFE,
  TSW_KUNG_FU,
  TSW_TKNIFE,
};

/* 
valid tsweaponid in TS_GiveWeapon

1: "Glock 18"
3: "Mini Uzi"
4: "Benelli M3"
5: "M4A1"
6: "MP5SD"
7: "MP5K"
8: "Akimbo Berettas"
9: "Socom Mk23"
11: "Usas12"
12: "Desert Eagle"
13: "Ak47"
14: "FiveSeven"
15: "Steyr Aug"
17: "Steyr Tmp"
18: "Barrett M82"
19: "HK Pdw"
20: "Spas12"
21: "Akimbo colts"
22: "Glock 20"
23: "Mac10"
25: "Combat Knife"
26: "Mossberg 500"
27: "M16A4"
28: "Ruger Mk1"
24: "M61 Grenade"
29: "C4"
31: "Raging Bull"
32: "M60"
33: "Sawed off"
34: "Katana"
35: "Seal Knife"

valid pwuptype in TS_GivePwUp

0: "Random"
1: "Slow Motion"
2: "Infinite Clip"
4: "Kung Fu"
8: "Slow Pause"
16: "Double Firerate"
32: "Grenade"
64: "Health"
128: "Armor"
256: "Superjump"

*/


// vim: set ts=4 sw=4 tw=99 noet:
//
// AMX Mod X, based on AMX Mod by Aleksander Naszko ("OLO").
// Copyright (C) The AMX Mod X Development Team.
//
// This software is licensed under the GNU General Public License, version 3 or higher.
// Additional exceptions apply. For full license details, see LICENSE.txt or visit:
//     https://alliedmods.net/amxmodx-license

//
// TSFUN Functions
//

#if defined _tsxfun_included
  #endinput
#endif
#define _tsxfun_included

#include <tsx>
#include <tsconst>

/************* Shared Natives Start ********************************/

/* Forward types */
enum {
  XMF_DAMAGE = 0,
  XMF_DEATH,
};

#if AMXX_VERSION_NUM >= 175
 #pragma reqlib tsfun
 #if !defined AMXMODX_NOAUTOLOAD
  #pragma loadlib tsfun
 #endif
#else
 #pragma library tsfun
#endif

/************* Shared Natives End ********************************/

/* Function is called just before a kung foo attack is done,
 * damage and time length may be altered with natives.
 * Return PLUGIN_HANDLED to stop attack.
 * UNAVAILABLE IN 1.70
 */
forward Melee_Attack(id,Float:time,Float:damage,UNAVAILABLE);


// Returns when someone stunts, after they do it.
//UNAVAILABLE IN 1.70
forward client_stunt(id,stunttype,UNAVAILABLE);

/* Function is called when powerups are ran,
 * Returns value of powerup. Use TSPWUP_*'s
 * to find exactly which one it is. 
 * UNAVAILABLE IN 1.70
 */
forward client_powerup(id,powerup,UNAVAILABLE);

/* weapon logname to weapon name convertion */
native ts_wpnlogtoname(const logname[],name[],len);

/* weapon logname to weapon index convertion */
native ts_wpnlogtoid(const logname[]);

//UNAVAILABLE IN 1.70
//native Float:ts_getusertime( index );		//!
//native ts_setusertime( index, Float:time );	//!

native ts_getusercash( index );
native ts_setusercash( index, money );

native ts_getuserslots( index );
native ts_setuserslots( index, slots );

native ts_getuserstate( index );
native ts_getuserwpn( index,&clip=0,&ammo=0,&mode=0,&extra=0 );
native ts_getuserspace( index );

native ts_getuserkillflags(killer);
native ts_getkillingstreak( index );
native ts_getuserlastfrag( index );

native ts_giveweapon( index,weapon,clips,extra );

native ts_getuserpwup( index );

stock ts_has_slowmo(id) return (ts_getuserpwup(id) &TSPWUP_SLOWMO);
stock ts_has_infammo(id) return (ts_getuserpwup(id) &TSPWUP_INFAMMO);
stock ts_has_slowpause(id) return (ts_getuserpwup(id) &TSPWUP_SLOWPAUSE);
stock ts_has_dfirerate(id) return (ts_getuserpwup(id) &TSPWUP_DFIRERATE);
stock ts_has_grenade(id) return (ts_getuserpwup(id) &TSPWUP_GRENADE);
stock ts_has_health(id) return (ts_getuserpwup(id) &TSPWUP_HEALTH);
stock ts_has_armor(id) return (ts_getuserpwup(id) &TSPWUP_ARMOR);

/* Function will create pwup entity and return its index (pwupent) */
native ts_createpwup( pwup );

native ts_givepwup( index,pwupent );

native ts_setpddata( knifeoffset );

// Alters a fu attack. Use with fu forward
// UNAVAILABLE IN 1.70
// native ts_set_fuattack(id,Float:time,Float:damage);	//!

// Changes board message
native ts_set_message(id,message);

// Gets the message board message
native ts_get_message(id);

stock ts_is_normal(id)
{
	new msg = ts_get_message(id);
	if( (msg > 11) || (msg > 6 && msg < 10) ) return 1;
	return 0;
}
stock ts_is_waiting(id) return (ts_get_message(id) == TSMSG_WAITING);
stock ts_is_dead(id) return (ts_get_message(id) == TSMSG_DEAD);
stock ts_is_killer(id) return (ts_get_message(id) == TSMSG_KILLER);
stock ts_is_demolition(id) return (ts_get_message(id) == TSMSG_DEMOLITION);
stock ts_is_specialist(id) return (ts_get_message(id) == TSMSG_SPECIALIST);
stock ts_is_unstoppable(id) return (ts_get_message(id) == TSMSG_UNSTOPPABLE);
stock ts_is_theone(id) return (ts_get_message(id) == TSMSG_THEONE);

// Return one on true, 0 on false
// UNAVAILABLE IN 1.70
native ts_has_superjump(id);					//!
native ts_has_fupowerup(id);					//!
native ts_is_in_slowmo(id);

// Get and set consecutive frags
//UNAVAILABLE IN 1.70
//native ts_get_cons_frags(id);
//native ts_set_cons_frags(id,num);

// Set to see cool bullet trails. Only id will see them.
native ts_set_bullettrail(id,yesorno);

// Sets fake versions of slow mo and slow pause. Use ts_set_speed for more options.
native ts_set_fakeslowmo(id,Float:time);
native ts_set_fakeslowpause(id,Float:time);

/* Sets speed artificially. 1.0 is default, Go into fractions and decimals for slower
* and put in higher numbers for higher speeds. Aura is how far things around you are effected
* Time is the time until it wears off. 0.0 for speed will freeze people. Do not use negatives. */

native ts_set_speed(id,Float:speed,Float:auradist,Float:time);

/* Sets physics speed artificially. Things like sparks and sounds will be effected.
* Any negative number will render all physics paused. */
native ts_set_physics_speed(id,Float:speed);

// Returns 0 if no powerup is running. Returns the powerup type otherwise.
native ts_is_running_powerup(id);

// Highly experimental command which overrides powerup types.
// Use if a powerup is already running, or if a powerup is not running.
// Safe to use in powerup forward.
native ts_force_run_powerup(id,PWUP_TYPE);
// vim: set ts=4 sw=4 tw=99 noet:
//
// AMX Mod X, based on AMX Mod by Aleksander Naszko ("OLO").
// Copyright (C) The AMX Mod X Development Team.
//
// This software is licensed under the GNU General Public License, version 3 or higher.
// Additional exceptions apply. For full license details, see LICENSE.txt or visit:
//     https://alliedmods.net/amxmodx-license

//
// TSX Stats Functions
//

#if defined _tsstats_included
  #endinput
#endif
#define _tsstats_included

/* Gets stats from given weapon index. If wpnindex is 0
* then the stats are from all weapons. If weapon has not been used function
* returns 0 in other case 1. Fields in stats are:
* 0 - kills
* 1 - deaths
* 2 - headshots
* 3 - teamkilling
* 4 - shots
* 5 - hits
* 6 - damage
* For body hits fields see amxconst.inc. */
native get_user_wstats(index,wpnindex,stats[8],bodyhits[8]);

/* Gets round stats from given weapon index.*/
native get_user_wrstats(index,wpnindex,stats[8],bodyhits[8]);

/* Gets life (from spawn to spawn) stats from given weapon index.*/
native get_user_wlstats(index,wpnindex,stats[8],bodyhits[8]);

/* Gets overall stats which are stored in file on server
* and updated on every respawn or user disconnect.
* Function returns the position in stats by diff. kills to deaths. */
native get_user_stats(index,stats[8],bodyhits[8]);

/* Gets round stats of player. */
native get_user_rstats(index,stats[8],bodyhits[8]);

/* Gets stats with which user have killed/hurt his victim. If victim is 0
* then stats are from all victims. If victim has not been hurt, function
* returns 0 in other case 1. User stats are reset on his respawn. */
native get_user_vstats(index,victim,stats[8],bodyhits[8],wpnname[]="",len=0);

/* Gets stats with which user have been killed/hurt. If killer is 0
* then stats are from all attacks. If killer has not hurt user, function
* returns 0 in other case 1. User stats are reset on his respawn. */
native get_user_astats(index,wpnindex,stats[8],bodyhits[8],wpnname[]="",len=0);

/* Resets life, weapon, victims and attackers user stats. */
native reset_user_wstats(index);

/* Gets overall stats which stored in stats.dat file in amx folder
* and updated on every mapchange or user disconnect.
* Function returns next index of stats entry or 0 if no more exists. */
native get_stats(index,stats[8],bodyhits[8],name[],len);

/* Returns number of all entries in stats. */
native get_statsnum();
// vim: set ts=4 sw=4 tw=99 noet:
//
// AMX Mod X, based on AMX Mod by Aleksander Naszko ("OLO").
// Copyright (C) The AMX Mod X Development Team.
//
// This software is licensed under the GNU General Public License, version 3 or higher.
// Additional exceptions apply. For full license details, see LICENSE.txt or visit:
//     https://alliedmods.net/amxmodx-license

//
// TSX Functions
//

#if defined _tsx_included
  #endinput
#endif
#define _tsx_included

#include <tsstats>

#if AMXX_VERSION_NUM >= 175
 #pragma reqclass xstats
 #if !defined AMXMODX_NOAUTOLOAD
  #pragma defclasslib xstats tsx
 #endif
#else
 #pragma library tsx
#endif

/************* Shared Natives Start ********************************/

/* Forward types */
enum {
  XMF_DAMAGE = 0,
  XMF_DEATH,
};

/* Use this function to register forwards 
 * DEPRECATED
 */
native register_statsfwd( ftype );

/* Function is called after player to player attacks ,
* if players were damaged by teammate TA is set to 1 */
forward client_damage(attacker,victim,damage,wpnindex,hitplace,TA);

/* Function is called after player death ,
* if player was killed by teammate TK is set to 1 */
forward client_death(killer,victim,wpnindex,hitplace,TK);

/* Custom Weapon Support */
/* function will return index of new weapon */
native custom_weapon_add( const wpnname[],melee = 0,const logname[]="" ); 
/* Function will pass damage done by this custom weapon to stats module and other plugins */
native custom_weapon_dmg( weapon, att, vic, damage, hitplace=0 ); 
/* Function will pass info about custom weapon shot to stats module */
native custom_weapon_shot( weapon,index ); // weapon id , player id

/* function will return 1 if true */
native xmod_is_melee_wpn(wpnindex);

/* Returns weapon name. */
native xmod_get_wpnname(wpnindex,name[],len);

/* Returns weapon logname. */
native xmod_get_wpnlogname(wpnindex,name[],len);

/* Returns weapons array size */
native xmod_get_maxweapons();

/* Returns stats array size ex. 8 in TS , 9 in DoD */
native xmod_get_stats_size();

/* Returns 1 if true */
native xmod_is_custom_wpn(wpnindex);

/************* Shared Natives End ********************************/

/* Spawns a Weapon */
stock ts_weaponspawn(const weaponid[], const duration[], const extraclip[], const spawnflags[], const Float:Origin[3])
{
	new ent = create_entity("ts_groundweapon");

	DispatchKeyValue(ent, "tsweaponid", weaponid);
	DispatchKeyValue(ent, "wduration", duration);
	DispatchKeyValue(ent, "wextraclip", extraclip);
	DispatchKeyValue(ent, "spawnflags", spawnflags);
	DispatchSpawn(ent);

	entity_set_origin(ent, Origin);
	return PLUGIN_HANDLED;
}
// vim: set ts=4 sw=4 tw=99 noet:
//
// AMX Mod X, based on AMX Mod by Aleksander Naszko ("OLO").
// Copyright (C) The AMX Mod X Development Team.
//
// This software is licensed under the GNU General Public License, version 3 or higher.
// Additional exceptions apply. For full license details, see LICENSE.txt or visit:
//     https://alliedmods.net/amxmodx-license

//
// Vault Functions
//

#if defined _vault_included
  #endinput
#endif
#define _vault_included

/* Reads a data from given key.
* If len is set to zero then get_vaultdata
* returns value as an number. */
native get_vaultdata(const key[], data[] = "", len = 0);

/* Sets a data under given key. */
native set_vaultdata(const key[], const data[] = "");

/* Removes a key from vault.*/
native remove_vaultdata(const key[]);

/* Checks if a key exists in the vault.*/
native vaultdata_exists(const key[]);
// vim: set ts=4 sw=4 tw=99 noet:
//
// AMX Mod X, based on AMX Mod by Aleksander Naszko ("OLO").
// Copyright (C) The AMX Mod X Development Team.
//
// This software is licensed under the GNU General Public License, version 3 or higher.
// Additional exceptions apply. For full license details, see LICENSE.txt or visit:
//     https://alliedmods.net/amxmodx-license

//
// Vector Functions
//

#if defined _corevector_included
  #endinput
#endif
#define _corevector_included

/* Used for angle_vector() */
#define ANGLEVECTOR_FORWARD      1
#define ANGLEVECTOR_RIGHT        2
#define ANGLEVECTOR_UP           3

/* Returns distance between two vectors. */
native get_distance(const origin1[3], const origin2[3]);

/* Gets distance between two origins (float). */
native Float:get_distance_f(const Float:Origin1[3], const Float:Origin2[3]);

/* Gives you a velocity in the direction a player is looking, iVelocity is the multiplier. */
native velocity_by_aim(iIndex, iVelocity, Float:vRetValue[3]);

/* Changes a vector into an angle vector. */
native vector_to_angle(const Float:fVector[3], Float:vReturn[3]);

/* Changes an angle vector into a vector. */
native angle_vector(const Float:vector[3], FRU, Float:ret[3]);

/* Gets the length of a vector (float[3]). */
native Float:vector_length(const Float:vVector[3]);

/* Gets the distance between 2 vectors (float[3]). */
native Float:vector_distance(const Float:vVector[3], const Float:vVector2[3]);

/* Changes an integer vec to a floating vec
 * This is not a for loop because that's slower
 */
stock IVecFVec(const IVec[3], Float:FVec[3])
{
	FVec[0] = float(IVec[0]);
	FVec[1] = float(IVec[1]);
	FVec[2] = float(IVec[2]);

	return 1;
}

/* Changes a float vec to an integer vec */
stock FVecIVec(const Float:FVec[3], IVec[3])
{
	IVec[0] = floatround(FVec[0]);
	IVec[1] = floatround(FVec[1]);
	IVec[2] = floatround(FVec[2]);
	
	return 1;
}
// vim: set ts=4 sw=4 tw=99 noet:
//
// AMX Mod X, based on AMX Mod by Aleksander Naszko ("OLO").
// Copyright (C) The AMX Mod X Development Team.
// Copyright (C) 2004 Pavol "PM" Marko
//
// This software is licensed under the GNU General Public License, version 3 or higher.
// Additional exceptions apply. For full license details, see LICENSE.txt or visit:
//     https://alliedmods.net/amxmodx-license

//
// XS Library
//  Version 0.1
//
// MACROS THAT YOU CAN DEFINE BEFORE INCLUDING XS.INC:
//  XS_FLEQ_TOLERANCE:
//   Tolerance that is used for XS_FLEQ float nearly-equal comparisions
//    DEFAULT: 0.000005
//   XS_DEBUG
//    Turn debug logging on
//     DEFAULT: 0
//   XS_LOGBUFFER_SIZE
//    Buffer size for logging
//     DEFAULT: 512
//   XS_TASK_MAXPARAMS
//    Maximal parameter count for managed tasks
//     DEFAULT: 8
//   XS_TASK_MAXPARAMSIZE
//    Maximal size of string parameter for tasks
//   Has to be power of 2 and has to be >= 8
//     DEFAULT: 512
//  XS_TASK_MANAGEDIDS
//   Number of managed IDs for tasks.
//     DEFAULT: 2048
//   XS_REPLACEBUF_SIZE
//    DEFAULT: 3072
//
//
//  NOTES:
//   On AMX, VexdUM is required for some math functions
//
//   xs__ / XS__ (2 underscores) stuff is meant to be intern
//
//  untested: never tested
//  half-tested: succesfully used in other applications; not extensively tested in xs though
//  tested: fully tested
//
//  If you have any useful functions / ideas for functions, please tell me.
//

#if defined _xs_included
  #endinput
#endif
#define _xs_included

// **** CONFIG CHECK

#if !defined XS_FLEQ_TOLERANCE
	#define XS_FLEQ_TOLERANCE 0.000005
#endif

#if !defined XS_DEBUG
	#define XS_DEBUG 0
#endif

#if !defined XS_LOGBUFFER_SIZE
	#define XS_LOGBUFFER_SIZE 512
#endif

#if !defined XS_TASK_MAXPARAMS
	#define XS_TASK_MAXPARAMS 8
#endif

#if !defined XS_TASK_MAXPARAMSIZE
	#define XS_TASK_MAXPARAMSIZE 512
#endif

#if !defined XS_TASK_MANAGEDIDS
	#define XS_TASK_MANAGEDIDS 2048
#endif

#if !defined XS_REPLACEBUF_SIZE
	#define XS_REPLACEBUF_SIZE 3072
#endif


/****** DEBUGGING / LOGING FUNCTIONS ******/
enum xs_logtypes
{
	xs_debug,
	xs_message,
	xs_warning,
	xs_error,
	xs_fatalerror,
	xs__assertionfailed,
	
	// must come last
	xs_logtypes_count
}

stock const xs__logtypenames[xs_logtypes_count][] = {"DEBUG", "", "WARNING", "ERROR", "FATAL ERROR", "DEBUG ASSERTION FAILED"};

// tested
stock xs_log(xs_logtypes:logtype, {Float,_}:...)
{
	// WARNING: Don't try to use assert in here; it uses this func
	
	// Don't log debug if not in debug mode
	#if !XS_DEBUG
		if (logtype == xs_debug)
			return;
	#endif
	
	new buffer[XS_LOGBUFFER_SIZE+1];
	buffer[XS_LOGBUFFER_SIZE]=0;
	format_args(buffer, XS_LOGBUFFER_SIZE, 1 /* go from SECOND argument*/);
	new bool:addLogTypeName = strlen(xs__logtypenames[logtype]) ? true : false;
	
	// Use AMXX's logging system
	log_amx("%s%s%s", addLogTypeName ? xs__logtypenames[logtype] : "",
		addLogTypeName ? ": " : "", buffer);
}

// Assertion
// tested
stock xs_assertfunc({Float,_}:exp, const desc[])
{
	// Check exp
	if (exp)
		return 1; // ok
	
	// not ok
	
	// print info
	xs_log(xs__assertionfailed, "%s", desc);
	
	return 0;
}
#define xs_assert(%1,%2) if (!xs_assertfunc(%1,%2)) xs__global_null /= xs__global_null


// Assertion; only in debug mode
// untested; logical flow says it should work
#if XS_DEBUG
	#define xs_assert_dbg(%1,%2) if (!xs_assertfunc(%1,%2)) xs__global_null /= xs__global_null
#else
	#define xs_assert_dbg(%1,%2)
#endif

new xs__global_null = 0;

/****** MATH FUNCTIONS ******/

/****** BASIC STUFF ******/

// Returns -1 if num is negative, 0 if num is 0, 1 if num is positive
// tested
stock xs_sign(num)
{
	return (num < 0) ? -1 : ((num == 0) ? 0 : 1);
}

// Returns -1 if num is negative, 0 if num is 0, 1 if num is positive
// tested
stock xs_fsign(Float:num)
{
	return (num < 0.0) ? -1 : ((num == 0.0) ? 0 : 1);
}

// Returns absolute value
// tested
stock xs_abs(num)
{
	return (num < 0) ? -num : num;
}

// is power of 2? (== can be expressed as 1<<i)
// tested
stock xs_is_2power(x)
{
	return (x!=0) && ((x&(x-1))==0);
}

// degrees to radians
// tested
stock Float:xs_deg2rad(Float:x)
{
	return x * 0.017453292519943;
}

// tested
stock Float:xs_rad2deg(Float:x)
{
	return x * 57.29577951308232;
}

// untested, should work though
stock Float:xs_gra2rad(Float:x)
{
	return x * 0.015707963267948;
}

// untested, should work though
stock Float:xs_rad2gra(Float:x)
{
	return x * 63.66197723675813;
}

// Only works when there is no whitespace between %1, the comma and %2...
// tested
#define XS_FLEQ(%1,%2) (((%1) <= ((%2) + XS_FLEQ_TOLERANCE)) && ((%1) >= ((%2) - XS_FLEQ_TOLERANCE)))

// 1/sqrt
// tested
stock Float:xs_rsqrt(Float:x)
{
	return 1.0 / floatsqroot(x);
}

// sqrt
// tested
stock Float:xs_sqrt(Float:x)
{
	return floatsqroot(x);
}

// These functions generate errors if you use the macros with wrong parameter count.
stock Float:xs_fabs(Float:pa)
{
	#pragma unused pa
	new rawr = you_need_one_param_for_fabs;
	rawr = warning_below_shows_line_number;
	#pragma unused rawr
}
stock Float:xs_asin(Float:pa,Float:pb)
{
	#pragma unused pa,pb
	new rawr = you_need_two_params_for_asin;
	rawr = warning_below_shows_line_number;
	#pragma unused rawr
}
stock Float:xs_sin(Float:pa,Float:pb)
{
	#pragma unused pa,pb
	new rawr = you_need_two_params_for_sin;
	#pragma unused rawr
}
stock Float:xs_acos(Float:pa,Float:pb)
{
	#pragma unused pa,pb
	new rawr = you_need_two_params_for_acos;
	rawr = warning_below_shows_line_number;
	#pragma unused rawr
}
stock Float:xs_cos(Float:pa,Float:pb)
{
	#pragma unused pa,pb
	new rawr = you_need_two_params_for_cos;
	rawr = warning_below_shows_line_number;
	#pragma unused rawr
}
stock Float:xs_atan(Float:pa,Float:pb)
{
	#pragma unused pa,pb
	new rawr = you_need_two_params_for_atan;
	rawr = warning_below_shows_line_number;
	#pragma unused rawr
}
stock Float:xs_atan2(Float:pa,Float:pb)
{
	#pragma unused pa,pb
	new rawr = you_need_two_params_for_atan2;
	rawr = warning_below_shows_line_number;
	#pragma unused rawr
}
stock Float:xs_tan(Float:pa, Float:pb)
{
	#pragma unused pa,pb
	new rawr = you_need_two_params_for_tan;
	rawr = warning_below_shows_line_number;
	#pragma unused rawr
}

#define xs_fabs(%1) floatabs(%1)
#define xs_asin(%1,%2) floatasin(%1, %2)
#define xs_sin(%1,%2) floatsin(%1, %2)
#define xs_acos(%1,%2) floatacos(%1, %2)
#define xs_cos(%1,%2) floatcos(%1, %2)
#define xs_atan(%1,%2) floatatan(%1, %2)
#define xs_atan2(%1,%2) floatatan2(%1, %2)
#define xs_tan(%1,%2) floattan(%1, %2)

/****** RANDOM NUMBERS ******/
// This routine comes from the book "Inner Loops" by Rick Booth, Addison-Wesley
// (ISBN 0-201-47960-5). This is a "multiplicative congruential random number
// generator" that has been extended to 31-bits

stock xs__internalseed=0x546875;

#define XS__IL_RMULT 1103515245

// tested
stock xs_seed(seed)
{
	xs__internalseed = seed;
}

// tested
stock xs_irand()
{
	new lo, hi, ll, lh, hh, hl;
	new result;
	
	lo = xs__internalseed & 0xffff;
	hi = xs__internalseed >> 16;
	xs__internalseed = xs__internalseed * XS__IL_RMULT + 12345;
	ll = lo * (XS__IL_RMULT  & 0xffff);
	lh = lo * (XS__IL_RMULT >> 16    );
	hl = hi * (XS__IL_RMULT  & 0xffff);
	hh = hi * (XS__IL_RMULT >> 16    );
	result = xs_abs(((ll + 12345) >> 16) + lh + hl + (hh << 16));
	return result;
}

// tested
stock Float:xs_frand()
{
	return float(xs_irand()) / float(xs_get_maxnum());		// -1/2 should be the biggest possible positive number
}

// tested
stock xs_irand_range(pmin, pmax)
{
	xs_assert_dbg(pmax - pmin >= 0, "xs_irand_range: pmin > pmax");
	new i = pmin + floatround(xs_frand() * float(pmax - pmin));
	if (i > pmax)
		i = pmax;
	return i;
}

/****** VECTORS & PLANES ******/

// *** vectors

// Set vec components to values
// tested
stock xs_vec_set(Float:vec[], Float:x, Float:y, Float:z)
{
	vec[0] = x;
	vec[1] = y;
	vec[2] = z;
}

// Add vec
// tested
stock xs_vec_add(const Float:in1[], const Float:in2[], Float:out[])
{
	out[0] = in1[0] + in2[0];
	out[1] = in1[1] + in2[1];
	out[2] = in1[2] + in2[2];
}

// Subtract vec
// untested, but should work
stock xs_vec_sub(const Float:in1[], const Float:in2[], Float:out[])
{
	out[0] = in1[0] - in2[0];
	out[1] = in1[1] - in2[1];
	out[2] = in1[2] - in2[2];
}

// Are vectors equal?
// untested, but should work
stock bool:xs_vec_equal(const Float:vec1[], const Float:vec2[])
{
	return (vec1[0] == vec2[0]) && (vec1[1] == vec2[1]) && (vec1[2] == vec2[2]);
}

// Are vectors nearly equal?
// tested
stock bool:xs_vec_nearlyequal(const Float:vec1[], const Float:vec2[])
{
	return XS_FLEQ(vec1[0], vec2[0]) && XS_FLEQ(vec1[1], vec2[1]) && XS_FLEQ(vec1[2], vec2[2]);
}

// multiply vector by scalar
// tested
stock xs_vec_mul_scalar(const Float:vec[], Float:scalar, Float:out[])
{
	out[0] = vec[0] * scalar;
	out[1] = vec[1] * scalar;
	out[2] = vec[2] * scalar;
}

// divide vector by scalar
// untested, but should work
stock xs_vec_div_scalar(const Float:vec[], Float:scalar, Float:out[])
{
	new Float:__tmp = 1.0 / scalar;
	out[0] = vec[0] * __tmp;
	out[1] = vec[1] * __tmp;
	out[2] = vec[2] * __tmp;
}

// Compute vector length
// tested
stock Float:xs_vec_len(const Float:vec[])
{
	return xs_sqrt(vec[0]*vec[0] + vec[1]*vec[1] + vec[2]*vec[2]);
}

// Normalize vec
// tested
stock xs_vec_normalize(const Float:vec[], Float:out[])
{
	new Float:invlen = xs_rsqrt(vec[0]*vec[0] + vec[1]*vec[1] + vec[2]*vec[2]);
	out[0] = vec[0] * invlen;
	out[1] = vec[1] * invlen;
	out[2] = vec[2] * invlen;
}

// Store the cross product of vec1 and vec2 in out
// tested
stock xs_vec_cross(const Float:vec1[], const Float:vec2[], Float:out[])
{
	out[0] = vec1[1]*vec2[2] - vec1[2]*vec2[1];
	out[1] = vec1[2]*vec2[0] - vec1[0]*vec2[2];
	out[2] = vec1[0]*vec2[1] - vec1[1]*vec2[0];
}

// Compute vec1 dot vec2
// tested
stock Float:xs_vec_dot(const Float:vec1[], const Float:vec2[])
{
	return vec1[0]*vec2[0] + vec1[1]*vec2[1] + vec1[2]*vec2[2];
}

// Negate vec into out
// untested, but should work
stock xs_vec_neg(const Float:vec[], Float:out[])
{
	out[0] = -vec[0];
	out[1] = -vec[1];
	out[2] = -vec[2];
}

// Copy vec
// untested, but should work
stock xs_vec_copy(const Float:vecIn[], Float:vecOut[])
{
	vecOut[0] = vecIn[0];
	vecOut[1] = vecIn[1];
	vecOut[2] = vecIn[2];
}

// Compute angle between vec1 and vec2
// tested
stock Float:xs_vec_angle(const Float:vec1[], const Float:vec2[])
{
	return xs_rad2deg(xs_acos(xs_vec_dot(vec1, vec2), radian));
}

// Reflect vec about normal
// untested
stock xs_vec_reflect(const Float:vec[], const Float:normal[], Float:out[])
{
	// normalize(vec) - (normal * 2.0 * (tmp . normal)) * length(vec)
	
	new Float:tmp1[3];
	xs_vec_normalize(vec, tmp1);
	
	// tmp1 - (normal * 2.0 * (tmp . normal)) * length(vec)
	
	new Float:tmp2[3];
	xs_vec_mul_scalar(normal, 2.0, tmp2);
	xs_vec_mul_scalar(tmp2, xs_vec_dot(tmp1, normal), tmp2);
	
	// tmp1 - tmp2 * length(vec)
	xs_vec_mul_scalar(tmp2, xs_vec_len(vec), tmp2);
	
	// tmp1 - tmp2
	xs_vec_sub(tmp1, tmp2, out);
}

// Turn a 3D vector into a 2D vector
stock xs_vec_make2d(const Float:vec[3], Float:out[2])
{
	out[0] = vec[0];
	out[1] = vec[1];
}

// *** planes

// normal
#define XS_PLANE_A 0
#define XS_PLANE_B 1
#define XS_PLANE_C 2
// plane shift distance
#define XS_PLANE_D 3


// Set a plane to specific values
// tested
stock xs_plane_set(Float:plane[], Float:a, Float:b, Float:c, Float:d)
{
	plane[XS_PLANE_A] = a;
	plane[XS_PLANE_B] = b;
	plane[XS_PLANE_C] = c;
	plane[XS_PLANE_D] = d;
}

// Construct a plane out of 3 points
// tested
stock xs_plane_3p(Float:plane[], const Float:p1[], const Float:p2[], const Float:p3[])
{
	new Float:normalA[3], Float:normalB[3];
	
	// normalA = Normalize(p3 - p1);
	normalA[0] = p3[0] - p1[0];
	normalA[1] = p3[1] - p1[1];
	normalA[2] = p3[2] - p1[2];
	xs_vec_normalize(normalA, normalA);
	
	// normalB = Normalize(p3 - p2);
	normalB[0] = p3[0] - p2[0];
	normalB[1] = p3[1] - p2[1];
	normalB[2] = p3[2] - p2[2];
	xs_vec_normalize(normalB, normalB);
	
	// plane normal = Normalize(normalA cross normalB)
	xs_vec_cross(normalA, normalB, plane);
	xs_vec_normalize(plane, plane);
	
	// plane shift distance = (-p1) dot plane normal
	new Float:__tmp[3];
	xs_vec_neg(plane, __tmp);
	plane[XS_PLANE_D] = xs_vec_dot(__tmp, p1);
	
}

// untested, but should work
stock bool:xs_plane_equal(const Float:plane1[], const Float:plane2[])
{
	if (	(plane1[0] == plane2[0]) &&
		(plane1[1] == plane2[1]) &&
		(plane1[2] == plane2[2]) &&
		(plane1[3] == plane2[3]))
		return true;
	return false;
}

// untested, but should work
stock bool:xs_plane_nearlyequal(const Float:plane1[], const Float:plane2[])
{
	if (	XS_FLEQ(plane1[0], plane2[0]) &&
		XS_FLEQ(plane1[1], plane2[1]) &&
		XS_FLEQ(plane1[2], plane2[2]) &&
		XS_FLEQ(plane1[3], plane2[3]))
		return true;
	return false;
}

// Compute distance between plane and point
// tested
stock Float:xs_plane_dst2point(const Float:plane[], const Float:point[])
{
	// return normal dot point + D
	return xs_vec_dot(plane, point) + plane[XS_PLANE_D];
}

// Checks whether plane intersects with the ray starting and rayStart and going to rayDir direction.
// If yes, returns true and sets out to the intersection point
// Otherwise, returns false
// tested
stock bool:xs_plane_rayintersect(const Float:plane[], const Float:rayStart[], const Float:rayDir[], Float:out[])
{
	new Float:a = xs_vec_dot(plane, rayDir);
	
	if (a == 0.0)
		return false;		// ray is parallel to plane
	
	// if (distance plane<->(rayStart + rayDir) > distance plane<->rayStart) and both have the same sign, the ray
	// goes away from the plane
	new Float:rsplusrd[3];
	xs_vec_add(rayStart, rayDir, rsplusrd);
	new Float:dst1 = xs_plane_dst2point(plane, rsplusrd);
	new Float:dst2 = xs_plane_dst2point(plane, rayStart);
	if (xs_fabs(dst1) > xs_fabs(dst2) && xs_fsign(dst1) == xs_fsign(dst2))
		return false;
	
	
	// out = rayStart - rayDir * ((distance plane<->rayStart) / a)
	new Float:__tmp[3];
	xs_vec_mul_scalar(rayDir, xs_plane_dst2point(plane, rayStart) / a, __tmp);
	// out = rayStart - tmp
	xs_vec_sub(rayStart, __tmp, out);
	
	return true;
}

// Is point on plane?
// tested
stock bool:xs_point_onplane(const Float:plane[], const Float:point[])
{
	return XS_FLEQ(xs_plane_dst2point(plane, point), 0.0);
}

// Project point on plane
// tested
stock xs_projpoint_onplane(const Float:plane[], const Float:point[], Float:out[])
{
	new Float:__tmp[3];
	// out = point - (plane normal * distance point<->plane)
	xs_vec_copy(plane, __tmp);
	xs_vec_mul_scalar(__tmp, xs_plane_dst2point(plane, point), __tmp);
	xs_vec_sub(point, __tmp, out);
}

// Copy plane
// untested, but should work
stock xs_plane_copy(const Float:planeIn[], Float:planeOut[])
{
	planeOut[0] = planeIn[0];
	planeOut[1] = planeIn[1];
	planeOut[2] = planeIn[2];
	planeOut[3] = planeIn[3];
}

/****** HL ENGINE SPECIFIC STUFF ******/
// Compute forward, right and up vector from angles
// half-tested

// angle indexes
#define	XS_PITCH				0		// up / down
#define	XS_YAW					1		// left / right
#define	XS_ROLL					2		// fall over

stock xs_anglevectors(const Float:angles[3], Float:fwd[3], Float:right[3], Float:up[3])
{
	// sin (s) and cos (c) for yaw (y), pitch (p) and roll (r)
	new Float:sr, Float:sp, Float:sy, Float:cr, Float:cp, Float:cy;
	
	sy = xs_sin(angles[XS_YAW], degrees);
	cy = xs_cos(angles[XS_YAW], degrees);
	sp = xs_sin(angles[XS_PITCH], degrees);
	cp = xs_cos(angles[XS_PITCH], degrees);
	sr = xs_sin(angles[XS_ROLL], degrees);
	cr = xs_cos(angles[XS_ROLL], degrees);
	
	fwd[0] = cp*cy;
	fwd[1] = cp*sy;
	fwd[2] = -sp;
	
	right[0] = (-1*sr*sp*cy + -1*cr*-sy);
	right[1] = (-1*sr*sp*sy + -1*cr*cy);
	right[2] = -1*sr*cp;
	
	up[0] = (cr*sp*cy + -sr*-sy);
	up[1] = (cr*sp*sy + -sr*cy);
	up[2] = cr*cp;
}
/****** STRING FUNCS *******/

// tested
stock xs_strchr(const str[], chr)
{
	for (new i = 0; str[i] != 0; ++i)
	{
		if (str[i] == chr)
			return i;
	}
	return -1;
}

// by JGHG, adapted
// removes charstotrim number of charactes from stringtotrim's
//  - beginning if fromleft is true
//  - end if fromleft is false
// tested
stock xs_strtrim(stringtotrim[], charstotrim, bool:fromleft = true)
{
	if (charstotrim <= 0)
    		return;
	
	if (fromleft)
	{
		new maxlen = strlen(stringtotrim);
		if (charstotrim > maxlen)
			charstotrim = maxlen;

		// In format, input and output regions can overlap
		format(stringtotrim, maxlen, "%s", stringtotrim[charstotrim]);
	}
	else
	{
		new maxlen = strlen(stringtotrim) - charstotrim;
		if (maxlen < 0)
			maxlen = 0;

		// In format, input and output regions can overlap
		format(stringtotrim, maxlen, "%s", stringtotrim);
	}
}

// by xeroblood, adapted
// copies characters from oldmsg to newmsg, starting at start and ending at end (_includes_ end).
// terminates newmsg with 0
// if outlen is positive, it specifies the maximal number of characters to be copied.
// otherwise, assumes that newmsg is at least end-start+1 characters long.
// tested
stock xs_strmid(const oldmsg[], newmsg[], start, end, outlen=-1)
{
	new len = strlen(oldmsg);
	
	if(start < 0)
		start = 0;
	
	++end;		// Include end
	
	if(end <= start || end > len)
		end = len;

	new j = 0, i = start;
	for(; (i < end) && (outlen--);)
		newmsg[j++] = oldmsg[i++];
	
	newmsg[j] = 0;
}

// by xeroblood, adapted
// maxelems: maximal number of elements in output, elemsize: maximal size of one element
// tested
stock xs_explode(const input[], output[][], delimiter, maxelems, elemsize)
{
	new nIdx = 0;
	new nLen = 0;

	new copied = 0;
	while(nLen < strlen(input) && nIdx < maxelems)
	{
		copied = copyc(output[nIdx++], elemsize, input[nLen], delimiter);
		if (copied == elemsize)
		{
			// maybe it got force-stopped because of maxsize
			// so check whether we have to skip something
			if (input[nLen + copied] != delimiter && input[nLen + copied] != 0)
			{
				new found = xs_strchr(input[nLen + copied], delimiter);
				if (found == -1)
					break;
				copied += found;
			}
		}
		
		nLen += copied + 1;	// +1: skip delimiter
	}
	return nIdx;
}

// returns number of cells written.
stock xs_implode(output[], outsize, delimiter, const input[][], elemsnum)
{
	new pos = 0;
	new copied;
	for (new i = 0; i < elemsnum; ++i)
	{
		copied = copy(output[pos], outsize - pos, input[i]);
		pos += copied;
		if (pos >= outsize)
			return outsize;
		// append delimiter
		output[pos] = delimiter;
		++pos;
		// last check
		if (pos >= outsize)
			return outsize;
	}
	
	output[--pos] = 0;		// The last char would be delimiter, so skip it.
	return pos;
}


stock xs__replace_buf[XS_REPLACEBUF_SIZE];
// Replace all occurencies of what in text with with
// Returns number of (also partially if trimmed by len) replaced items.
stock xs_replace(text[], len, const what[], const with[])
{
	new occur = 0;
	new i = 0;
	new bufPos = 0;
	new replaceLen = strlen(with);
	new whatLen = strlen(what);
	for (; text[i]; ++i)
	{
		if (text[i] == what[0])
		{
			new posInWhat=0;
			new j;
			for (j = i; j-i < replaceLen && text[j]; ++j, ++posInWhat)
			{
				if (text[j] != what[posInWhat])
					break;
			}
			if (whatLen == posInWhat)
			{
				for (new i2 = 0; i2 < replaceLen && bufPos < XS_REPLACEBUF_SIZE; ++i2)
					xs__replace_buf[bufPos++] = with[i2];
				i = j - 1;
				++occur;
				if (bufPos >= XS_REPLACEBUF_SIZE)
					return occur;
				continue;
			}
		}
		if (bufPos >= XS_REPLACEBUF_SIZE)
			return occur;
		xs__replace_buf[bufPos++] = text[i];
	}
	xs__replace_buf[bufPos] = 0;
	copy(text, len, xs__replace_buf);
	return occur;
}

// replaces all occurencies of what in text with with
// Returns number of replaced items.
stock xs_replace_char(text[], len, what, with)
{
	// let the xs_replace function do the work
	new arr[4];
	arr[0] = what;
	arr[1] = 0;
	arr[2] = with;
	arr[3] = 0;
	
	return xs_replace(text, len, arr[0], arr[2]);
}

/****** MISC FUNCS *******/
// sets namestr to name of the command identified by cid
// half-tested
stock xs_concmd_name(cid, namestr[], namelen)
{
	new dummy1;
	new dummy2[1];
	get_concmd(cid, namestr, namelen, dummy1, dummy2, 0, 0);
}

// Checks whether there are at least num free visible slots
// half-tested
stock bool:xs_freevisibleslots(num)
{	
	new maxplayers = get_cvar_num("sv_visiblemaxplayers");
	if (maxplayers <= 0)
		maxplayers = MaxClients;
	
	return (get_playersnum(1) <= maxplayers-num) ? true : false;
}

// Returns biggest possible positive number
stock xs__maxnum = 0;
// tested
stock xs_get_maxnum()
{
	if (!xs__maxnum)
	{
		// build it
		xs__maxnum = ((1 << (cellbits - 2)) - 1 ) | (1 << (cellbits - 2));
		/*
		new bits = get_cellsize() * 8 - 1;
		for (new i = 0; i < bits; ++i)
			xs__maxnum |= 1 << i;
		*/
	}
	return xs__maxnum;
}

// tested
stock xs_get_minnum()
{
	return xs_get_maxnum() + 1;
}


// *** The following two functions were created by Damaged Soul.

// Max messages reserved by engine (DO NOT MODIFY)
#define XS__MAX_ENGINE_MESSAGES 63
// Max possible messages for mod, is 255 really the limit?
#define XS__MAX_POSSIBLE_MESSAGES 255

// Returns max number of messages for mod
stock xs_get_maxmessages()
{
	new name[2];
	
	for (new i = XS__MAX_ENGINE_MESSAGES + 1; i <= XS__MAX_POSSIBLE_MESSAGES; i++)
		if (!get_user_msgname(i, name, 1))
			return i - 1;
	    
	return XS__MAX_POSSIBLE_MESSAGES;
}

// Returns true if msgid is a valid message
stock bool:xs_is_msg_valid(msgid)
{
	new name[2];
	new retval = get_user_msgname(msgid, name, 1);
	
	if (msgid < 1 || (msgid > XS__MAX_ENGINE_MESSAGES && !retval))
		return false;
	
	return true;
}

/****** MANAGED TASKS ******/

// ***** managed task ids
stock xs_find_freetaskid()
{
	for (new i = 1; i <= XS_TASK_MANAGEDIDS; ++i)
	{
		if (!task_exists(i))
			return i;
	}
	return -1;
}

// ***** managed tasks
enum xs_paramtypes
{
	xs_invalid = 0,
	xs_int,
	xs_float,
	xs_string
}

// new task
stock xs__TaskParam[	1 +						// number of parameters
			XS_TASK_MAXPARAMS +						// parameter types
			(XS_TASK_MAXPARAMSIZE char) * XS_TASK_MAXPARAMS];		// space for len + value

stock Float:xs__TaskInterval = 0.0;
stock xs__TaskFlags[5];
stock xs__TaskFunc[48];
stock xs__TaskId;
stock xs__TaskRepeat;

#define xs__TaskParamCount xs__TaskParam[0]
#define xs__TaskParamType[%1] xs__TaskParam[1 + %1]

#define xs__TaskParamValue[%1] xs__TaskParam[1 + XS_TASK_MAXPARAMS + (%1 * (XS_TASK_MAXPARAMSIZE char))]


// incoming task
stock xs__ITaskParam[	1 +						// number of parameters
			XS_TASK_MAXPARAMS +						// parameter types
			(XS_TASK_MAXPARAMSIZE char) * XS_TASK_MAXPARAMS];		// space for len + value
stock xs__ITaskId;

#define xs__ITaskParamCount xs__ITaskParam[0]
#define xs__ITaskParamType[%1] xs__ITaskParam[1 + %1]

#define xs__ITaskParamValue[%1] xs__ITaskParam[1 + XS_TASK_MAXPARAMS + (%1 * (XS_TASK_MAXPARAMSIZE char))]

// tested
stock xs_task_begin(Float:interval, const func[], id = 0, const flags[] = "", repeat = 0)
{
	xs_assert(xs__TaskInterval == 0.0, "New xs_task_begin called before xs_task_end");
	
	xs__TaskInterval = interval;
	if (xs__TaskInterval < 0.1)
		xs__TaskInterval = 0.1;
	
	copy(xs__TaskFunc, 47, func);
	xs__TaskId = id;
	copy(xs__TaskFlags, 4, flags);
	xs__TaskRepeat = repeat;
	
	xs__TaskParamCount = 0;
}

// tested
stock xs_task_pushint(value, bool:__isfl=false /*internal use only*/)
{
	xs_assert(xs__TaskInterval, "xs_task_push* called without xs_task_begin");
	if (xs__TaskParamCount >= XS_TASK_MAXPARAMS)
		return 0;
		
	xs__TaskParamType[xs__TaskParamCount] = __isfl ? xs_float : xs_int;
	xs__TaskParamValue[xs__TaskParamCount] = value;
	
	++xs__TaskParamCount;
	return 1;
}

// tested
stock xs_task_pushfl(Float:value)
{
	return xs_task_pushint(_:value, true);
}

// tested
stock xs_task_pushstr(const value[])
{
	xs_assert(xs__TaskInterval, "xs_task_push* called without xs_task_begin");
	if (xs__TaskParamCount >= XS_TASK_MAXPARAMS)
		return 0;
		
	xs__TaskParamType[xs__TaskParamCount] = xs_string;
	strpack(xs__TaskParamValue[xs__TaskParamCount], value);
	++xs__TaskParamCount;
	return 1;
}

// tested
stock xs_task_end()
{
	xs_assert(xs__TaskInterval, "xs_task_end called without xs_task_begin");
	
	// find a task id if needed
	if (xs__TaskId == -1)
	{
		xs__TaskId = xs_find_freetaskid();
		if (xs__TaskId == -1)
		{
			// not found
			xs__TaskInterval = 0.0;
			return -1;
		}
	}
	
	set_task(xs__TaskInterval, xs__TaskFunc, xs__TaskId, xs__TaskParam, 
		1 + xs__TaskParamCount * (XS_TASK_MAXPARAMSIZE char), xs__TaskFlags, xs__TaskRepeat);
	
	xs__TaskInterval = 0.0;
	
	return xs__TaskId;
}


// tested
#define XS_MAKE_TASKFUNC(%1) public %1(const _xs__taskparam[], _xs__taskid) if(xs__task_setup(_xs__taskparam, _xs__taskid))

// tested
stock xs__task_setup(const param[], taskid)
{
	xs__ITaskId = taskid;
	new len = 1 + param[0] * (XS_TASK_MAXPARAMSIZE char);
	for (new i = 0; i < len; ++i)
		xs__ITaskParam[i] = param[i];
	return 1;
}

// tested
stock xs_task_readid()
{
	return xs__ITaskId;
}

// tested
stock xs_task_paramcount()
{
	return xs__ITaskParamCount;
}

// tested
stock xs_paramtypes:xs_task_paramtype(paramid)
{
	if (paramid < 0 || paramid >= xs__ITaskParamCount)
		return xs_invalid;
	
	return xs_paramtypes:xs__ITaskParamType[paramid];
}

// tested
stock xs_task_paramint(paramid)
{
	if (paramid < 0 || paramid >= xs__ITaskParamCount)
		return 0;
	if (xs__ITaskParamType[paramid] != _:xs_int)
		return 0;
	
	return xs__ITaskParamValue[paramid];
}

// tested
stock Float:xs_task_paramfl(paramid)
{
	if (paramid < 0 || paramid >= xs__ITaskParamCount)
		return 0.0;
	if (xs__ITaskParamType[paramid] != _:xs_float)
		return 0.0;
	
	return Float:xs__ITaskParamValue[paramid];
}

// tested
stock xs_task_paramstr(paramid, out[], maxlen)
{
	#pragma unused maxlen
	
	if (paramid < 0 || paramid >= xs__ITaskParamCount)
		return 0;
	if (xs__ITaskParamType[paramid] != _:xs_string)
		return 0;
	
	strunpack(out, xs__ITaskParamValue[paramid]);
	return 1;
}
